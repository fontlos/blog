---
feature: false
title: 一文速通 Python 基础
date: 2024-03-06 00:27:10
abstracts: 非官方的 Python 极简教程, 主要面向学校计算机课需要用到 Python 或者有专门的 Python 课程且毫无基础的小朋友们, 通过一篇文章, 从安装开始讲解 Python 最基本的知识
tags:
    - Python
categories:
    - Course
cover: https://fontlos.com/icons/logo.png
---

非官方的 Python 极简教程, 不会完全按照常规教程的体系进行, 适合快速熟悉语法, 并且会介绍一些与基础相关但冷门的内容

# Python 极简介绍

**Python** 是一门 **高层次的** **动态类型的** **弱类型的** **解释型** 语言, 下面逐一解释这些名词的含义

- 高层次: 对比汇编这种底层的低级语言, C/C++ 这种偏底层的中级语言, Python是高度抽象的, 更加接近自然语言, 关键字很少, 便于理解记忆
- 动态类型: 一个软件在运行时的状态被称为 **Runtime (运行时)**, 而动态类型就是指只有在运行时才会进行类型检查, 这意味着变量的数据类型不是在编译期确定的, 而是在程序运行过程中才会绑定的
- 弱类型: 弱类型语言允许变量被赋予不同的数据类型, 不需要任何显式的类型转换, 比如一个整数类型, 既可以被赋值数字 0, 也可以被赋值字符 "0"
- 解释型: 指不需要被编译成计算机可以直接识别的机器码, 而是通过解释器进行逐行解释在运行时翻译执行

# 环境配置 (以 Windows 为例)

## Python 安装

可以直接下载并运行官网提供的 [安装器](https://www.python.org/ftp/python/3.12.2/python-3.12.2-amd64.exe), 安装过程建议勾选 **Add Python 3.x to PATH** (用于自动添加环境变量) 并选择自定义安装, 在设置 **Optional Features** 界面最好将 **pip, tcl/tk, Python test suite** 等项全部勾选上. 强烈建议选择自定义的安装路径并保证路径中没有中文

也可以手动下载 [压缩包](https://www.python.org/ftp/python/3.12.2/python-3.12.2-embed-amd64.zip), 解压到任意目录, 并手动添加到环境变量, 注意, 这种版本的 Python 只提供基本功能, 连创建虚拟环境和安装 Python 包都需要手续手动修改, 不是有必要的话不建议使用

通过在终端执行

```sh
python -V
```

如果显示了版本信息, 则安装完成

你也可以直接通过在终端输入 `python` 并回车进入终端交互式页面编写一次性代码, 当然更多情况下我们还是会使用代码编辑器进行编码

## 值得一试的 Python 管理器 -- UV (可选)

[UV](https://github.com/astral-sh/uv) 是一个用 Rust 编写的, 拥有及高性能的 **All In One** Python 管理器, 从多版本的 Python 安装, Python 项目组织, Python 虚拟环境创建, Python 包导入等全方位包揽的 Python 的一切, 为了保持一个干净整洁的 Python 环境, 十分值得尝试一下

官方文档在 [这里](https://docs.astral.sh/uv), 我们简单介绍一下

如果你想自定义安装位置, 需要先在系统环境变量添加一条 `UV_INSTALL_DIR` 环境变量, 对于 Windows 平台, 使用以下命令即可安装

```sh
powershell -ExecutionPolicy ByPass -c "irm https://astral.sh/uv/install.ps1 | iex"
```

安装完成后, 还有两个比较有用的环境变量

- `UV_PYTHON_INSTALL_DIR`: 这是 UV 下载安装不同版本的 Python 的路径
- `UV_PYTHON_INSTALL_MIRROR`: UV 默认从 https://github.com/indygreg/python-build-standalone/releases/download 下载 Python, 如果你访问 Github 的速度很慢, 这个环境变量可以设置代理, 能够加速 Github Release `indygreg/python-build-standalone/releases/download` 下载的都可以

下面介绍一些常用功能

```sh
# 安装最新稳定版 CPython
uv python install
# 安装特定版本的 Python, 可以同时安装多个, 也可以指定安装 PyPy 而非 CPython版
uv python install 3.10 3.12 pypy@3.10
# 创建一个完整的 Python 项目
uv init <Project>
# 初始化一个虚拟环境, 可以跟上 `-p` 参数指定 Python 版本, 可以跟上目录, 否则在当前目录初始化环境
# 需要在命令行根据你的系统手动运行 `<Folder>\Scripts\activate` 脚本来激活环境
uv venv -p 3.12 <Folder>
# 安装 Python 包
uv add <Package>
# 运行一个 Python 文件
uv run <file>
```

## 编辑器安装配置

最专业的 **Python IDE (集成开发环境)** 当然是 Jetbrains 的 [Pycharm](https://www.jetbrains.com/pycharm/download/), 但对于初学者而言, 单个脚本或小型项目的编写更推荐使用 [VSCode](https://code.visualstudio.com/), 点击链接下载安装后, 只需要再安装 [Python](https://marketplace.visualstudio.com/items?itemName=ms-python.python) 插件即可

下面是其他的可能需要的插件

- [Chinese (Simplified)](https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans) 简体中文插件
- [Code Runner](https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner) 为 Python 等语言添加右键运行菜单
- [Codeium](https://marketplace.visualstudio.com/items?itemName=Codeium.codeium) 一个类似 Copilot 的 AI 代码提示插件

## 编辑器基本使用

打开 VSCode, 点击左下角齿轮图标, 点击设置, 在设置中搜索 `Auto Save`, 将 **Auto Save** 选项改成 `afterDelay`, 将 **Auto Save Delay** 选项改成 `1000`, 这表示每 1000 ms 自动保存一次文件

在左侧侧边栏选择打开一个空文件夹, 在文件夹内新建一个 `<文件名>.py` 文件. 接下来就可以在文件内编写代码了

编写完成后, 在对应文件上右键, 选择 **在集成终端中打开**, 在新打开的终端中输入

```sh
# 表示调用 Python 解释器执行这个文件, 注意空格
python <文件名>.py
```

如果安装了 **Code Runner** 插件, 你也可以在文件编辑区内右键选择 **Run Code**, 在文件上右键选择 **Run Code**, 或在文件编辑区右上角单击小三角来运行程序

# 熟悉 Python 世界的基本工具

## 注释

对于一个 Python 文件, 或者对于任何的不论是语言, 知识还是笔记, 适当的注解都是至关重要的. 这些能够帮助你在很长时间后快速熟悉起曾经写下的内容, 也能时刻提醒自己: 自己该做什么, 自己在做什么, 自己做了什么

即便 Python 已经是一门高度抽象的高级语言, 但自然语言仍然比这些代码更加易懂, 因此编写代码的时候, 注释尤为重要

在 Python 文件中可以使用以下两种注释

```py
# 一个井号后面的内容都将作为注释, 不会被执行, 这被称为单行注释
print("你好, 世界!") # 单行注释也可以放在代码的后面

"""
三组双引号之间是多行注释
这之间的所有内容都将被忽略
"""
```

在这同时我们也按照惯例写出了最简单的 Python 程序, 运行程序, 即可看到控制台输出了 `你好, 世界!`

## Print 控制台输出

接下来让我们认识一下第二个基本工具, 我们已经在上面见过它了: `print()` 函数. 这将是我们基础知识中最常用的一个函数, 它的意义和数学中的函数类似, 有函数的名字, 后面跟上一个小括号, 括号里面放函数的参数, 最后函数可以计算出一个值. 就像它的名字 "打印", 它的功能就是将括号中的参数打印到控制台中, 你不仅可以打印字符, 还可以打印变量, 和几乎所有的数据类型, 我们会在后面逐一介绍

# 变量与基本数据类型

## 变量

就像数学中可以 "令 x = 1" 那样, Python同样可以用极为类似的方式声明变量

```py
x = 1
```

对没错, 仅此而已, 就是那么简单, 用一个等号连接. 等号左边是变量的名字, 等号右边是变量的值

对于变量的名字, 理论上可以是符合下列规则的任何字符串

- 硬性规则
    - 由字母 (广义的 **Unicode 字符**, 不包括 **空格** 等特殊字符), 数字和下划线构成, 但不能以数字开头
    - 大小写敏感 (大写的 `a` 和小写的 `A` 是两个不同的变量)
    - 不要跟关键字 (有特殊含义的单词, 后面会讲到, 比如 `if`, `else` 等) 和系统保留字 (如刚刚学到的 `print` 函数的名字, 模块的名字等) 冲突
- PEP 8 要求:
    - 用小写字母拼写, 多个单词用下划线连接。
    - 受保护的实例属性用单个下划线开头 (后面会讲到)
    - 私有的实例属性用两个下划线开头 (后面会讲到)

还记得刚刚说的 `print` 函数可以用来打印变量吗, 快来试试吧

```py
x = 1
print(x) # 打印变量
```

## 基本数据类型

```py
string = "字符串"
string2 = '单引号也可以'
integer_num = -1 # 整数类型, 简称整型, 在 Python 3.x 之后已经不区分长整型和短整型了
float_num = 1.0 # 浮点数类型, 简称浮点型, 表示小数
inf = float("inf") # 正无穷
ninf = float("-inf") # 负无穷
bool_type = True # 布尔类型, 用于表示 "真" 或 "假", 只有两种值 "True" 或 "False"

big_num = 1_000_000 # 可以通过下划线分割长数字增加可读性
sci_num = 2e2 # 科学计数法, 表示 2.0 * 10^2, 自带至少一位小数, 200.0
sci_num2 = 2.000000e+02 # 标准科学计数法
bin_num = 0b101 # 以 "0b" 开头的是二进制数字类型, 注意后面跟的数字不能超过 1, 打印时默认以十进制输出
hex_num = 0x12abcdef # 以 "0x" 开头的是十六进制数字类型, 包含 0-9, a-f 这些字符, 打印时默认以十进制输出
```

## 打印数据类型

我们可以通过 `type()` 函数来获取一个变量的数据类型

```py
a = 1
print(type(a))
#这将会输出 "<class 'int'>"
```

# 格式化输出

就像上面说的, 二进制和十六进制的小数被打印时默认都是十进制, 那么有没有办法让它们以原来的样子输出呢? 这就要提到 **格式化输出** 了, 事实上我们可以为很多类型的输出自定义其格式

下面将会看到字符串内部有多种 `%` 开头的短字符串, 它们被称之为 **类型格式符**, 表示一个占位符并且具有特殊的格式, 在这个字符串外面再次用出现了单个 `%` ,其后面有一些值或者变量, 就是这些值或变量将会替换掉前面字符串中的占位符并继承它的格式

```py
print("%c" % "C") # %c 表示 char, 将值格式化为单个字符
print("%s" % "String") # %s 表示 string, 将值格式化为字符串
print("%d" % 1.0)  # %d 表示将值格式化为整数
# %2d 表示将值格式化为整数
# 用空格补齐到两位, 在左侧补齐, 即 " 1"
# 如果原始位数已经超出则不会修改原始数字
print("%2d" % 1)
# 和上面类似, 只不过在右侧补齐, 即 "1 "
print("%-2d" % 1)
# %02d 表示将值格式化为整数
# 用 "0" 补齐到两位, 在左侧补齐, 即 "01"
# 如果原始位数已经超出则不会修改原始数字
print("%02d" % 1)
# %.2d 表示将值格式化为整数, 但最少输出两位. 类似 %02d
print("%.2d" % 1)
print("%f" % 1) # %f 表示格式化为标准浮点数
print("%.2f" % 1) # %.2f 表示格式化为两位小数, 当然也可以指定其他精度
print('%e' % 1.0e3) # %e 表示将值格式化为标准科学计数法

# 多个类型格式符后面对应的多个参数需要用小括号包起来
# 这被称之为元组, 将会在下面提及
print('%s %s' % ("Hello", "World!"))
```

可以简单的通过逗号隔开打印多个值和变量, 也可以通过 **format** 将变量嵌入到字符串中, 这是在新版本 Python 中更推荐的做法

```py
name = "Job"

print("Hello ",name)
# 用 f 进行标记, 即可通过外面包裹花括号的方式将变量嵌入字符串
print(f"Hello {name}")
```

# 运算符

运算符, 顾名思义, 用于运算的符号, 可以用于值或变量的运算, 其中就有我们在数学中熟悉的数学运算符, 包括加减乘除等. 同样, 就像数学中先乘除后加减那样, Python中的运算符也有优先级之分

下面将按照优先级从高到低的顺序列出常见运算符, 仅加粗部分为常用运算符

- **小括号**: `()`, 最高级的运算符
- **索引/切片运算符**: `[]`, `[:]`, 其作用分别是
  - 取列表或元组元素下标
  - 取列表或元组切片
- 优先级比较特殊的运算符: `~`, `+`, `-`, 其功能分别如下
  - (不常用)位运算符中优先级较高的特例, 按位取反, 比如 `~4` 意思是 4 的 二进制 100 每一位进行取反, 即 001, 即十进制的 1
  - 取正负号
- **数学运算符**
  - `**`: 乘幂运算符, 例如 2 ** 3 = 8, **当幂次是既约真分数时至少自带一位小数**
  - `*`, `/`, `%`, `//`, 其功能分别是:
    - 乘法运算符
    - 除法运算符, **自带至少一位小数**
    - 除法取余数运算符, 例如 5 % 3 = 2
    - 除法取整数运算符, 例如 5 // 3 = 1
  - `+`, `-`: 加减法运算符
- (不常用)位运算符
  - `>>`, `<<`
    - 前者为右移运算符, 将数字类型的二进制值右移, 相当于除 2 运算, 例如 `4 >> 1` 意思是 4 的二进制 100 整体右移一位, 导致末尾 0 消失, 变成 10 即十进制的 2
    - 后者为左移运算符, 类比右移运算符, 相当于乘 2 运算, 例如 `1 << 10` 相当于 1 的二进制 1 整体左移十位, 空位补零变成 10000000000, 即十进制的 1024
    - 注: 在早期 CPU 上位运算的速度大于乘法运算, 但在现代 CPU 与编译器优化下, 二者区别已经不大了
  - `&` 按位与运算符, 对两个二进制执行按位与运算, 相同为 1 不同为 0, 例如 `4 & 5` 意思是 4 和 5 的二进制 100 和 101 按位与运算得到 110, 即十进制的6
  - `^`, `|`: 前者为按位异或运算符, 后者为按位或运算符
- 比较运算符, 返回布尔值
  - `>`, `<`, `>=`, `<=`, 判断是否大于, 小于, 大于等于, 小于等于
  - `==`, `!=`, 判断是否等于, 是否不等于
- 身份运算符: `is`, `is not`
- 成员运算符: `in`, `not in`
- **逻辑运算符**: `and`, `or`, `not`, 分别对应 **与, 或, 非** 运算
  - 与运算, 连接的两个表达式都为真时才为真, 例如 `5 > 4 and 6 > 5` 返回 `True`
    - 短路功能: 当与运算左侧为假时, 右侧表达式不进行计算, 整体即可判定为假
  - 或运算, 连接的两个表达式有一个为真时就为真, 例如 `5 > 4 or 5 > 6` 返回 `True`
    - 短路功能: 当或运算左侧为真时, 右侧表达式不进行计算, 整体即可判定为真
  - 非运算, 后接真时返回假, 后接假时返回真, 例如 `not 5 == 4` 返回真
- **赋值运算符**: `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `//=`, `**=`, `&=`
  - `=` 是最常用的赋值运算符
  - `+=` 加法赋值运算, 例如 `a += 6` 意思是 `a = a + 6`, 后面的其他运算符同理
  - (不常用) `&=` 是按位与赋值运算符
  - (不常用) 赋值运算符链式调用时从左往右运算, 比如 `a = b = c` 意思是 `a = (b = c)`, `a = b += 4` 意思是 `a = (b = b + 4)`

# 语法结构

之前我们所写的代码都是扁平结构的, 接下来我们就要学习 Python 的语法结构了. 不同于 C/C++ 等语言靠分号和大括号区分层级结构, Python 采用空格缩进来区分层级结构, 如果不理解, 看下面的例子即可

## 条件分支结构

类似于数学中的分段函数, Python也可以根据不同的条件执行不同的语句, Python 有两种条件分支结构

### If-Else 语句

通过 `if` - `else` 关键字组合, `if` 后接一个布尔表达式, 通常直接为布尔类型或者由比较运算符参与构成, 如果表达式为真, 则执行 `if` 之下的内容, 如果表达式为假, 则执行 `else` 之下的内容. 这非常符合自然语言的直觉, "如果 ... 为真, 那么 ..., 否则 ..."

例如判断一个数是否是偶数

```py
a = 4

if a % 2 == 0:
    print("a 是偶数")
else:
    print("a 是奇数")
```

当 `if` - `else` 语句用于返回值或者推导式语法时, 还有一种特殊的写法

```py
value1 if bool else value2
# 如果 bool 为真就返回 value1, 否则返回 value2
```

有的时候分支不止两条, 这时我们可以连用 `else if` 关键字, 后接一个布尔表达式, 意味"又如果 ... 为真, 那么 ...", 但是这样略有冗长, 且容易让层级显得参差不齐, 所以我们可以把这两个单词合并成 `elif`, 比如下面的例子

```py
score = 98

if score > 90:
    print("优秀!")
elif score > 80:
    print("良好")
elif score > 60:
    print("及格")
else:
    print("不及格...")
```

### Match-Case 语句

对于上面的最后一个例子, 如果分支条件是一些离散变量, 比如字符串, 或者一组固定的数字类型, 或是布尔变量, `if`-`else` 语句虽然也可以很好的解决, 但略显冗长. 好在在 Python 3.10 之后引入了一种类似于 Rust 语言中的模式匹配结构: `match`-`case` 语句, 下面来简单的看一个例子

```py
gender = "男"

match gender:
    case "男":
        print("是男孩子")
    case "女":
        print("是女孩子")
    case "保密":
        print("性别保密哦")
    case _: # 通过一个通配符来匹配其他剩下的所有情况, 当然也可以省略, 不像 Rust 那样严格要求穷尽式匹配
        print("也许是武装直升机)")
```

通过这个简单的例子, 就应该能体会到, 离散的分支条件越多, 这种方法的优势就越大

可以通过在 `case` 分支后面添加一个 `if` 语句增加额外的判断, 例如

```py
gender = "女"
age = 18

match gender:
    case "女" if age < 20:
        print("是青春少女")
```

`case` 关键字还可以捕获变量

```py
greeting = "Job"

match greeting:
    case "":
        print("Hello!")
    case name: # 这里新建了一个 name 变量用于捕获 greeting 这个变量
        print(f"Hello, {name}!")
```

这样的 `if` 条件被称为 **卫语句**, 字面意思, 保卫条件分支的语句

`match`-`case` 语句的其他功能这里就不再赘述, 感兴趣可以自行搜索

## 循环结构

类似于数学中的迭代, 当需要重复某件事若干次时, 就需要用到循环结构了, 循环结构同样有两种

### While 循环

`while` 是最简单的一种循环, 通过后接一个布尔表达式, 很容易从字面上理解其含义, "当 ... 为真时, 就 ..."

当然我们很少需要一个无法打破的无限循环, 因此需要在循环体内部加上一些可以帮助跳出循环的条件

```py
a = 0

while a < 10:
    print(a)
    a+=1
```

如此一来, 每次循环结束前, 循环条件 `a` 都会加一, 当 `a` 等于 `10` 时, 循环条件不再满足, 循环结束, 继续向下运行其他代码, 那么这段时间里将会打印 `0` 到 `9` 这些数字

当然我们也可以通过一些特殊手段提前跳出循环, 比如 `break` 关键字, 字面意思, 打破循环

```py
a = 0

while a < 10:
    if a == 3:
        break
    print(a)
    a+=1
```

如此一来, 当 `a` 增加到 `3` 时, 就会触发 `if` 语句内部的 `break`, 提前结束循环, 只会打印 `0`, `1`, `2` 三个数字

除此之外, 还有 `continue` 关键字, 字面意思, 继续循环, 但是不包括关键字下面的部分了, 即一旦遇到这个关键字, 立刻开始新一轮循环

```py
a = 0

while a < 10:
    if a == 3:
        a+=1 # 注意给循环条件加一, 以免无限循环
        continue
    print(a)
    a+=1
```

如此一来就会打印 `0` 到 `9` 里除了 `3` 的数字

值得注意的一点是, 当有 **多重嵌套** 循环时, `break` 和 `continue` 都只影响它们外面紧挨着的那一层循环

### For-In 迭代器

对于遍历一个集合元素, 使用 `while` 循环当然也能做到, 但是需要我们提前知道集合元素的长度并小心的设定循环条件, 很不方便. 这时就需要专门遍历集合以及范围的 `for`-`in` 循环了, 形如 `for item in range`, 意思是 "从 range 里面取出一个 item 并 ..." 并一直循环取遍每一个 `item`, 并且这个 `item` 是一个临时变量, 可以在循环体中使用

```py
cities = ["北京", "天津", "上海"]

for city in cities:
    print(city)
```

如果需要在迭代集合的同时获取元素的下标, 可以通过 `enumerate()` 函数

```py
cities = ["北京", "天津", "上海"]

for index, city in enumerate(cities):
    print(index, city)

# 这将会输出
# 0 北京
# 1 天津
# 2 上海
```

上面我们说到 `for` 循环还可以遍历一个范围, Python 中提供了一个非常灵活的函数用于生成整数范围: `range()`, 使用方法形如 `range(start, end, step)`, 非常类似于切片的用法

- start: 范围的起始, 且包括在范围中
- end: 范围的终止, 但不包括在范围中
- step: 步长, 从起始开始数值递增的值, 默认为 1
- 若 start < end, 则表示一个 **倒序** 范围

下面举几个简单的例子

- `range(10)`: 生成 `0` - `10` 但不包括 `10` 的整数范围, 即 `0` 到 `9` 十个数字
- `range(1, 10)`: 生成 `1` - `10` 但不包括 `10` 的整数范围
- `range(1, 10, 2)`: 生成 `1` - `10` 但不包括 `10` 的奇数范围
- `range(10, 0, -2)`: 生成 `10` - `0` 但不包括 `0` 的偶数范围

下面是与 `for` 循环结合的示例

```py
# 一个简单的 0 到 100 的求和
sum = 0

for i in range(101):
    sum+=1
print(sum)
```

# 集合类型

类似数学中的集合, 向量, Python 中也有集合类型, 用于储存多个值

## 有序集合

不同于多数语言, Python 的有序集合类型不包括数组, 而是用列表取而代之, 除此之外还有元组. 作为有序集合类型, 那么自然而然地可以理解, 每一个元素都有一个对应的编号. 但需要注意的是, 在包括 Python 在内的绝大多数编程语言中, **索引都是从 0 开始的**, 即不论是列表还是元组, 其第一个元素的编号或者说索引都是 0!

还有一点特殊的是, Python 中的索引可以是 *负值*, 表示 *倒数第几个元素*, 比如 `-1` 表示最后一个元素

- **列表 (List)**
  - 使用 `[]` 包裹的一组用逗号隔开的值
  - 值可以是任何类型, 可以是不同的类型, 甚至包括列表本身
  - 列表是可以被改变的, 可以通过列表内置的方法进行增加, 删除, 修改, 查询元素
    - 方法可以理解为一种数据类型自带的函数, 通过 `变量/值.[函数名]()` 调用
- **元组 (Tuple)**
  - 使用 `()` 包裹的一组用逗号隔开的值, 但 `()` 可以省略不写
  - 值可以是任何类型, 可以是不同的类型, 甚至包括元组本身
  - 元组一旦确定就不可以被更改

```py
my_list = [1, 1.5, "a", [0, True]]
my_tuple = 1, 1.5, "a", (0, True)

# 可以通过列表内置的一些方法操作列表
my_list.append(1) # 添加单个元素在列表末尾
# 此时 my_list = [1, 1.5, "a", [0, True], 1]
my_list.extend((2, 3)) # 添加多个元素在列表末尾, 注意需要括号
# 此时 my_list = [1, 1.5, "a", [0, True], 1, 2, 3]
my_list.insert(2,"b") # 在索引为 2 的元素后面插入值 "b"
# 此时 my_list = [1, 1.5, "a", "b", [0, True], 1, 2, 3]
my_list.remove([0, True]) # 删除指定值的元素
# 此时 my_list = [1, 1.5, "a", "b", 1, 2, 3]
my_list.pop(1) # 删除指定索引的元素
# 此时 my_list = [1,"a", "b", 1, 2, 3]
a = my_list.index(1) # 获取指定索引的值
# a = "a"
my_list.clear() # 清空列表
```

除了通过方法获得列表的值, 还可以直接通过索引或切片来获取, 还记得 [运算符](#运算符) 部分提到的 索引/切片运算符 吗

*下面的内容不仅对列表有效, 对元组同样有效*

- 索引
  - 通过在变量后追加一个方括号来获取索引元素, 形如 `variable[index]`
- 切片: 字面意思, 获取变量中的一段
  - 通过在变量后追加一个方括号来获取切片, 形如 `variable[start:end:step]`
  - start: 表示截取的起始索引, 且包含, 不写则截取到开头 (可以理解为从正方向的 0 号开始截取)
  - end: 表示截取的终止索引, 但不包含, 不写则截取到结尾 (可以理解为从负数索引截取到 0 号)
  - step: 步长, 即从起始索引开始, 每隔多少个元素选取一个元素, 不写默认为 1
  - 总之, 切片相当于从集合中取了一个 "左闭右开区间"

```py
arr = [1, 2, 3, 4, 5]
# 通过在列表或元组变量后追加一个方括号来获取索引元素或切片
# one 等于 arr 列表的第一个元素, 即 1
one = arr[0]
# five 等于 arr 列表的倒数第一个元素, 即 5
five = arr[-1]
# 根据参数省略规则, 截取索引为 0, 1, 2 的切片, 即 [1, 2, 3]
arr1 = arr[:3]
# 根据参数省略规则, 截取索引为 -2, -1 的切片, 即 [4, 5]
arr2 = arr[-2:]
# 根据参数省略规则, 截取整个列表作为切片
arr3 = arr[:]
# 根据参数省略规则, 截取整个列表作为切片, 但是步长是 `-1`, 即倒转整个切片
arr3 = arr[::-1]
```

列表有很多方便的函数

- `len()`: 获取集合元素的长度, 即内部有多少个元素
- `sum()`: 计算纯数字列表的和
- `max()`: 返回纯数字列表的最大值
- `min()`: 返回纯数字列表的最小值
- `index()`: 返回元素在集合中的下标, 如果有重复则返回找到的 **第一个** 对应元素的下标
- `in` 关键字: 判断某一元素是否在集合中, 返回布尔值

```py
arr = [1, 2, 3, 4, 5]

print(len(arr))     # 输出 5
print(sum(arr))     # 输出 15
print(arr.index(2)) # 输出 1
print(5 in arr)     # 输出 True
```

最后, 介绍一种针对于列表的创建方法, **推导式语法**

```py
arr = [i for i in range(11)] # 这将创建一个 0 - 10 的数字列表
arr = [i for i in range(10) if i % 2 == 0] # 这将创建一个 0 - 10 的偶数数字列表
```

## 字符串

字符串的本质可以理解为一个字符集合, 是相当重要的数据类型, 关于操作字符串的方法也很繁多, 很多集合类型的功能都可以直接使用, 比如 `enumerate()`, `len()`, `index()`, `in` 关键字等以及切片相关语法, 这里再介绍其他几个常用的

### 遍历字符串

首先就是对字符串进行遍历, 可以通过 `for` 循环轻松实现

```py
# 这将逐一打印 `H e l l o` 这些字符
for char in "Hello":
    print(char)
```

### ASCII 字符相关函数

对于 ASCII 字符, 每一个字符都对应一个序号, 比如 `a` 对应 `97`, 我们可以通过 `ord()` 和 `chr()` 函数轻松的完成这个关系转换

```py
print(ord("a")) # 这将输出 `97`
print(chr(97))  # 这将输出 `a`
```

同一字符大小写对应的序号不同, 我们可以依此区分大小写字符, 但 Python 还为我们提供了更方便的方法

```py
print("a".isupper()) # 判断字符是否为大写, 返回布尔值
print("a".islower()) # 判断字符是否为小写, 返回布尔值
```

### 拼接字符串

字符串可以简单的通过 `+` 运算符方便的拼接, 而对于大量字符串, 或者字符数组, 可以通过 `join` 方法进行快速拼接

```py
str_list = ["H", "e", "l", "l", "o"]
str = "".join(str_list)
print(str)
# 这将输出 `Hello`
```

你可能注意到了为什么 `join` 函数前面还有一个空字符串, 实际上, 这是一个 **连接符**, 留空就代表直接连接, 当然你也可以填入任何你想要的字符, 比如 `"-".join(str_list)` 就会生成 `H-e-l-l-o` 这个字符串

通过上面的学习, 现在我们可以只用一行代码过滤一个字符串中的大写字母, 就像这样

```py
str = "".join([c for c in "HabcEabcLabcLabcOabc" if c.isupper()])
# 这将会给 `str` 变量赋值 `HELLO`
```

### 切割字符串

有的时候面对一串路径字符 `path/to/file`, 我们需要截取其中一段的名字. 或者对于不规矩的日期字符串, `2024/01/05`, `2022/4/7`, 如果只是通过元素下标来获取其中的月份会变得很复杂. 或者对于一句话 `How are you` 我们需要将其拆分为单个的单词

这个时候我们就需要按照一个固定的 **分隔符** 来拆分字符, Python 中提供了 `split()` 函数实现这个功能, 比如

```py
# 这表示通过空格字符切割字符串
l = "How are you".split(" ")
# 这将会得到一个字符串列表 ["How", "are", "you"]
```

### 查找字符串

除了用 `in` 关键字判断某一子字符串是否存在于字符串中, 还可以用 `find()` 函数查找某一子字符串的在集合中第一次出现的位置

```py
str = "Hello"
print(str.find("l"))
# 这将输出 `2`
```

## 字典

**字典** 是一种无序集合类型, 在其它语言中通常被称为 **哈希表**, 是一种 **键值对应** 的数据结构, 用大括号包裹, 键值之间通过冒号隔开.

哈希表定义了一种 **一一映射** 的关系, 可以将哈希表理解成一个函数, 输入一个 **参数 (键 Key)**, 吐出来一个唯一对应的 **返回值 (值 Value)**. 事实上多数哈希表就是通过实现了这样一个 **哈希函数** (也叫 **散列函数**) 来实现键值之间的一一对应

首先是如何创建字典, 创建字典的第一种方法被称为 **字面量语法**, 可以理解为通过字面意义上的量创建字典, 如果你了解 JSON 会发现这很像 Object 对象

```py
scores = {
    'A': 1, # 即键 'A' 对应了一个值 1
    'B': 2,
    'C': 3
}

# 打印整个字典
print(scores)
```

接下来再介绍几种不是那么基础的字典创建方法

```py
# 创建字典的构造器语法
items1 = dict(
    one=1, # 即键 'one' 对应了一个值 1
    two=2,
    three=3,
    four=4
)

# 通过 zip 函数将两个序列压成字典
# 这是一种特殊的语法, 感兴趣可以自行查找更多信息
# 这里只需要知道键 'a' 对应值 `1`, 后面以此类推
items2 = dict(zip(['a', 'b', 'c'], '123'))

# 创建字典的推导式语法
# 创建 num 到 num^2 的键值映射, num 范围从 1 到 9
items3 = {num: num ** 2 for num in range(1, 10)}
print(items1, items2, items3)
```

现在让我们回到字面量语法创建字典的例子, 创建完成后, 就是类似于列表元组那样, 对字典进行增删改查等操作, 下面通过一些例子展示

```py
# 通过键可以获取字典中对应的值
print(scores['A'])
print(scores['B'])

# 对字典中所有键值对进行遍历
for key in scores:
    print(f'{key}: {scores[key]}')

# 更新字典中的元素

# 直接通过键更新值
scores['A'] = 4
scores['B'] = 5

# 通过方法更新键值对
scores.update(A=6, B=7)

# 注: 你可以直接通过对不存在的键进行更新来创建新的键值对!
# 这也是最简单的创建新的键值对的方法

# 此时字典内容为 {'A': 6, 'B': 7, 'C': 3}
print(scores)

# 直接通过键获取对应的值
# 如果键 'D' 在字典中就打印其对应的值
# 很明显键 'D' 并不存在, 直接打印会报错
if 'D' in scores:
    print(scores['D'])

# 通过 get 获取键对应的值, 且当键不存在时返回 None 而不是报错
print(scores.get('D'))

# get 方法当键不存在时可以设置默认值
# 此时不会创建了一个键 'D', 仅仅是 'D' 不存在, 所以返回一个 0
print(scores.get('D', 0))

# 删除字典中的元素
# 该方法从最后一对键值开始向上删除
# 实际上该方法在删除键值对的时候也会获取到键值对, 并转化成元组
# 比如这里可以将 ('C', 3) 打印出来, 也可以用一个变量承接
print(scores.popitem())
print(scores.popitem())
# 直接删除某个键值对, 并获取该键对应的值
print(scores.pop('A'))

# 清空字典
scores.clear()
print(scores)
```

# 函数

> "代码有很多种坏味道, 重复是最坏的一种!" --- Martin Fowler

数学中, 如果我们有需要反复往一个冗长的表达式中代入不同的值并计算, 为了让卷面清爽一些, 我们通常会将这个冗长的表达式包装成一个 **函数**, 在编程中当然也可以这样做

如果有一组相似且机械的行为, 那我们就可以将其抽象成函数以供调用, 比如阶乘的计算, 即使用循环来写这仍然是一个冗长的过程, 我们就可以定义一个函数, 输入数字, 就返回它的阶乘

在 Python 中, 我们通过 `def` 关键字来定义函数, 后面跟上函数的名字, 在后面跟上一个小括号, 里面可选的可以加入若干的函数内部所需的参数, 由于此时参数并没有确切的值, 只是起到参与运算的形式作用, 因此称之为 **形参**, 多个形参之间可以用逗号隔开

在函数内部的某个部分, 可选的可以使用 `return` 关键字返回一个变量作为函数的结果, 如果需要返回多个变量, 可以以元组或列表的形式返回

类似于 `break` 和 `continue` 关键字, 此时函数会立即停止执行

如果不显式写明的话, 则会默认返回函数最下面的一个变量

```py
def fac(num):
    result = 1
    for n in range(1, num + 1):
        result *= n
    return result

# 这样比如我们计算组合数时就不需要反复计算阶乘了
m = 5
n = 3
print(fac(m) // fac(n) // fac(m - n))
```

与其它语言不同的是, **Python 的函数参数可以有默认值**, 使用起来就像变量赋值一样简单

```py
def func(n=2):
    print(n)

func() # 输出 2
func(3) # 输出 3
```

**Python 的函数还支持可变参数**, 只需要在参数前面加上一个 `*`, 这表示可以传入 0 到任意个参数. 如果了解正则表达式可能会对此熟悉

```py
def sum(*args):
    total = 0
    for val in args:
        total += val
    return total

print(sum()) # 输出 0
print(sum(1)) # 输出 1
print(sum(1, 2)) # 输出 3
```

# 类

类似于其他语言中的 **结构体**, **类 (Class)** 是一种自定义的复合数据类型, 类成员可以包含任何类型的值

可以通过 `class` 关键字定义一个类, 并为其实现一些类方法

```py
class Rectangle:
    class_value = 0
    # 下面几个是名字内定但须要手动实现的特殊方法

    # 构造方法, 用于初始化一个类, 在创建对象的时候自动调用
    # 用于创建一个矩形
    def __init__(self, length, width):
        self.length = length
        self.width = width

    # 用于返回对象的字符串表示, 通常用于 print 函数打印输出时
    def __str__(self):
        return f"Rectangle's size is {self.length} * {self.width}"

    # 用于返回对象的调试表示, 通常在控制台输出时调用
    __repr__ = __str__

    # 下面几个是自定义方法

    # 普通方法, 也叫实例方法, 第一个参数都是 self, 代表对象本身
    # 用于计算矩形面积
    def area(self):
        return self.length * self.width

    # 类方法是绑定到类而不是实例的方法
    # 可以让类有更多的构造方法, 而无需修改 __init__
    # 使用装饰器 @classmethod 来定义类方法
    # 创建一个矩形
    @classmethod
    def build_rec(cls, length, width):
        return cls(length, width)

    # 静态方法不需要访问类或实例的属性
    # 当一个函数和类本身无关, 但只被该类使用, 为了让代码结构更加有序, 可以将该函数移动到类的定义之下成为一个静态方法, 可以理解为一个纯粹的工具函数
    # 使用装饰器 @staticmethod 来定义静态方法
    # 仅仅是计算一下加法, 与类本身无关
    @staticmethod
    def just_add(a, b):
        return a + b

rec = Rectangle(10, 20)
print(rec) # 输出 "Rectangle's size is 10 * 20"
print(rec.area()) # 输出 200
print(Rectangle.build_rec(10,10))
print(Rectangle.just_add(1,2))
```

# 模块

将所有代码都放在同一个文件中是不现实的, 这个时候就需要把代码按一定组织分散到不同文件中, 通过 `from`-`import` 关键字, 我们就可以使用这些定义在其他文件的 Python 代码

```py
###############
# a.py
###############

def func(){
    print("Hello from a.py")
}

###############
# b.py
###############

import a # 只导入模块
a.func() # 通过 . 操作符获取 a 这个模块的命名空间下的函数

# 或者
import a as my_module # 导入并重命名模块
my_module.func()

# 或者
from a import func # 只导入模块某一方法
func()

# 或者
from a import * # 代表导入 a.py 中的所有代码
func()

# 运行 b.py 后, 以上几种方式都将打印 "Hello from a.py"
```

很多时候, 我们的模块内部不仅仅有函数, 还有其他可以被直接运行的代码, 那么如果我们在某一文件导入了这个模块并运行该文件, Python 解释器就会执行这些代码, 可是有的时候我们并不希望如此, 我们只希望当该模块被直接执行时才运行这部分代码, 这种时候就可以利用 **私有的实例属性**, 还记得吗, 我们在 [变量](#变量) 的部分提到过

```py
###############
# nothing.py
###############

def foo():
    pass


# __name__是Python中一个隐含的变量它代表了模块的名字
# 只有被Python解释器直接执行的模块的名字才是__main__
if __name__ == '__main__':
    print('call foo()')
    foo()

###############
# test.py
###############
import nothing

# 导入模块时 不会执行模块中 `if` 条件成立时的代码 因为模块的名字是 `nothing` 而不是 `__main__`
# 可以尝试去除 nothing.py 中的 if 语句
```

# 结语

Python 最最基本的语法就算是介绍完了, 比某些三分钟教你学 Python 更精细, 也比一些专业的教程更适合迅速入门.

(PS: 或许也比一些大学老师讲的更易懂)

希望文章对您有所帮助, 有任何问题欢迎底部评论
