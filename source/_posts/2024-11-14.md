---
feature: false
title: 一个零基础靠自行摸索的网络 API 逆向工程经验
date: 2024-11-14 10:00:00
abstracts:
tags:
    - Web
    - Resolution
categories:
    - Note
cover: https://fontlos.com/icons/logo.png
---

这是我的一个 [逆向项目](https://github.com/fontlos/buaa-api) 开发过程中的一些经验, 但我个人几乎没有网络逆向基础, 也没有系统的学过 JS 相关的内容, 在最开始的时候几乎完全是面向浏览器编程, 哪里遇到困难就查哪里, 所以这些经验可能不完全正确, 如疏漏还请担待. 我使用的是微软 Edge 浏览器, 其他浏览器的调试工具应该也类似

> 这可能是一篇拖了 4 个月的文章, 虽然发布时间标记在 2024.11.14, 但是截止到 2025.3.8 才写完, (主要是拖延症严重发作www), 因此许多细节也都丢失记不清了

# 寻找目标

逆向的第一步当然是找到自己想要逆向什么, 可能是一个登录请求, 可能是一个资源请求, 也可能是一个操作请求. 既然是请求, 那么最简单的方式就是直接在调试工具 **网络** 选项卡, 在筛选条件中选择 **Fetch/XHR**, 这里就没有那些静态资源的请求干扰了, 随便点开一个就能看到请求头响应头等信息, 最重要的是我们可以看到请求所需的 **参数**, 包括请求负载和请求头内的一些信息.

一个设计良好的 API 应该就能通过这些 API 名字分辨出功能, 当然也有分辨不出来的时候, 或者干脆这个链接虽然名字正确, 但是却不是完整的请求过程, 通过打开 **发起程序** 选项卡就能看到一串 HTTP 请求调用链. 有了这些信息就方便我们去定位我们所需要的请求发生在哪个阶段, 应该如何达到这个目标

# 定位代码

接下来我们可以来到调试工具的 **源代码** 选项卡, 打开 **XHR/提取断点**, 如果你在上一阶段明确知道了你的目标请求的信息, 你可以增添一些过滤器提高效率. 或者干脆勾选 **任何 XHR 或提取** 也可以, 这样会拦截所有的 HTTP 请求. 为了保证获取到所有我们所需的信息, 你可以在浏览器设置中, 找到 Cookies 的管理选项, 删除我们目标域名下的 Cookie. 然后刷新网页. 接下来就会在每一次发生 HTTP 请求的时候自动暂停, 右上角会有实际请求的 URL, 源代码选项卡也会弹出当前执行的 JS 代码位置. 代码看不懂没关系, 这些代码可能都是经过打包器混淆过的, 我也看不懂, 但是浏览器会在旁边给你标上当前局部变量的实际值, 在旁边的 **作用域** 选项卡会有汇总起来的内容.

如果你确定这就是你需要的请求发生的位置, 你可以先下一个断点. 有时候可能出现断点位置不准确的情况, 因为 JS 代码普遍是经过压缩的, 实际只有几行, 但被浏览器自动格式化了, 这时可能需要在设置里关掉 **JavaScript 源映射** 之类的 (比较久远已经记不清了). 如果不确定这就是你想要的, 但怀疑是, 你同样可以下一个断点, 然后右上角让浏览器继续执行, 直到不再停在任何请求

# 断点调试

这是最需要耐心的步骤, 需要反反复复刷新网页, 而且 JS 代码通常极为混乱

接下来你可以再次刷新网页, 这次应该会停留在你所下的断点处, 我当时遇到的一个棘手情况是, 请求的目标负载响应都是是一段被加密的文本, 那么现在的目的就是去看这段负载是在什么位置, 如何生成的. 灵活运用 **断点**, **作用域**, **调用堆栈** , **控制台 console.log** 等工具

在请求发生之前, 一定完成了这部分数据的生成与加密编码, 所以我们往上打断点, 寻找疑似的变量, 观察作用域信息, 你可以通过尝试在浏览器控制台打印这些变量, 执行某些函数, 来确定这些完全没有可读性的函数功能. 如果一直向上打断点, 直到断点都到了这次请求根本不会执行的位置, 那么你可以通过调用堆栈来向上寻找函数调用, 找到上一次函数调用发生的位置, 继续打断点, 当我们向上找了几层函数调用以后, 也可能会遇到要向下找函数调用的步骤, 不要急, 慢慢来

最终你就能找到数据实际生成的位置, 这里附上一个例子

![image](./post/img/2024-11-14.png)

这算是一个相当复杂的例子了, 首先可以看到 `v` 变量这个 token, 这是我之前逆向登录接口后得到的, 这个值经过分析需要插入到请求头中, 然后看下面 `y` 变量, 这里调用了一个叫做 JSEncrypt 的东西, 从名字看这是一个 JS 加密库, 虽说是加密库, 但不要害怕, 任何生产环境下一定不会使用自定义的加密方法, 使用的一定是久经考验的加密方案, 通过调用堆栈链进入加密代码内部, 虽然变量名仍然被混淆了, 但基本结构仍然保留, 可以通过结构来看实际调用的是哪个函数, 这里是一次 RSA 加密, 经过一番查找 RSA 公钥被硬编码在一段 JS 代码中

我们的请求负载实际是一个 JSON 对象, 就是图中 `w` 变量, 在这次请求中它只是一个空对象, `_` 变量这里是一个 AES  Key, 这个 Key 才是实际加密数据的密钥, 通过随机数生成, 使用 RSA 加密作为 `ak` 参数放在请求头里, 然后用 SHA1 处理请求负载, 再用 RSA 加密一次, 得到了 `sk` 参数, 也放在请求头里用于验证身份, 最终用 AES Key 加密我们的请求负载放进请求体里, 实际的 AES 加密内部还用了一层 Base64 编码, 并且字母表是自定义的, AES 类型是 ECB mode, PKCS5Padding, 但这些东西都被硬编码在 JS 代码中了, 可以通过在控制台调用这个 AES 函数, 然后在网上找一个标准的 AES 加密, 调整到需要的参数, 加密同样的信息, 看看结果是否相同.

最后再在请求头里插入一些其他必要信息, 完成请求. 而这个响应体的解码, 只需要用之前的 AES Key 解码再用之前的特殊 Base64 解码就可以了
