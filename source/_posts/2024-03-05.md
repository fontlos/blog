---
feature: false
title: 一文速通 Python 基础
date: 2024-03-06 00:27:10
abstracts: 非官方的 Python 极简教程, 主要面向学校计算机课需要用到 Python 或者有专门的 Python 课程且毫无基础的小朋友们, 通过一篇文章, 从安装开始讲解 Python 最基本的知识
tags:
    - Python
categories:
    - Course
cover: https://fontlos.com/icons/logo.png
---

非官方的 Python 极简教程, 不会完全按照常规教程的体系进行, 适合快速熟悉语法, 并且会介绍一些与基础相关但冷门的内容

# Python 极简介绍

**Python** 是一门 **高层次的** **动态类型的** **弱类型的** **解释型** 语言, 下面逐一解释这些名词的含义

- 高层次: 对比汇编这种底层的低级语言, C/C++ 这种偏底层的中级语言, Python是高度抽象的, 更加接近自然语言, 关键字很少, 便于理解记忆
- 动态类型: 一个软件在运行时的状态被称为 **Runtime (运行时)**, 而动态类型就是指只有在运行时才会进行类型检查, 这意味着变量的数据类型不是在编译期确定的, 而是在程序运行过程中才会绑定的
- 弱类型: 弱类型语言允许变量被赋予不同的数据类型, 不需要任何显式的类型转换, 比如一个整数类型, 既可以被赋值数字 0, 也可以被赋值字符 "0"
- 解释型: 指不需要被编译成计算机可以直接识别的机器码, 而是通过解释器进行逐行解释在运行时翻译执行

# 环境配置 (以 Windows 为例)

## Python 安装

可以直接下载并运行官网提供的 [安装器](https://www.python.org/ftp/python/3.12.2/python-3.12.2-amd64.exe), 安装过程建议勾选 **Add Python 3.x to PATH** (用于自动添加环境变量) 并选择自定义安装, 在设置 **Optional Features** 界面最好将 **pip, tcl/tk, Python test suite** 等项全部勾选上. 强烈建议选择自定义的安装路径并保证路径中没有中文

也可以手动下载 [压缩包](https://www.python.org/ftp/python/3.12.2/python-3.12.2-embed-amd64.zip), 解压到任意目录, 并手动添加到环境变量

通过在终端执行

```sh
python -V
```

如果显示了版本信息, 则安装完成

你也可以直接通过在终端输入 `python` 并回车进入终端交互式页面编写一次性代码, 当然更多情况下我们还是会使用代码编辑器进行编码

## 编辑器安装配置

最专业的 **Python IDE (集成开发环境)** 当然是 Jetbrains 的 [Pycharm](https://www.jetbrains.com/pycharm/download/), 但对于初学者而言, 单个脚本或小型项目的编写更推荐使用 [VSCode](https://code.visualstudio.com/), 点击链接下载安装后, 只需要再安装 [Python](https://marketplace.visualstudio.com/items?itemName=ms-python.python) 插件即可

下面是其他的可能需要的插件

- [Chinese (Simplified)](https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans) 简体中文插件
- [Code Runner](https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner) 为 Python 等语言添加右键运行菜单
- [Codeium](https://marketplace.visualstudio.com/items?itemName=Codeium.codeium) 一个类似 Copilot 的 AI 代码提示插件

## 编辑器基本使用

打开 VSCode, 点击左下角齿轮图标, 点击设置, 在设置中搜索 `Auto Save`, 将 **Auto Save** 选项改成 `afterDelay`, 将 **Auto Save Delay** 选项改成 `1000`, 这表示每 1000 ms 自动保存一次文件

在左侧侧边栏选择打开一个空文件夹, 在文件夹内新建一个 `<文件名>.py` 文件. 接下来就可以在文件内编写代码了

编写完成后, 在对应文件上右键, 选择 **在集成终端中打开**, 在新打开的终端中输入

```sh
# 表示调用 Python 解释器执行这个文件, 注意空格
python <文件名>.py
```

如果安装了 **Code Runner** 插件, 你也可以在文件编辑区内右键选择 **Run Code**, 在文件上右键选择 **Run Code**, 或在文件编辑区右上角单击小三角来运行程序

# 熟悉 Python 世界的基本工具

## 注释

对于一个 Python 文件, 或者对于任何的不论是语言, 知识还是笔记, 适当的注解都是至关重要的. 这些能够帮助你在很长时间后快速熟悉起曾经写下的内容, 也能时刻提醒自己: 自己该做什么, 自己在做什么, 自己做了什么

即便 Python 已经是一门高度抽象的高级语言, 但自然语言仍然比这些代码更加易懂, 因此编写代码的时候, 注释尤为重要

在 Python 文件中可以使用以下两种注释

```py
# 一个井号后面的内容都将作为注释, 不会被执行, 这被称为单行注释
print("你好, 世界!") # 单行注释也可以放在代码的后面

"""
三组双引号之间是多行注释
这之间的所有内容都将被忽略
"""
```

在这同时我们也按照惯例写出了最简单的 Python 程序, 运行程序, 即可看到控制台输出了 `你好, 世界!`

## Print 控制台输出

接下来让我们认识一下第二个基本工具, 我们已经在上面见过它了: `print()` 函数. 这将是我们基础知识中最常用的一个函数, 它的意义和数学中的函数类似, 有函数的名字, 后面跟上一个小括号, 括号里面放函数的参数, 最后函数可以计算出一个值. 就像它的名字 "打印", 它的功能就是将括号中的参数打印到控制台中, 你不仅可以打印字符, 还可以打印变量, 和几乎所有的数据类型, 我们会在后面逐一介绍

# 变量与基本数据类型

## 变量

就像数学中可以 "令 x = 1" 那样, Python同样可以用极为类似的方式声明变量

```py
x = 1
```

对没错, 仅此而已, 就是那么简单, 用一个等号连接. 等号左边是变量的名字, 等号右边是变量的值

对于变量的名字, 理论上可以是符合下列规则的任何字符串

- 硬性规则
    - 由字母 (广义的 **Unicode 字符**, 不包括 **空格** 等特殊字符), 数字和下划线构成, 但不能以数字开头
    - 大小写敏感 (大写的 `a` 和小写的 `A` 是两个不同的变量)
    - 不要跟关键字 (有特殊含义的单词, 后面会讲到, 比如 `if`, `else` 等) 和系统保留字 (如刚刚学到的 `print` 函数的名字, 模块的名字等) 冲突
- PEP 8 要求:
    - 用小写字母拼写, 多个单词用下划线连接。
    - 受保护的实例属性用单个下划线开头 (后面会讲到)
    - 私有的实例属性用两个下划线开头 (后面会讲到)

还记得刚刚说的 `print` 函数可以用来打印变量吗, 快来试试吧

```py
x = 1
print(x) # 打印变量
```

## 基本数据类型

```py
string = "字符串"
string2 = '单引号也可以'
integer_num = -1 # 整数类型, 简称整型, 在 Python 3.x 之后已经不区分长整型和短整型了
float_num = 1.0 # 浮点数类型, 简称浮点型, 表示小数
bool_type = True # 布尔类型, 用于表示 "真" 或 "假", 只有两种值 "True" 或 "False"

big_num = 1_000_000 # 可以通过下划线分割长数字增加可读性
sci_num = 2e2 # 科学计数法, 表示 2.0 * 10^2, 自带至少一位小数, 200.0
sci_num2 = 2.000000e+02 # 标准科学计数法, 表示 2.0 * 10^2, 自带至少一位小数, 200.0
bin_num = 0b101 # 以 "0b" 开头的是二进制数字类型, 注意后面跟的数字不能超过 1, 打印时默认以十进制输出
hex_num = 0x12abcdef # 以 "0x" 开头的是十六进制数字类型, 包含 0-9, a-f 这些字符, 打印时默认以十进制输出
```

## 打印数据类型

我们可以通过 `type()` 函数来获取一个变量的数据类型

```py
a = 1
print(type(a))
#这将会输出 "<class 'int'>"
```

# 格式化输出

就像上面说的, 二进制和十六进制的小数被打印时默认都是十进制, 那么有没有办法让它们以原来的样子输出呢? 这就要提到 **格式化输出** 了, 事实上我们可以为很多类型的输出自定义其格式

下面将会看到字符串内部有多种 `%` 开头的短字符串, 它们表示一个占位符并且具有特殊的格式, 在这个主字符串后面用单个 `%` 相隔会有一些数据类型, 他们将会替换掉前面的占位符并继承它的格式

```py
print("%c" % "C") # %c 表示 char, 将值格式化为单个字符
print("%s" % "String") # %s 表示 string, 将值格式化为字符串
print("%d" % 1.0)  # %d 表示将值格式化整数
print("%f" % 1) # %f 表示格式化为标准浮点数
print("%.2f" % 1) # %.2f 表示格式化为两位小数, 当然也可以指定其他精度
print('%e' % 1.0e3) # %e 表示将值格式化为标准科学计数法
```

可以简单的通过逗号隔开打印多个值和变量, 也可以通过 **format** 将变量嵌入到字符串中

```py
name = "Job"

print("Hello ",name)
# 用 f 进行标记, 即可通过外面包裹花括号的方式将变量嵌入字符串
print(f"Hello {name}")
```

# 运算符

运算符, 顾名思义, 用于运算的符号, 可以用于值或变量的运算, 其中就有我们在数学中熟悉的数学运算符, 包括加减乘除等. 同样, 就像数学中先乘除后加减那样, Python中的运算符也有优先级之分

下面将按照优先级从高到低的顺序列出常见运算符, 仅加粗部分为常用运算符

- **小括号**: `()`, 最高级的运算符
- **索引/切片运算符**: `[]`, `[:]`, 其作用分别是
  - 取列表或元组元素下标
  - 取列表或元组切片
- 优先级比较特殊的运算符: `~`, `+`, `-`, 其功能分别如下
  - (不常用)位运算符中优先级较高的特例, 按位取反, 比如 `~4` 意思是 4 的 二进制 100 每一位进行取反, 即 001, 即十进制的 1
  - 取正负号
- **数学运算符**
  - `**`: 乘幂运算符, 例如 2 ** 3 = 8, **当幂次是既约真分数时至少自带一位小数**
  - `*`, `/`, `%`, `//`, 其功能分别是:
    - 乘法运算符
    - 除法运算符, **自带至少一位小数**
    - 除法取余数运算符, 例如 5 % 3 = 2
    - 除法取整数运算符, 例如 5 // 3 = 1
  - `+`, `-`: 加减法运算符
- (不常用)为运算符
  - `>>`, `<<`
    - 前者为右移运算符, 将数字类型的二进制值右移, 相当于除 2 运算, 例如 `4 >> 1` 意思是 4 的二进制 100 整体右移一位, 导致末尾 0 消失, 变成 10 即十进制的 2
    - 后者为左移运算符, 类比右移运算符, 相当于乘 2 运算, 例如 `1 << 10` 相当于 1 的二进制 1 整体左移十位, 空位补零变成 10000000000, 即十进制的 1024
    - 注: 在早期 CPU 上位运算的速度大于乘法运算, 但在现代 CPU 与编译器优化下, 二者区别已经不大了
  - `&` 按位与运算符, 对两个二进制执行按位与运算, 相同为 1 不同为 0, 例如 `4 & 5` 意思是 4 和 5 的二进制 100 和 101 按位与运算得到 110, 即十进制的6
  - `^`, `|`: 前者为按位异或运算符, 后者为按位或运算符
- 比较运算符, 返回布尔值
  - `>`, `<`, `>=`, `<=`, 判断是否大于, 小于, 大于等于, 小于等于
  - `==`, `!=`, 判断是否等于, 是否不等于
- 身份运算符: `is`, `is not`
- 成员运算符: `in`, `not in`
- **逻辑运算符**: `and`, `or`, `not`, 分别对应 **与, 或, 非** 运算
  - 与运算, 连接的两个表达式都为真时才为真, 例如 `5 > 4 and 6 > 5` 返回 `True`
    - 短路功能: 当与运算左侧为假时, 右侧表达式不进行计算, 整体即可判定为假
  - 或运算, 连接的两个表达式有一个为真时就为真, 例如 `5 > 4 or 5 > 6` 返回 `True`
    - 短路功能: 当或运算左侧为真时, 右侧表达式不进行计算, 整体即可判定为真
  - 非运算, 后接真时返回假, 后接假时返回真, 例如 `not 5 == 4` 返回真
- **赋值运算符**: `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `//=`, `**=`, `&=`
  - `=` 是最常用的赋值运算符
  - `+=` 加法赋值运算, 例如 `a += 6` 意思是 `a = a + 6`, 后面的其他运算符同理
  - (不常用) `&=` 是按位与赋值运算符
  - (不常用) 赋值运算符链式调用时从左往右运算, 比如 `a = b = c` 意思是 `a = (b = c)`, `a = b += 4` 意思是 `a = (b = b + 4)`

# 集合类型

类似数学中的集合, 向量, Python 中也有集合类型, 用于储存多个值

## 有序集合

不同于多数语言, Python 的有序集合类型不包括数组, 而是用列表取而代之, 除此之外还有元组. 作为有序集合类型, 那么自然而然地可以理解, 每一个元素都有一个对应的编号. 但需要注意的是, 在包括 Python 在内的绝大多数编程语言中, **索引都是从 0 开始的**, 即不论是列表还是元组, 其第一个元素的编号或者说索引都是 0!

还有一点特殊的是, Python 中的索引可以是 *负值*, 表示 *倒数第几个元素*, 比如 `-1` 表示最后一个元素

- **列表 (List)**
  - 使用 `[]` 包裹的一组用逗号隔开的值
  - 值可以是任何类型, 可以是不同的类型, 甚至包括列表本身
  - 列表是可以被改变的, 可以通过列表内置的方法进行增加, 删除, 修改, 查询元素
    - 方法可以理解为一种数据类型自带的函数, 通过 `变量/值.[函数名]()` 调用
- **元组 (Tuple)**
  - 使用 `()` 包裹的一组用逗号隔开的值, 但 `()` 可以省略不写
  - 值可以是任何类型, 可以是不同的类型, 甚至包括元组本身
  - 元组一旦确定就不可以被更改

```py
my_list = [1, 1.5, "a", [0, True]]
my_tuple = 1, 1.5, "a", (0, True)

# 可以通过列表内置的一些方法操作列表
my_list.append(1) # 添加单个元素在列表末尾
# 此时 my_list = [1, 1.5, "a", [0, True], 1]
my_list.extend((2, 3)) # 添加多个元素在列表末尾, 注意需要括号
# 此时 my_list = [1, 1.5, "a", [0, True], 1, 2, 3]
my_list.insert(2,"b") # 在索引为 2 的元素后面插入值 "b"
# 此时 my_list = [1, 1.5, "a", "b", [0, True], 1, 2, 3]
my_list.remove([0, True]) # 删除指定值的元素
# 此时 my_list = [1, 1.5, "a", "b", 1, 2, 3]
my_list.pop(1) # 删除指定索引的元素
# 此时 my_list = [1,"a", "b", 1, 2, 3]
a = my_list.index(1) # 获取指定索引的值
# a = "a"
my_list.clear() # 清空列表
```

除了通过方法获得列表的值, 还可以直接通过索引或切片来获取, 还记得 (运算符)[#运算符] 部分提到的 索引/切片运算符 吗

*下面的内容不仅对列表有效, 对元组同样有效*

- 索引
  - 通过在变量后追加一个方括号来获取索引元素, 形如 `variable[index]`
- 切片: 字面意思, 获取变量中的一段
  - 通过在变量后追加一个方括号来获取切片, 形如 `variable[start:end:step]`
  - start: 表示截取的起始索引, 且包含, 不写则截取到开头 (可以理解为从正方向的 0 号开始截取)
  - end: 表示截取的终止索引, 但不包含, 不写则截取到结尾 (可以理解为从负数索引截取到 0 号)
  - step: 步长, 即从起始索引开始, 每隔多少个元素选取一个元素, 不写默认为 1
  - 总之, 切片相当于从集合中取了一个 "左闭右开区间"

```py
arr = [1, 2, 3, 4, 5]
# 通过在列表或元组变量后追加一个方括号来获取索引元素或切片
one = arr[0]
# one 等于 arr 列表的第一个元素, 即 1
five = arr[-1]
# five 等于 arr 列表的倒数第一个元素, 即 5
arr1 = arr[:3]
# 根据参数省略规则, 截取索引为 0, 1, 2 的切片, 即 [1, 2, 3]
arr2 = arr[-2:]
# 根据参数省略规则, 截取索引为 -2, -1 的切片, 即 [4, 5]
arr3 = arr[:]
# 工具参数省略规则, 截取整个列表作为切片
# 切片的
```

最后, 可以通过 `len()` 函数获取集合元素的长度, 即内部有多少个元素

```py
arr = [1, 2, 3, 4, 5]

print(len(arr)) # 输出 5
```

## 字典

**字典** 是一种无序集合类型, 在其它语言中通常被称为 **哈希表**, 是一种 **键值对应** 的数据结构, 用大括号包裹, 键值之间通过冒号隔开, 下面是一些基本示例

```py
# 创建字典的字面量语法
scores = {'A': 1, 'B': 2, 'C': 3}
print(scores)

# 创建字典的构造器语法
items1 = dict(one=1, two=2, three=3, four=4)

# 通过 zip 函数将两个序列压成字典
items2 = dict(zip(['a', 'b', 'c'], '123'))

# 创建字典的推导式语法
items3 = {num: num ** 2 for num in range(1, 10)}
print(items1, items2, items3)

# 通过键可以获取字典中对应的值
print(scores['A'])
print(scores['B'])

# 对字典中所有键值对进行遍历
for key in scores:
    print(f'{key}: {scores[key]}')

# 更新字典中的元素
scores['A'] = 4
scores['B'] = 5
scores.update(A=6, B=7)
print(scores)

# 直接通过键获取对应的值
if 'D' in scores:
    print(scores['D'])

# 通过 get 获取键对应的值, 且当键不存在时返回 None 而不是报错
print(scores.get('D'))

# get 方法当键不存在时可以设置默认值
print(scores.get('D', 0))

# 删除字典中的元素
print(scores.popitem())
print(scores.popitem())
print(scores.pop('A', 6))

# 清空字典
scores.clear()
print(scores)
```

# 语法结构

之前我们所写的代码都是扁平结构的, 接下来我们就要学习 Python 的语法结构了. 不同于 C/C++ 等语言靠分号和大括号区分层级结构, Python 采用空格缩进来区分层级结构, 如果不理解, 看下面的例子即可

## 条件分支结构

类似于数学中的分段函数, Python也可以根据不同的条件执行不同的语句, Python 有两种条件分支结构

### If-Else 语句

通过 `if` - `else` 关键字组合, `if` 后接一个布尔表达式, 通常直接为布尔类型或者由比较运算符参与构成, 如果表达式为真, 则执行 `if` 之下的内容, 如果表达式为假, 则执行 `else` 之下的内容. 这非常符合自然语言的直觉, "如果 ... 为真, 那么 ..., 否则 ..."

例如判断一个数是否是偶数

```py
a = 4

if a % 2 == 0:
    print("a 是偶数")
else:
    print("a 是奇数")
```

有的时候分支不止两条, 这时我们可以连用 `else if` 关键字, 后接一个布尔表达式, 意味"又如果 ... 为真, 那么 ...", 但是这样略有冗长, 且容易让层级显得参差不齐, 所以我们可以把这两个单词合并成 `elif`, 比如下面的例子

```py
score = 98

if score > 90:
    print("优秀!")
elif score > 80:
    print("良好")
elif score > 60:
    print("及格")
else:
    print("不及格...")
```

### Match-Case 语句

对于上面的最后一个例子, 如果分支条件是一些离散变量, 比如字符串, 或者一组固定的数字类型, 或是布尔变量, `if`-`else` 语句虽然也可以很好的解决, 但略显冗长. 好在在 Python 3.10 之后引入了一种类似于 Rust 语言中的模式匹配结构: `match`-`case` 语句, 下面来简单的看一个例子

```py
gender = "男"

match gender:
    case "男":
        print("是男孩子")
    case "女":
        print("是女孩子")
    case "保密":
        print("性别保密哦")
    case _: # 通过一个通配符来匹配其他剩下的所有情况, 当然也可以省略, 不像 Rust 那样严格要求穷尽式匹配
        print("也许是武装直升机)")
```

通过这个简单的例子, 就应该能体会到, 离散的分支条件越多, 这种方法的优势就越大

可以通过在 `case` 分支后面添加一个 `if` 语句增加额外的判断, 例如

```py
gender = "女"
age = 18

match gender:
    case "女" if age < 20:
        print("是青春少女")
```

`case` 关键字还可以捕获变量

```py
greeting = "Job"

match greeting:
    case "":
        print("Hello!")
    case name: # 这里新建了一个 name 变量用于捕获 greeting 这个变量
        print(f"Hello, {name}!")
```

这样的 `if` 条件被称为 **卫语句**, 字面意思, 保卫条件分支的语句

`match`-`case` 语句的其他功能这里就不再赘述, 感兴趣可以自行搜索

## 循环结构

类似于数学中的迭代, 当需要重复某件事若干次时, 就需要用到循环结构了, 循环结构同样有两种

### While 循环

`while` 是最简单的一种循环, 通过后接一个布尔表达式, 很容易从字面上理解其含义, "当 ... 为真时, 就 ..."

当然我们很少需要一个无法打破的无限循环, 因此需要在循环体内部加上一些可以帮助跳出循环的条件

```py
a = 0

while a < 10:
    print(a)
    a+=1
```

如此一来, 每次循环结束前, 循环条件 `a` 都会加一, 当 `a` 等于 `10` 时, 循环条件不再满足, 循环结束, 继续向下运行其他代码, 那么这段时间里将会打印 `0` 到 `9` 这些数字

当然我们也可以通过一些特殊手段提前跳出循环, 比如 `break` 关键字, 字面意思, 打破循环

```py
a = 0

while a < 10:
    if a == 3:
        break
    print(a)
    a+=1
```

如此一来, 当 `a` 增加到 `3` 时, 就会触发 `if` 语句内部的 `break`, 提前结束循环, 只会打印 `0`, `1`, `2` 三个数字

除此之外, 还有 `continue` 关键字, 字面意思, 继续循环, 但是不包括关键字下面的部分了, 即一旦遇到这个关键字, 立刻开始新一轮循环

```py
a = 0

while a < 10:
    if a == 3:
        a+=1 # 注意给循环条件加一, 以免无限循环
        continue
    print(a)
    a+=1
```

如此一来就会打印 `0` 到 `9` 里除了 `3` 的数字

值得注意的一点是, 当有 **多重嵌套** 循环时, `break` 和 `continue` 都只影响它们外面紧挨着的那一层循环

### For-In 迭代器

对于遍历一个集合元素, 使用 `while` 循环当然也能做到, 但是需要我们提前知道集合元素的长度并小心的设定循环条件, 很不方便. 这时就需要专门遍历集合以及范围的 `for`-`in` 循环了, 形如 `for item in range`, 意思是 "从 range 里面取出一个 item 并 ..." 并一直循环取遍每一个 `item`, 并且这个 `item` 是一个临时变量, 可以在循环体中使用

```py
cities = ["北京", "天津", "上海"]

for city in cities:
    print(city)
```

上面我们说到 `for` 循环还可以遍历一个范围, Python 中提供了一个非常灵活的函数用于生成整数范围: `range()`, 使用方法形如 `range(start, end, step)`, 非常类似于切片的用法

- start: 范围的起始, 且包括在范围中
- end: 范围的终止, 但不包括在范围中
- step: 步长, 从起始开始数值递增的值, 默认为 1
- 若 start < end, 则表示一个 **倒序** 范围

下面举几个简单的例子

- `range(10)`: 生成 `0` - `10` 但不包括 `10` 的整数范围, 即 `0` 到 `9` 十个数字
- `range(1, 10)`: 生成 `1` - `10` 但不包括 `10` 的整数范围
- `range(1, 10, 2)`: 生成 `1` - `10` 但不包括 `10` 的奇数范围
- `range(10, 0, -2)`: 生成 `10` - `0` 但不包括 `0` 的偶数范围

下面是与 `for` 循环结合的示例

```py
# 一个简单的 0 到 100 的求和
sum = 0

for i in range(101):
    sum+=1
print(sum)
```

# 函数

> "代码有很多种坏味道, 重复是最坏的一种!" --- Martin Fowler

数学中, 如果我们有需要反复往一个冗长的表达式中代入不同的值并计算, 为了让卷面清爽一些, 我们通常会将这个冗长的表达式包装成一个 **函数**, 在编程中当然也可以这样做

如果有一组相似且机械的行为, 那我们就可以将其抽象成函数以供调用, 比如阶乘的计算, 即使用循环来写这仍然是一个冗长的过程, 我们就可以定义一个函数, 输入数字, 就返回它的阶乘

在 Python 中, 我们通过 `def` 关键字来定义函数, 后面跟上函数的名字, 在后面跟上一个小括号, 里面可选的可以加入若干的函数内部所需的参数, 由于此时参数并没有确切的值, 只是起到参与运算的形式作用, 因此称之为 **形参**, 多个形参之间可以用逗号隔开

在函数内部的某个部分, 可选的可以使用 `return` 关键字返回一个变量作为函数的结果, 如果需要返回多个变量, 可以以元组或列表的形式返回

类似于 `break` 和 `continue` 关键字, 此时函数会立即停止执行

如果不显式写明的话, 则会默认返回函数最下面的一个变量

```py
def fac(num):
    result = 1
    for n in range(1, num + 1):
        result *= n
    return result

# 这样比如我们计算组合数时就不需要反复计算阶乘了
m = 5
n = 3
print(fac(m) // fac(n) // fac(m - n))
```

与其它语言不同的是, **Python 的函数参数可以有默认值**, 使用起来就像变量赋值一样简单

```py
def func(n=2):
    print(n)

func() # 输出 2
func(3) # 输出 3
```

**Python 的函数还支持可变参数**, 只需要在参数前面加上一个 `*`, 这表示可以传入 0 到任意个参数

```py
def sum(*args):
    total = 0
    for val in args:
        total += val
    return total

print(sum()) # 输出 0
print(sum(1)) # 输出 1
print(sum(1, 2)) # 输出 3
```

# 类

类似于其他语言中的 **结构体**, **类 (Class)** 是一种自定义的复合数据类型, 类成员可以包含任何类型的值

可以通过 `class` 关键字定义一个类, 并为其实现一些类方法

```py
class Rectangle:
    class_value = 0
    # 下面几个是名字内定但须要手动实现的特殊方法

    # 构造方法, 用于初始化一个类, 在创建对象的时候自动调用
    # 用于创建一个矩形
    def __init__(self, length, width):
        self.length = length
        self.width = width

    # 用于返回对象的字符串表示, 通常用于 print 函数打印输出时
    def __str__(self):
        return f"Rectangle's size is {self.length} * {self.width}"

    # 用于返回对象的调试表示, 通常在控制台输出时调用
    __repr__ = __str__

    # 下面几个是自定义方法

    # 普通方法, 也叫实例方法, 第一个参数都是 self, 代表对象本身
    # 用于计算矩形面积
    def area(self):
        return self.length * self.width

    # 类方法是绑定到类而不是实例的方法
    # 可以让类有更多的构造方法, 而无需修改 __init__
    # 使用装饰器 @classmethod 来定义类方法
    # 创建一个矩形
    @classmethod
    def build_rec(cls, length, width):
        return cls(length, width)

    # 静态方法不需要访问类或实例的属性
    # 当一个函数和类本身无关, 但只被该类使用, 为了让代码结构更加有序, 可以将该函数移动到类的定义之下成为一个静态方法, 可以理解为一个纯粹的工具函数
    # 使用装饰器 @staticmethod 来定义静态方法
    # 仅仅是计算一下加法, 与类本身无关
    @staticmethod
    def just_add(a, b):
        return a + b

rec = Rectangle(10, 20)
print(rec) # 输出 "Rectangle's size is 10 * 20"
print(rec.area()) # 输出 200
print(Rectangle.build_rec(10,10))
print(Rectangle.just_add(1,2))
```

# 模块

将所有代码都放在同一个文件中是不现实的, 这个时候就需要把代码按一定组织分散到不同文件中, 通过 `from`-`import` 关键字, 我们就可以使用这些定义在其他文件的 Python 代码

```py
###############
# a.py
###############

def func(){
    print("Hello from a.py")
}

###############
# b.py
###############

import a # 只导入模块
a.func()
# 或者
import a as my_module # 导入并重命名模块
my_module.func()
# 或者
from a import func # 只导入模块某一方法
func()
# 或者
from a import * # 代表导入 a.py 中的所有代码
func()

# 运行 b.py 后, 以上几种方式都将打印 "Hello from a.py"
```

很多时候, 我们的模块内部不仅仅有函数, 还有其他可以被直接运行的代码, 那么如果我们在某一文件导入了这个模块并运行该文件, Python 解释器就会执行这些代码, 可是有的时候我们并不希望如此, 我们只希望当该模块被直接执行时才运行这部分代码, 这种时候就可以利用 **私有的实例属性**, 还记得吗, 我们在 [变量](#变量) 的部分提到过

```py
###############
# nothing.py
###############

def foo():
    pass


# __name__是Python中一个隐含的变量它代表了模块的名字
# 只有被Python解释器直接执行的模块的名字才是__main__
if __name__ == '__main__':
    print('call foo()')
    foo()
###############
# test.py
###############
import nothing

# 导入模块时 不会执行模块中 `if` 条件成立时的代码 因为模块的名字是 `nothing` 而不是 `__main__`
```