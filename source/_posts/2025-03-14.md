---
feature: false
title: 从零开始, 用 Rust Nom Crate 写一个基本的 Markdown 解析器
date: 2025-03-14 20:00:00
abstracts: Nom 是一个解析器组合器库, 富有乐高式语义, 在这篇文章中我们将从零实现一个基本的 Markdown 解析器. 本文会经常更新前面的内容, 比起教程, 这更像是一段开发学习的笔记, 而且可能慢慢更新的特别长
tags:
    - Rust
    - Nom
categories:
    - Course
cover: https://fontlos.com/icons/logo.png
---

[Nom](https://github.com/rust-bakery/nom) 是一个解析器组合器库, 专注于**安全解析, 流模式和尽可能的零拷贝**. 这是一种富有**乐高式语义**的库, 通过组合一个个小解析器, 最终构造出一个完整的解析工具

关于 Nom 在网上的文档比较少, 而且很多都是多年前的了, 如今 Nom 更新到 8.0, 已经经过多轮重构, 那些教程也大多过时了, 所以趁此机会, 以实践的形式, 边学习, 边分享 Nom 的使用方法, 因此, 本文会经常更新前面的内容, 比起教程, 这更像是一段开发学习的笔记, 而且可能慢慢更新的特别长. 但注意, **这不是 Nom 的中文文档**, 我不会系统的介绍 Nom 的一切, 而是遇到什么介绍什么

代码可以在 [Github](https://github.com/fontlos/nomarkdown) 上找到, ~~我尽量完成这个项目, 不烂尾~~

在这篇文章中, 我们将从零开始, 构建一个最基本的专注于 Markdown 本身的解析器, 至于代码块语法老亮, 数学块的渲染, 那不在我们的考虑范围之内, 交给更专业的工具来解决. 对于一些极端特殊 Markdown 语法, 我们会考虑一部分, 并将其拆分到不同的 `features` 中

那么现在, 让我们开始吧

# 准备工作与思路分析

要解析 Markdown 就要先了解 Markdown, 作为一种轻量级标记语言, 没有严格的语法限制, 灵活却松散, 因此会给解析带来一定困难, 而且经常会出现一些极端情况

> 比如引用里套引用里套列表里套标题里套斜体里套粗体里套行内代码......

这看上去就很离谱, 没有人真的会这样写 Markdown, 但是许多编辑器, 例如 VSCode 真的可以正确解析它, 因此其中一部分内容会在我们的扩展考虑范围内

## Markdown 的结构

先看看 Markdown 的整体结构, 整个文档是由一个个块构成的, 块与块之间靠多个换行, 或者块级元素(例如标题, 列表)分隔, 虽然理论上块可以嵌套块, 就像我们上面举的那个套娃例子, 但我们不考虑所有这种情况, 只对一些合理的进行实现

块的内部是行内元素, 例如标题 `#` 后面的文本, 或者干脆一个文本块, 文字的各种变体(粗体, 斜体, 加粗斜体, 删除线, 高亮等)

Nom 作为一个组合式的解析器, 由小的解析器组合成大的解析器, 那么在解析的过程就应该反过来, 先将文档拆成大的块, 然后再逐步分解, 直到分割成最小语法单元, 进行解析

因此我们的第一个目标就是正确解析行内元素

# 正式开始

## 核心结构体

先从基本的开始, 尝试将 Markdown 解析到 Rust 结构. 这算是比较简单的部分了, 我们首先需要一个结构用来容纳解析后的 Markdown, 有点类似于 **serde_json** 的 `Value` 枚举

我们先想想有什么元素, 需要什么变体.

在许多静态博客渲染器中, 允许 Markdown 最前面顶格写一些 YAML 格式的配置, 这被称为 **Front Matter**, 我们不考虑解析它内部, 但是可以尝试解析这个块出来

然后最基本的, 我们需要文字, 包含普通文字和各种变体. 链接, 图片, 这两个也是类似且常用的功能. 我们还需要行内代码和行内数学, 对于代码块和数学块, 我们只捕获它们, 不进行进一步解析. 此外还有块内的文字换行, 块内的特殊的转义字符

行内元素基本就这些了, 然后是一些块级元素, 出现在开头就会产生新的块

首先最基本的就是换行, 不是你敲得单个换行符和块内换行符, 而是区分一个个块的换行符, 还有分割线, 这两个算是比较简单的. 接下来还有标题, 对于一些静态站点渲染器, 会为不同的标题分配 ID, 以方便构建目录索引. 然后就是各种列表, 有序的, 无序的, 和任务列表, 嵌套会产生层级差距. 然后还有表格. 最后是引用块, 我个人认为这是 Markdown 里最复杂的元素, 因为它不仅可以自己嵌套自己, 区分层级, 还能在内部放另一个完整的 Markdown 文件

考虑到现在, 我们的枚举基本已经成型了, 详细信息在注释中

```rust
#[derive(Debug, PartialEq, Eq)]
pub enum Markdown<'a> {
    Config(Option<&'a str>),
    /// # 普通文字
    /// 注: HTML 标签默认作为普通文字不做处理,
    /// 如果其内部文字干扰解析会导致解析出奇怪的东西
    Text(&'a str),
    /// # 粗斜体
    /// ```Markdown
    /// ***bold italic***
    /// ```
    BoldItalic(Vec<Markdown<'a>>),
    /// # 粗体
    /// ```Markdown
    /// **blod**
    /// ```
    Bold(Vec<Markdown<'a>>),
    /// # 斜体
    /// ```Markdown
    /// *italic*
    /// __italic__
    /// ```
    Italic(Vec<Markdown<'a>>),
    /// # 删除线
    /// ```Markdown
    /// ~~strike~~
    /// ```
    Strike(Vec<Markdown<'a>>),
    /// # 高亮
    /// ```Markdown
    /// ==highlight==
    /// ^^highlight^^
    /// ```
    Highlight(Vec<Markdown<'a>>),
    /// # 原始链接, 链接自己作为标题
    /// ```Markdown
    /// https://example.com/
    /// ```
    ///
    /// #外部链接
    /// ```Markdown
    /// [title](url)
    /// ```
    Link {
        title: &'a str,
        url: &'a str,
    },
    ///# 图片链接
    /// ```Markdown
    /// ![alt](url)
    /// ```
    Image {
        alt: &'a str,
        url: &'a str,
    },
    /// # 行内代码
    /// ```Markdown
    /// `code`
    /// ```
    Code(&'a str),
    /// 代码块
    /// ```Markdown
    /// \```text
    /// code
    /// \```
    /// ```
    CodeBlock {
        lang: &'a str,
        code: &'a str,
    },
    /// # 行内数学公式
    /// ```Markdown
    /// $math$
    /// ```
    Math(&'a str),
    /// # 数学块
    /// ```Markdown
    /// $$math$$
    /// ```
    MathBlock(&'a str),
    /// # 连续回车只解析成一个换行
    NewLine,
    /// # 分割线, 三个以上
    /// ```Markdown
    /// ---
    /// ```
    DividingLine,
    /// # 标题
    /// 包含等级, 标题内容, 和一个用于构建目录索引的 ID
    Head {
        level: usize,
        title: &'a str,
        id: &'a str,
    },
    /// # 有序列表
    /// ```Markdown
    /// 1. list
    /// 2. list
    /// ```
    OrderedList(Vec<Markdown<'a>>),
    /// # 无序列表
    /// ```Markdown
    /// - list
    /// + list
    /// * list
    /// ```
    UnorderedList(Vec<Markdown<'a>>),
    /// # 任务列表
    /// ``` Markdown
    /// -[] task1
    /// -[x] task2
    /// ```
    TaskList {
        content: Vec<Markdown<'a>>,
        finish: bool,
    },
    /// # 表格
    Table(&'a str),
    /// # 引语
    /// ```Markdown
    /// > quote1
    /// >> quote2
    /// ```
    BlockQuote(Vec<Markdown<'a>>),
    /// # 拓展语法，由双层大括号包裹
    Command(&'a str),
    /// 一个特殊的变体, 无任何效果, 只用于容纳一个枚举数组
    Vanilla(Vec<Markdown<'a>>),
}
```

在这里除了这些基本的变体, 我还添加了一些特殊情况, 比如可以像一些静态站点渲染器的模板引擎那样, 提供一些特殊的自定义语法. 然后最后我们需要一个空的变体, 它不对内部元素做任何标记, 仅仅起一个容器作用

枚举上面的派生宏仅用于调试, 如果你不需要的话也可以去掉, 不影响解析器实际工作

## 行内元素解析

到现在, 我们才正式进入到使用 Nom 的解析部分. 因为 Markdown 的结构很松散, 语法可能会嵌套, 因此我们会需要递归的, 互相耦合的调用函数, 所以可能在你看完这部分前, 你的代码还无法正常工作, 但请耐心

### 行内元素解析函数

因为行内元素有灵活多变, 所以没什么好办法, 从输入的第一个字符开始迭代, 尝试解析, 但这里我们一样可以有一点简单的优化, 至少在遇到可能出现语法的位置之前, 我们都不需要调用真正的语法解析器

```rust
use nom::{IResult, Parser};
use nom::{branch::alt, bytes::complete::take_till};

pub fn line_element_parser(input: &str) -> IResult<&str, Vec<Markdown>> {
    let mut markdown = Vec::<Markdown>::new();
    let mut current_input = &input[..];
    while !current_input.is_empty() {
        // 一直匹配到可能含有语法结构才进行解析
        // 按照常用顺序排列, 对应: 换行, 粗体斜体, 链接, 行内代码, 图片, 转义字符, 行内数学公式, 删除线, 高亮
        // 被匹配到的是文字, 没被匹配到的才含有语法
        let (syntax, text) = take_till(|c| {
            c == '\n'
                || c == '*'
                || c == '['
                || c == '`'
                || c == '!'
                || c == '\\'
                || c == '$'
                || c == '~'
                || c == '='
        })
        .parse(current_input)?;
        if !text.is_empty() {
            markdown.push(Markdown::Text(text));
        }
        match line_element_syntax(syntax) {
            Ok((remain, parsed)) => {
                markdown.push(parsed);
                current_input = remain;
            }
            Err(_) => {
                break;
            }
        }
    }
    Ok(("", markdown))
}
```

首先我们可以看到, 输入输出都含有引用, 这就涉及到了让 Rust 初学者恐惧的生命周期规则. 实际上在核心枚举定义时我们就用了生命周期注解, 那我们需要处理复杂的生命周期吗? 答案是, 多数情况下不需要. 这就体现出 Nom **尽可能的零拷贝** 的优势了, 使用 Nom 解析字符串的本质就是对原始字符串取各式各样的切片, 将原始字符串切碎, 然后重新拼成逻辑结构, 每一个小部分都是从原始字符串上切下来的, 它们享有共同的生命周期参数, 因此在多数情况下我们甚至不需要生命周期参数

语义基本比较明确, 除了一个 `line_element_syntax` 函数还不知道是什么, 我们先来简单介绍一下这部分. 首先我们的第一次的当前输入 `current_input` 就是 `input`, 我们直接取它的完整切片, 进入循环, 直到 `current_input` 为空, 即完全被解析

`take_till` 是我们在这里遇到的第一个 Nom 函数, 它是一个 **解析器**, 其基本过程就是, 通过解析一段文字, 如果匹配到了需要的内容, 则会返回剩余的内容和匹配到的内容, 而这个返回类型就是 `IResult`, 它接受两个泛型参数, 剩余的内容, 和匹配到的内容, 内部还有一个 Nom 自己的错误类型, 我们无需手动提供.

解析器的本质是高阶函数, 及接受一个参数, 这个参数就是 **规则**, 返回一个可以解析这个规则的函数, 因此 Nom 所有的解析器的返回值都是形如 `FnMut(I) -> IResult<I, O, Error>` 的结构, 在早期版本, 你可以在解析器调用之后后面直接再跟一个函数, 类似 `func("arg")("input")`, 表示直接调用解析器这个高阶函数的返回函数, 但现在, Nom 添加了 `Parser` trait, 并为所有形如 `FnMut(I) -> IResult<I, O, Error>` 的结构都实现了它, 因此你可以直接在高阶函数上调用上面的方法, 最常用的就是 `parse()` 方法

`take_till` 解析器的作用是, 接受一个闭包规则, 返回一个解析函数, 解析函数将会逐个读取字符并在上面应用闭包, 直到闭包返回 true, 匹配结束, 然后返回剩余部分和匹配到的部分

例如这里的意思就是逐个读取字符, 如果它不符合任何一种语法的开头, 那就继续匹配字符, 不过这里要注意的是, 匹配到的才是普通字符, 剩下的才是含有语法的部分. 然后就像刚刚说的, `take_till` 函数作为高阶函数, 被调用后只会产生一个函数, 并且这个返回函数实现了 `Parser` trait, 因此我们可以在上面调用 `parse` 方法, 并传入我们真正需要解析的字符

如果匹配到的普通文字不是空的, 那么就作为普通文字变体直接推入 `Vec<Markdown>`, 然后将检测到有语法的部分送入行内元素语法解析器, 之所以要这样做是因为 Nom 的解析器默认从字符串开头开始匹配, 只要失败就会停止

虽然我们还不知道语法解析器 `line_element_syntax` 如何工作, 但是它的结果很清楚, 成功匹配到语法了, 就推入数组, 并且将当前输入设置为被匹配掉语法结构后剩下的字符, 例如 `*斜体*普通文字`, 其中 `*斜体*` 被匹配走并转化成枚举变体了, 剩下了 `普通文字`

我们一次次的匹配掉普通字符和语法结构, 最终当 `current_input` 为空时, 循环结束, 这个块内的行元素解析完毕, 返回 `Ok(("", markdown))`

### 行内语法解析函数

接下来让我们来了解一下语法究竟是如何被解析的, 因为很简单所以我们直接给出函数

```rust
fn line_element_syntax(input: &str) -> IResult<&str, Markdown> {
    alt((
        text::bold_italic,
        text::bold,
        text::italic,
        text::strike,
        text::highlight,
        code::code,
        math::math
    )).parse(input)
}
```

解析行元素的时候可能返回一系列 Markdown 枚举作为数组, 但语法结构我们一次只解析一个, 所以不用嵌套数组, `alt` 是我们遇到的一个新函数, 这也是我们遇到的第一个 **组合器**, Nom 只由解析器组合器这两部分构成, 现在我们已经都认识到了, 剩下的就是学会不同的解析器和组合器的作用, 并将它们组合起来

组合器, 顾名思义就是将解析器组合在一起的函数, 接受一个不超过 16 个元素的元组参数

组合器的功能都很简单, 例如 `alt`, 其作用就是, 将元组内的解析器按顺序逐个应用, 直到解析成功, 如果全部失败则解析失败. 因此, 恰当的顺序也能优化解析器整体的性能

在这里我分了几个模块, 放了不同的内容, 类比一下即可, 可以看到这里又有许多暂时没实现的函数, 但我们知道, 它们都是解析器, 从名字来看也很清楚, 分别是用于解析 **粗斜体, 粗体, 斜体** 等. 虽然按我们前面说的, 将常用解析器放在前面可以提高性能, 但这里, 解析粗斜体, 粗体, 斜体必须按照这个顺序, 因为它们三个共用相同的符号 `*`, 如果调换顺序, 就可能导致本该匹配粗斜体时候先一步被当作粗体匹配掉了

为了更好的模块化, 你可以再用一次 `alt` 函数, 将其中 `text` 模块下的函数变体封装成一个函数, 但是暂时解析器数量不多, 我们先这样做, 如果需要再后续调整

### 行内代码解析

我们先从上面那个 `code` 函数开始. 因为这个最简单, 至少在我们考虑的情况下是的. 在 VSCode 的默认 Markdown 渲染器中, 行内代码内部是不允许使用转义字符的, 也就是说, 你无法使用转义字符在一对反引号里面打一个反引号, 那如果我就是想打一个反引号呢? 用反双引号引起来, 并且需要空格, 如果用单引号演示一下的话, 类似于 `'' ' ''`. 那怎么打反双引号呢? 答案是用反三引号引起来......这很快就会变得无比复杂, 因此我们暂时不考虑, 直接将一对反引号内的字符作为普通字符, 并且我们暂时考虑为行内代码支持转义字符

在 Markdown 中, 这种由一对定界符包裹起来的语法结构很常见, 因此我们先实现一个工具函数

```rust
use nom::{Parser, error::Error};
use nom::{
    bytes::complete::{tag, take_until},
    sequence::delimited,
};

/// 生成处理被特定模式包裹的字符串的函数
pub fn fenced<'a>(
    boundary: &'a str,
) -> impl Parser<&'a str, Output = &'a str, Error = Error<&'a str>> {
    delimited(tag(boundary), take_until(boundary), tag(boundary))
}
```

函数签名比较可怕, 但别紧张, 使用 Nom 库时编写高阶函数来自定义解析器是常有的事, 我们知道所有的解析器都实现了 `Parser` trait, 因此返回类型也是一个实现了 `Parser` trait 的对象, 这里 `Parser` 的三个泛型对应了 `IResult` 里的三个泛型, 分别是输入, 输出, 错误

`delimited` 似乎比较难定位, 既像解析器也像组合器, 其作用是, 同时应用三个解析器, 并返回第二个解析器解析到的内容, 简单来说就是匹配一个模式, 掐头去尾返回中间. 如果你点开定义看一下的话会发现它也是由更小的高阶函数组合而来的

`tag` 算是最简单的解析器了, 作用很简单, 返回一个匹配输入的规则的解析函数, 即匹配一类字符, 例如 `tag("a").parse("abc")` 就会匹配掉 `a`, 剩余内容 `bc`

`take_until` 类似于 `take_till`, 只不过判定规则反过来, 这个解析器将一直匹配, 直到遇到目标模式. 这看起来有点熟悉, 就像是查找一个字符串子串. 没错! 如果你翻开定义的话, 对于 `&str` 类型, 这个函数的底层实现就是 `find` 方法

有了这个工具函数, 我们就可以很轻松的实现用于匹配行内代码的结构了

```rust
use nom::{IResult, Parser};

use super::Markdown;
use super::utils::fenced;

// 行内代码
// 优先级很高, 只要能检测到定界符就匹配掉
pub fn code(input: &str) -> IResult<&str, Markdown> {
    fenced("`").map(Markdown::Code).parse(input)
}
```

很简单, 我们只需要匹配被反引号包裹的内容.

这里有一个 `map` 函数, 接受一个闭包, 将一个类型应用闭包映射到另一个类型, 这里直接填了个枚举变体, 就是简单的将匹配到的 `&str` 映射到 `Markdown::Code<&str>`, 然后别忘了调用一下 `parse` 方法完成真正的解析
