{"title":"初识 Rust(2) | 你好, 世界!","uid":"4b0f692f776f3adc938ca1b3146c2dd5","slug":"RustCourse-02","date":"2021-04-05T04:36:07.000Z","updated":"2024-03-06T02:36:48.107Z","comments":true,"path":"api/articles/RustCourse-02.json","keywords":"Programming, Web, Frontend, Backend ,Rust, Blog, Aurora, Fontlos, 芳塔洛斯","cover":"https://fontlos.com/cover/ferris.png","content":"<h1 id=\"Hello-Rust\"><a href=\"#Hello-Rust\" class=\"headerlink\" title=\"Hello Rust\"></a>Hello Rust</h1><h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h2><p>学习一门语言的传统都是打印 <strong>Hello World</strong>, 下面让我们用 Rust 的方式向世界问好</p>\n<h2 id=\"创建一个-Rust-文件\"><a href=\"#创建一个-Rust-文件\" class=\"headerlink\" title=\"创建一个 Rust 文件\"></a>创建一个 Rust 文件</h2><p>打开 <strong>VSCode</strong>, 新建一个文件夹用于存放我们的代码, 在里面新建一个 <code>main.rs</code> 文件 (Rust的习惯后缀名为 <code>.rs</code> 虽然在只用 Rustc 编译时别的后缀名也能通过)</p>\n<p>关于文件命名, Rust采用 <strong>蛇形命名法</strong>, 如果名字有多个单词, <strong>无需</strong> 有大写字母, 而是采用 <code>_</code> 来分隔每一个单词，如 <code>hello_world.rs</code>, 尽量避免使用 <strong>ASCII</strong> 字符以外的字符, 不要以数字开头</p>\n<h2 id=\"编写并运行第一个Rust程序\"><a href=\"#编写并运行第一个Rust程序\" class=\"headerlink\" title=\"编写并运行第一个Rust程序\"></a>编写并运行第一个Rust程序</h2><div class=\"language-rust\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">rust</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">// main.rs</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">fn</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">main</span><span style=\"color: #ABB2BF\">() {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF\">println!</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #98C379\">&quot;Hello World!&quot;</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span></code></pre></div><p>在 main.rs 文件上单击右键，选择 <strong>在终端中打开</strong>, 然后执行以下命令</p>\n<div class=\"language-sh\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sh</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #61AFEF\">rustc</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #98C379\">main.rs</span><span style=\"color: #ABB2BF\"> &amp;&amp; </span><span style=\"color: #61AFEF\">main</span></span></code></pre></div><p>终端上会输出</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #abb2bf\">Hello World!</span></span></code></pre></div><h2 id=\"分析这个程序\"><a href=\"#分析这个程序\" class=\"headerlink\" title=\"分析这个程序\"></a>分析这个程序</h2><p>好了, 我们已经创建了第一个 Rust 程序了, 但这段代码到底是什么意思呢? 现在让我们来分析一下:</p>\n<ol>\n<li><code>fn</code> 表示定义一个 <strong>函数</strong>, <code>main</code> 是这个函数的名字, 花括号 <code>{}</code> 里的语句则是这个函数的内容, Rust 要求所有函数体都要用花括号包裹起来. 一般来说, 将左花括号与函数声明置于同一行并以空格分隔, 是良好的代码风格</li>\n<li>名字为 <strong>main</strong> 的函数在 Rust 里有特殊的作用, 即程序的入口, 程序就是从这里开始执行的</li>\n<li><code>println!()</code>是一个宏, 它的功能是打印圆括号<code>()</code>中的内容并换行, <code>!</code> 是宏的标志, 如果是调用函数，则没有 <code>!</code></li>\n<li>在 Rust 中, 语句的末尾一般用分号 <code>;</code> 作为结束标志</li>\n<li>Rust 程序的编译与运行是彼此独立的, 在运行 Rust 程序之前, 必须先使用 Rust 编译器编译它, 即输入 rustc 命令并传入源文件名称</li>\n<li>Rust 是一种 <strong>预编译静态类型</strong> 语言, 这意味着你可以编译程序, 并将可执行文件送给其他人, 他们甚至不需要安装 Rust 就可以运行. 这与解释性语言不同</li>\n</ol>\n<h1 id=\"Hello-Cargo\"><a href=\"#Hello-Cargo\" class=\"headerlink\" title=\"Hello Cargo\"></a>Hello Cargo</h1><p>仅仅使用 Rustc 编译简单程序是没问题的, 不过随着项目的增长, Rustc 就会难以满足需要, 这种时候就需要包管理工具了</p>\n<h2 id=\"cargo简介\"><a href=\"#cargo简介\" class=\"headerlink\" title=\"cargo简介\"></a>cargo简介</h2><p>代码管理对于编程来说一直是一个重要的问题, 各种不同的语言也都会采用不同的代码管理器, Rust 作为一枚现代语言, 综合了现有语言管理工具的优点, 为我们提供了一个大杀器 — <strong>Cargo</strong></p>\n<p>作为 Rust 的代码组织管理工具, cargo 提供了一系列的工具. 从项目的建立, 构建到测试, 运行直至部署, 为 Rust 项目的管理提供尽可能完整的手段. 同时与 Rust 语言及其编译器 Rustc 本身的各种特性紧密结合</p>\n<h2 id=\"cargo入门\"><a href=\"#cargo入门\" class=\"headerlink\" title=\"cargo入门\"></a>cargo入门</h2><p>在我们安装 Rust 的时候就已经安装好了 Cargo</p>\n<h3 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h3><p>新建一个文件夹并在终端中打开, 输入以下命令</p>\n<div class=\"language-sh\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sh</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #61AFEF\">cargo</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #98C379\">new</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #98C379\">hello_cargo</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">--bin</span></span></code></pre></div><p><code>--bin</code> 是一个参数, 代表这是一个 <strong>Bin</strong> crate, 最终将会被编译为二进制可执行文件, Cargo 默认创建 Bin crate, 所以该参数可以不加</p>\n<h3 id=\"查看目录结构\"><a href=\"#查看目录结构\" class=\"headerlink\" title=\"查看目录结构\"></a>查看目录结构</h3><p><code>hello_cargo</code> 文件夹下有一个 <code>src</code> 和一个 <code>Cargo.toml</code> 文件, src 文件夹下有一个 <code>main.rs</code> 文件，它也在 hello_cargo 目录初始化了一个 <code>.git</code> 仓库, 以及一个 <code>.gitignore</code> 文件, 在 VSCode 中我们可以很轻易地使用 Git</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #abb2bf\">hello_cargo</span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\">├── Cargo.toml</span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\">└── src</span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\">    └── main.rs</span></span></code></pre></div><h3 id=\"编辑-main-rs-并运行\"><a href=\"#编辑-main-rs-并运行\" class=\"headerlink\" title=\"编辑 main.rs 并运行\"></a>编辑 main.rs 并运行</h3><p>Cargo 初始化的 main.rs 里会有一些默认内容, 我们把它改为</p>\n<div class=\"language-rust\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">rust</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">// hello_cargo/src/main.rs</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">fn</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">main</span><span style=\"color: #ABB2BF\">() {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #61AFEF\">println!</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #98C379\">&quot;Hello, Cargo!&quot;</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span></code></pre></div><p>随后在终端输入以下命令</p>\n<div class=\"language-sh\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sh</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #61AFEF\">cargo</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #98C379\">build</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #7F848E; font-style: italic\"># Debug 模式</span></span>\n<span class=\"line\"><span style=\"color: #61AFEF\">cargo</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #98C379\">build</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">--release</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #7F848E; font-style: italic\"># Release 模式 --release 代表优化编译</span></span></code></pre></div><p>也可以直接使用 <code>cargo run</code> 命令编译并运行</p>\n<p>这两个命令分别会在以下文件夹下生成可执行文件</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #abb2bf\">./target/debug/hello_cargo.exe</span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\">./target/release/hello_cargo.exe</span></span></code></pre></div><h1 id=\"Crate-与-Package\"><a href=\"#Crate-与-Package\" class=\"headerlink\" title=\"Crate 与 Package\"></a>Crate 与 Package</h1><p>我们说过 Cargo 是一个强大的包管理工具, 让我们先来介绍以下几个概念:</p>\n<ol>\n<li><strong>Crate</strong>: 通常翻译为 <strong>包</strong>, 包括 <strong>Bin Crate (将被编译为可执行文件)</strong> 和 <strong>Lib Crate (将被编译为库文件)</strong></li>\n<li><strong>Package</strong>: 包的名字已经被 Crate 占用, 这里可以被理解为 <strong>项目</strong>, 一个 Package 包括至多一个 Lib Crate 或任意数量得 Bin Crate 或者两者同时存在. 这一概念容易和 Crate 混淆, 一个方便理解得例子是对于 Bin Crate, 当我们初始化一个 Bin Crate 时看起来就像一个 Package, 这是因为这个 Crate 和 Package 的名字是一样的, 都是项目名. 但别忘了我们还可以在项目中创建其他的不同名字的将被编译为可执行文件的 <code>.rs</code> 文件</li>\n<li><strong>WorkSpace</strong>: <strong>工作空间</strong>, 用于在大型项目中组织多个 Package</li>\n</ol>\n<p>一个标准 Cargo Package 目录结构通常如下:</p>\n<ul>\n<li><code>cargo.toml</code> 和 <code>cargo.lock</code> 文件位于项目根目录</li>\n<li>源代码位于 <code>src</code></li>\n<li>默认的 Lib crate 入口文件是 <code>src/lib.rs</code></li>\n<li>默认的 Bin crate入口文件是 <code>src/main.rs</code></li>\n<li>其他可选的可执行文件位于 <code>bin/*.rs</code> (这里每一个rs文件均对应一个可执行文件)</li>\n<li>外部测试源代码文件位于 <code>tests</code></li>\n<li>示例程序源代码文件位于 <code>examples</code></li>\n<li>基准测试源代码文件位于 <code>benches</code></li>\n</ul>\n<h2 id=\"Cargo-toml\"><a href=\"#Cargo-toml\" class=\"headerlink\" title=\"Cargo.toml\"></a>Cargo.toml</h2><p>Cargo 的项目数据描述文件, 存储了项目的所有信息</p>\n<div class=\"language-toml\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">toml</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #ABB2BF\">[</span><span style=\"color: #61AFEF\">package</span><span style=\"color: #ABB2BF\">]</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">name</span><span style=\"color: #ABB2BF\"> = </span><span style=\"color: #98C379\">&quot;hello_cargo&quot;</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">description</span><span style=\"color: #ABB2BF\"> = </span><span style=\"color: #98C379\">&quot;&quot;</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">version</span><span style=\"color: #ABB2BF\"> = </span><span style=\"color: #98C379\">&quot;0.1.0&quot;</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">authors</span><span style=\"color: #ABB2BF\"> = [</span><span style=\"color: #98C379\">&quot;YourName &lt;Your email&gt;&quot;</span><span style=\"color: #ABB2BF\">]</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">edition</span><span style=\"color: #ABB2BF\"> = </span><span style=\"color: #98C379\">&quot;2021&quot;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">[</span><span style=\"color: #61AFEF\">dependencies</span><span style=\"color: #ABB2BF\">]</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">crate1</span><span style=\"color: #ABB2BF\"> = </span><span style=\"color: #98C379\">&quot;0.3&quot;</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">crate2</span><span style=\"color: #ABB2BF\"> = </span><span style=\"color: #98C379\">&quot;0.2*&quot;</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">crate3</span><span style=\"color: #ABB2BF\"> = { </span><span style=\"color: #E06C75\">version</span><span style=\"color: #ABB2BF\"> = </span><span style=\"color: #98C379\">&quot;0.5.0&quot;</span><span style=\"color: #ABB2BF\">}</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">crate4</span><span style=\"color: #ABB2BF\"> = { </span><span style=\"color: #E06C75\">git</span><span style=\"color: #ABB2BF\"> = </span><span style=\"color: #98C379\">&quot;https://github.com/name/crate_name&quot;</span><span style=\"color: #ABB2BF\"> }</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">crate5</span><span style=\"color: #ABB2BF\"> = { </span><span style=\"color: #E06C75\">path</span><span style=\"color: #ABB2BF\"> = </span><span style=\"color: #98C379\">&quot;path/crate_name&quot;</span><span style=\"color: #ABB2BF\"> }</span></span></code></pre></div><p><strong>TOML</strong> 是Rust的官方配置文件格式, 由像 <code>[package]</code> 或 <code>[dependencies]</code> 这样的段落组成, 每一个段落又由多个字段组成, 这些段落和字段就描述了项目组织的基本信息</p>\n<ul>\n<li><code>package</code> 段落<ul>\n<li><code>name</code> 字段表明项目的名称. 当发布 crate时, <code>crates.io</code> 将使用此字段标明的名称. 这也是编译时输出的二进制可执行文件的名称</li>\n<li><code>version</code> 字段是使用 <strong>语义版本控制</strong> 的 crate 版本号</li>\n<li><code>description</code> 字段是对项目的描述</li>\n<li><code>authors</code> 字段表明发布 crate 时的作者列表</li>\n<li><code>edition</code> 字段是对项目的 <strong>Edition (版次)</strong> 声明, 作为一门成熟的语言很重要的一点就是向后兼容. 但有的时候, 面对一些历史遗留问题, 做出一些不兼容的更改也是有需要的, Rust 通过不同的版次引入不兼容的新特性或者删除旧的特性</li>\n</ul>\n</li>\n<li><code>dependencies</code> 段落可以让你为项目添加依赖, 包括一下几种:<ul>\n<li>基于 Rust 官方仓库, 通过版本说明来描述</li>\n<li>基于项目源代码的 Git 仓库地址, 通过 URL 来描述</li>\n<li>基于本地项目的绝对路径或者相对路径</li>\n</ul>\n</li>\n</ul>\n<p>而对于 WorkSpace, <code>Cargo.toml</code> 的内容可能是这样的</p>\n<div class=\"language-toml\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">toml</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #ABB2BF\">[</span><span style=\"color: #61AFEF\">workspace</span><span style=\"color: #ABB2BF\">]</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">members</span><span style=\"color: #ABB2BF\"> = [</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #98C379\">&quot;path/crate1&quot;</span><span style=\"color: #ABB2BF\">,</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #98C379\">&quot;path/crate2&quot;</span><span style=\"color: #ABB2BF\">,</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #98C379\">&quot;...&quot;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">]</span></span></code></pre></div><h2 id=\"Cargo-lock\"><a href=\"#Cargo-lock\" class=\"headerlink\" title=\"Cargo.lock\"></a>Cargo.lock</h2><p>该不需要直接修改, 是 Cargo 工具根据 <code>Cargo.toml</code> 生成的项目依赖详细清单文件</p>\n<h2 id=\"定义集成测试用例\"><a href=\"#定义集成测试用例\" class=\"headerlink\" title=\"定义集成测试用例\"></a>定义集成测试用例</h2><p>Cargo 另一个重要的功能, 即将软件开发过程中必要且非常重要的测试环节进行集成, 并通过代码属性声明或者 <code>Cargo.toml</code> 文件描述来对测试进行管理</p>\n<p>单元测试主要通过在项目代码的测试代码部分前用 <code>#[test]</code> 属性来描述</p>\n<p>集成测试一般都会通过 <code>Cargo.toml</code> 文件中的 <code>[[test]]</code> 段落进行描述</p>\n<p>简单的示例:</p>\n<div class=\"language-toml\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">toml</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #ABB2BF\">[[</span><span style=\"color: #61AFEF\">test</span><span style=\"color: #ABB2BF\">]]</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">name</span><span style=\"color: #ABB2BF\"> = </span><span style=\"color: #98C379\">&quot;test1&quot;</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">path</span><span style=\"color: #ABB2BF\"> = </span><span style=\"color: #98C379\">&quot;tests/test1.rs&quot;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">[[</span><span style=\"color: #61AFEF\">test</span><span style=\"color: #ABB2BF\">]]</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">name</span><span style=\"color: #ABB2BF\"> = </span><span style=\"color: #98C379\">&quot;test2&quot;</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">path</span><span style=\"color: #ABB2BF\"> = </span><span style=\"color: #98C379\">&quot;tests/test2.rs&quot;</span></span></code></pre></div><p>上述例子中, <code>name</code> 字段定义了集成测试的名称, <code>path</code> 字段定义了集成测试文件相对于 <code>Cargo.toml</code> 的路径.</p>\n<p>看看，定义集成测试就是如此简单, 但需要注意的是:</p>\n<ol>\n<li>如果没有在 <code>Cargo.toml</code> 里定义集成测试的入口, 那么<code>tests</code> 目录(不包括子目录)下的每个 <code>.rs</code> 文件被当作集成测试入口</li>\n<li>如果在 <code>Cargo.toml</code> 里定义了集成测试入口, 那么定义的那些 <code>.rs</code> 文件就是入口, 不再默认指定任何集成测试入口.</li>\n</ol>\n<h2 id=\"定义示例和可执行文件\"><a href=\"#定义示例和可执行文件\" class=\"headerlink\" title=\"定义示例和可执行文件\"></a>定义示例和可执行文件</h2><p>Example 用例的描述以及 Bin 用例的描述也是 Cargo 的常用功能</p>\n<div class=\"language-toml\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">toml</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #ABB2BF\">[[</span><span style=\"color: #61AFEF\">example</span><span style=\"color: #ABB2BF\">]]</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">name</span><span style=\"color: #ABB2BF\"> = </span><span style=\"color: #98C379\">&quot;examlpe1&quot;</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">path</span><span style=\"color: #ABB2BF\"> = </span><span style=\"color: #98C379\">&quot;examples/examlpe1.rs&quot;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">[[</span><span style=\"color: #61AFEF\">bin</span><span style=\"color: #ABB2BF\">]]</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">name</span><span style=\"color: #ABB2BF\"> = </span><span style=\"color: #98C379\">&quot;bin1&quot;</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">path</span><span style=\"color: #ABB2BF\"> = </span><span style=\"color: #98C379\">&quot;bin/bin1.rs&quot;</span></span></code></pre></div><p>对于 <code>[[example]]</code> 和 <code>[[bin]]</code> 段落中声明的Examples 和 Bins，需要通过 <code>cargo run --example &lt;NAME&gt;</code> 或者 <code>cargo run --bin &lt;NAME&gt;</code> 来运行</p>\n<h2 id=\"其他Cargo命令\"><a href=\"#其他Cargo命令\" class=\"headerlink\" title=\"其他Cargo命令\"></a>其他Cargo命令</h2><ul>\n<li>cargo clean: 清理 <code>target</code> 文件夹中的所有内容</li>\n<li>cargo update: 根据 <code>Cargo.toml</code> 重新检索并更新各种依赖项的信息, 并写入 <code>Cargo.lock</code></li>\n<li>cargo install: 安装 <code>crates.io</code> 可用于实际的生产的可执行文件</li>\n<li>cargo fmt: 代码格式化工具</li>\n</ul>\n<p>从这开始, 请把 Cargo 当作习惯, 对于简单项目, Cargo 并不比 Rustc 提供了更多的优势, 不过随着开发的深入, 终将证明其价值</p>\n<h1 id=\"注释与文档\"><a href=\"#注释与文档\" class=\"headerlink\" title=\"注释与文档\"></a>注释与文档</h1><p>最后, 让我们学习一下 Rust 的注释</p>\n<p>Rust中有三种注释，前两种分别为:</p>\n<ol>\n<li>行注释 <code>//...</code></li>\n<li>C 语言风格的块注释 <code>/*...*/</code></li>\n</ol>\n<div class=\"language-rust\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">rust</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">// 创建一个绑定</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">let</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">x</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">5</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">let</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">y</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">6</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E; font-style: italic\"> // 创建另一个绑定</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">/*这是一段块注释*/</span><span style=\"color: #C678DD\">let</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">;</span><span style=\"color: #7F848E; font-style: italic\">/*块注释不影响块以外的代码*/</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">/*</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">块注释可以有很多行</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">*/</span></span></code></pre></div><p>Rust的第三种注释是 <strong>文档注释</strong> ,文档注释又分为两小种, 支持 <strong>Markdown</strong> 语法:</p>\n<ol>\n<li><code>//!</code> 模块注释, 用来描述包含它的项, 一般用在模块文件的头部</li>\n<li><code>///</code> 用来描述的它后面接着的项</li>\n</ol>\n<div class=\"language-rust\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">rust</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">//! 这是一个模块</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">/// Add One</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">/// # Example</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">/// ```rust</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">/// let one = 1;</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">///</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">/// assert_eq!(2, add_one(one));</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">/// fn add_one(x: i32) -&gt; i32 {</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">///     x + 1</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">/// }</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">/// ```</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">fn</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">add_one</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E06C75\">x</span><span style=\"color: #ABB2BF\">: </span><span style=\"color: #E5C07B\">i32</span><span style=\"color: #ABB2BF\">) -&gt; </span><span style=\"color: #E5C07B\">i32</span><span style=\"color: #ABB2BF\"> {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E06C75\">x</span><span style=\"color: #ABB2BF\"> + </span><span style=\"color: #D19A66\">1</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span></code></pre></div><h2 id=\"生成文档\"><a href=\"#生成文档\" class=\"headerlink\" title=\"生成文档\"></a>生成文档</h2><p>Rust 工具链可以很轻易地从文档注释中生成漂亮的 <strong>HTML</strong> 文档:</p>\n<ol>\n<li><code>rustdoc *.rs</code>: 用于单个文件</li>\n<li><code>cargo doc</code>: 用于整个项目</li>\n</ol>\n","feature":false,"text":"Rust 与 Cargo 的基本操作, 注释与文档...","permalink":"/post/RustCourse-02","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"Course","slug":"Course","count":11,"path":"api/categories/Course.json"}],"tags":[{"name":"Rust","slug":"Rust","count":12,"path":"api/tags/Rust.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Hello-Rust\"><span class=\"toc-text\">Hello Rust</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Hello-World\"><span class=\"toc-text\">Hello World</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-Rust-%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">创建一个 Rust 文件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99%E5%B9%B6%E8%BF%90%E8%A1%8C%E7%AC%AC%E4%B8%80%E4%B8%AARust%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">编写并运行第一个Rust程序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">分析这个程序</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Hello-Cargo\"><span class=\"toc-text\">Hello Cargo</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#cargo%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">cargo简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#cargo%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">cargo入门</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">创建项目</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">查看目录结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%BE%91-main-rs-%E5%B9%B6%E8%BF%90%E8%A1%8C\"><span class=\"toc-text\">编辑 main.rs 并运行</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Crate-%E4%B8%8E-Package\"><span class=\"toc-text\">Crate 与 Package</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Cargo-toml\"><span class=\"toc-text\">Cargo.toml</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Cargo-lock\"><span class=\"toc-text\">Cargo.lock</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B\"><span class=\"toc-text\">定义集成测试用例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E7%A4%BA%E4%BE%8B%E5%92%8C%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">定义示例和可执行文件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96Cargo%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">其他Cargo命令</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E9%87%8A%E4%B8%8E%E6%96%87%E6%A1%A3\"><span class=\"toc-text\">注释与文档</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3\"><span class=\"toc-text\">生成文档</span></a></li></ol></li></ol>","author":{"name":"芳塔洛斯","slug":"blog-author","avatar":"https://fontlos.com/icons/avatar.jpg","link":"/","description":"来人间一趟, 为散步一场<br />待走出岁月, 何样的彼方<br />才配得上这一路的颠沛与时光","socials":{"github":"https://github.com/fontlos","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"https://fontlos.com/icons/bilibili.svg","link":"https://space.bilibili.com/362772872"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"初识 Rust(4) | 作用域, 所有权机制, 函数与返回值, 复合类型, Module 与可见性","uid":"692ddd8a7f3465e5861ddef99bf86d5f","slug":"RustCourse-04","date":"2021-06-08T04:10:27.000Z","updated":"2024-03-06T02:36:48.107Z","comments":true,"path":"api/articles/RustCourse-04.json","keywords":"Programming, Web, Frontend, Backend ,Rust, Blog, Aurora, Fontlos, 芳塔洛斯","cover":"https://fontlos.com/cover/ferris.png","text":"回顾作用域, 初步了解作用域和堆栈相关知识, 熟悉 Rust 首创的所有权机制. 函数的初步认识. 介绍一下复合类型, 结构体, 枚举. 最后了解一下包, 模块, 以及结构体和枚举内部成员的可见性, 以及如何公开并引入成员...","permalink":"/post/RustCourse-04","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"Course","slug":"Course","count":11,"path":"api/categories/Course.json"}],"tags":[{"name":"Rust","slug":"Rust","count":12,"path":"api/tags/Rust.json"}],"author":{"name":"芳塔洛斯","slug":"blog-author","avatar":"https://fontlos.com/icons/avatar.jpg","link":"/","description":"来人间一趟, 为散步一场<br />待走出岁月, 何样的彼方<br />才配得上这一路的颠沛与时光","socials":{"github":"https://github.com/fontlos","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"https://fontlos.com/icons/bilibili.svg","link":"https://space.bilibili.com/362772872"}}}},"feature":false},"next_post":{"title":"如何给文章分类","uid":"8173c9ee4324b3b3ef1ff94914260b8e","slug":"2021-02-21","date":"2021-02-21T01:54:09.000Z","updated":"2024-03-06T02:36:48.103Z","comments":true,"path":"api/articles/2021-02-21.json","keywords":"Programming, Web, Frontend, Backend ,Rust, Blog, Aurora, Fontlos, 芳塔洛斯","cover":"https://fontlos.com/icons/logo.png","text":"关于博客如何规划 Category 和 Tag 的一些看法...","permalink":"/post/2021-02-21","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"Other","slug":"Other","count":1,"path":"api/categories/Other.json"}],"tags":[{"name":"Methodology","slug":"Methodology","count":1,"path":"api/tags/Methodology.json"},{"name":"Tip","slug":"Tip","count":1,"path":"api/tags/Tip.json"}],"author":{"name":"芳塔洛斯","slug":"blog-author","avatar":"https://fontlos.com/icons/avatar.jpg","link":"/","description":"来人间一趟, 为散步一场<br />待走出岁月, 何样的彼方<br />才配得上这一路的颠沛与时光","socials":{"github":"https://github.com/fontlos","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"https://fontlos.com/icons/bilibili.svg","link":"https://space.bilibili.com/362772872"}}}},"feature":false}}