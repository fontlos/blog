[{"id":"71664c173db75f1c7fc4f710319bb199","title":"一文速通 Python 基础","content":"非官方的 Python 极简教程, 不会完全按照常规教程的体系进行, 适合快速熟悉语法, 并且会介绍一些与基础相关但冷门的内容\nPython 极简介绍Python 是一门 高层次的 动态类型的 弱类型的 解释型 语言, 下面逐一解释这些名词的含义\n\n高层次: 对比汇编这种底层的低级语言, C&#x2F;C++ 这种偏底层的中级语言, Python是高度抽象的, 更加接近自然语言, 关键字很少, 便于理解记忆\n动态类型: 一个软件在运行时的状态被称为 Runtime (运行时), 而动态类型就是指只有在运行时才会进行类型检查, 这意味着变量的数据类型不是在编译期确定的, 而是在程序运行过程中才会绑定的\n弱类型: 弱类型语言允许变量被赋予不同的数据类型, 不需要任何显式的类型转换, 比如一个整数类型, 既可以被赋值数字 0, 也可以被赋值字符 “0”\n解释型: 指不需要被编译成计算机可以直接识别的机器码, 而是通过解释器进行逐行解释在运行时翻译执行\n\n环境配置 (以 Windows 为例)Python 安装可以直接下载并运行官网提供的 安装器, 安装过程建议勾选 Add Python 3.x to PATH (用于自动添加环境变量) 并选择自定义安装, 在设置 Optional Features 界面最好将 pip, tcl&#x2F;tk, Python test suite 等项全部勾选上. 强烈建议选择自定义的安装路径并保证路径中没有中文\n也可以手动下载 压缩包, 解压到任意目录, 并手动添加到环境变量\n通过在终端执行\nshpython -V如果显示了版本信息, 则安装完成\n你也可以直接通过在终端输入 python 并回车进入终端交互式页面编写一次性代码, 当然更多情况下我们还是会使用代码编辑器进行编码\n编辑器安装配置最专业的 Python IDE (集成开发环境) 当然是 Jetbrains 的 Pycharm, 但对于初学者而言, 单个脚本或小型项目的编写更推荐使用 VSCode, 点击链接下载安装后, 只需要再安装 Python 插件即可\n下面是其他的可能需要的插件\n\nChinese (Simplified) 简体中文插件\nCode Runner 为 Python 等语言添加右键运行菜单\nCodeium 一个类似 Copilot 的 AI 代码提示插件\n\n编辑器基本使用打开 VSCode, 点击左下角齿轮图标, 点击设置, 在设置中搜索 Auto Save, 将 Auto Save 选项改成 afterDelay, 将 Auto Save Delay 选项改成 1000, 这表示每 1000 ms 自动保存一次文件\n在左侧侧边栏选择打开一个空文件夹, 在文件夹内新建一个 &lt;文件名&gt;.py 文件. 接下来就可以在文件内编写代码了\n编写完成后, 在对应文件上右键, 选择 在集成终端中打开, 在新打开的终端中输入\nsh# 表示调用 Python 解释器执行这个文件, 注意空格\npython &lt;文件名&gt;.py如果安装了 Code Runner 插件, 你也可以在文件编辑区内右键选择 Run Code, 在文件上右键选择 Run Code, 或在文件编辑区右上角单击小三角来运行程序\n熟悉 Python 世界的基本工具注释对于一个 Python 文件, 或者对于任何的不论是语言, 知识还是笔记, 适当的注解都是至关重要的. 这些能够帮助你在很长时间后快速熟悉起曾经写下的内容, 也能时刻提醒自己: 自己该做什么, 自己在做什么, 自己做了什么\n即便 Python 已经是一门高度抽象的高级语言, 但自然语言仍然比这些代码更加易懂, 因此编写代码的时候, 注释尤为重要\n在 Python 文件中可以使用以下两种注释\npy# 一个井号后面的内容都将作为注释, 不会被执行, 这被称为单行注释\nprint(&quot;你好, 世界!&quot;) # 单行注释也可以放在代码的后面\n\n&quot;&quot;&quot;\n三组双引号之间是多行注释\n这之间的所有内容都将被忽略\n&quot;&quot;&quot;在这同时我们也按照惯例写出了最简单的 Python 程序, 运行程序, 即可看到控制台输出了 你好, 世界!\nPrint 控制台输出接下来让我们认识一下第二个基本工具, 我们已经在上面见过它了: print() 函数. 这将是我们基础知识中最常用的一个函数, 它的意义和数学中的函数类似, 有函数的名字, 后面跟上一个小括号, 括号里面放函数的参数, 最后函数可以计算出一个值. 就像它的名字 “打印”, 它的功能就是将括号中的参数打印到控制台中, 你不仅可以打印字符, 还可以打印变量, 和几乎所有的数据类型, 我们会在后面逐一介绍\n变量与基本数据类型变量就像数学中可以 “令 x &#x3D; 1” 那样, Python同样可以用极为类似的方式声明变量\npyx = 1对没错, 仅此而已, 就是那么简单, 用一个等号连接. 等号左边是变量的名字, 等号右边是变量的值\n对于变量的名字, 理论上可以是符合下列规则的任何字符串\n\n硬性规则\n由字母 (广义的 Unicode 字符, 不包括 空格 等特殊字符), 数字和下划线构成, 但不能以数字开头\n大小写敏感 (大写的 a 和小写的 A 是两个不同的变量)\n不要跟关键字 (有特殊含义的单词, 后面会讲到, 比如 if, else 等) 和系统保留字 (如刚刚学到的 print 函数的名字, 模块的名字等) 冲突\n\n\nPEP 8 要求:\n用小写字母拼写, 多个单词用下划线连接。\n受保护的实例属性用单个下划线开头 (后面会讲到)\n私有的实例属性用两个下划线开头 (后面会讲到)\n\n\n\n还记得刚刚说的 print 函数可以用来打印变量吗, 快来试试吧\npyx = 1\nprint(x) # 打印变量基本数据类型pystring = &quot;字符串&quot;\nstring2 = &#39;单引号也可以&#39;\ninteger_num = -1 # 整数类型, 简称整型, 在 Python 3.x 之后已经不区分长整型和短整型了\nfloat_num = 1.0 # 浮点数类型, 简称浮点型, 表示小数\nbool_type = True # 布尔类型, 用于表示 &quot;真&quot; 或 &quot;假&quot;, 只有两种值 &quot;True&quot; 或 &quot;False&quot;\n\nbig_num = 1_000_000 # 可以通过下划线分割长数字增加可读性\nsci_num = 2e2 # 科学计数法, 表示 2.0 * 10^2, 自带至少一位小数, 200.0\nsci_num2 = 2.000000e+02 # 标准科学计数法, 表示 2.0 * 10^2, 自带至少一位小数, 200.0\nbin_num = 0b101 # 以 &quot;0b&quot; 开头的是二进制数字类型, 注意后面跟的数字不能超过 1, 打印时默认以十进制输出\nhex_num = 0x12abcdef # 以 &quot;0x&quot; 开头的是十六进制数字类型, 包含 0-9, a-f 这些字符, 打印时默认以十进制输出打印数据类型我们可以通过 type() 函数来获取一个变量的数据类型\npya = 1\nprint(type(a))\n#这将会输出 &quot;&lt;class &#39;int&#39;&gt;&quot;格式化输出就像上面说的, 二进制和十六进制的小数被打印时默认都是十进制, 那么有没有办法让它们以原来的样子输出呢? 这就要提到 格式化输出 了, 事实上我们可以为很多类型的输出自定义其格式\n下面将会看到字符串内部有多种 % 开头的短字符串, 它们表示一个占位符并且具有特殊的格式, 在这个主字符串后面用单个 % 相隔会有一些数据类型, 他们将会替换掉前面的占位符并继承它的格式\npyprint(&quot;%c&quot; % &quot;C&quot;) # %c 表示 char, 将值格式化为单个字符\nprint(&quot;%s&quot; % &quot;String&quot;) # %s 表示 string, 将值格式化为字符串\nprint(&quot;%d&quot; % 1.0)  # %d 表示将值格式化整数\nprint(&quot;%f&quot; % 1) # %f 表示格式化为标准浮点数\nprint(&quot;%.2f&quot; % 1) # %.2f 表示格式化为两位小数, 当然也可以指定其他精度\nprint(&#39;%e&#39; % 1.0e3) # %e 表示将值格式化为标准科学计数法可以简单的通过逗号隔开打印多个值和变量, 也可以通过 format 将变量嵌入到字符串中\npyname = &quot;Job&quot;\n\nprint(&quot;Hello &quot;,name)\n# 用 f 进行标记, 即可通过外面包裹花括号的方式将变量嵌入字符串\nprint(f&quot;Hello {name}&quot;)运算符运算符, 顾名思义, 用于运算的符号, 可以用于值或变量的运算, 其中就有我们在数学中熟悉的数学运算符, 包括加减乘除等. 同样, 就像数学中先乘除后加减那样, Python中的运算符也有优先级之分\n下面将按照优先级从高到低的顺序列出常见运算符, 仅加粗部分为常用运算符\n\n小括号: (), 最高级的运算符\n索引&#x2F;切片运算符: [], [:], 其作用分别是\n取列表或元组元素下标\n取列表或元组切片\n\n\n优先级比较特殊的运算符: ~, +, -, 其功能分别如下\n(不常用)位运算符中优先级较高的特例, 按位取反, 比如 ~4 意思是 4 的 二进制 100 每一位进行取反, 即 001, 即十进制的 1\n取正负号\n\n\n数学运算符\n**: 乘幂运算符, 例如 2 ** 3 &#x3D; 8, 当幂次是既约真分数时至少自带一位小数\n*, /, %, //, 其功能分别是:\n乘法运算符\n除法运算符, 自带至少一位小数\n除法取余数运算符, 例如 5 % 3 &#x3D; 2\n除法取整数运算符, 例如 5 &#x2F;&#x2F; 3 &#x3D; 1\n\n\n+, -: 加减法运算符\n\n\n(不常用)位运算符\n&gt;&gt;, &lt;&lt;\n前者为右移运算符, 将数字类型的二进制值右移, 相当于除 2 运算, 例如 4 &gt;&gt; 1 意思是 4 的二进制 100 整体右移一位, 导致末尾 0 消失, 变成 10 即十进制的 2\n后者为左移运算符, 类比右移运算符, 相当于乘 2 运算, 例如 1 &lt;&lt; 10 相当于 1 的二进制 1 整体左移十位, 空位补零变成 10000000000, 即十进制的 1024\n注: 在早期 CPU 上位运算的速度大于乘法运算, 但在现代 CPU 与编译器优化下, 二者区别已经不大了\n\n\n&amp; 按位与运算符, 对两个二进制执行按位与运算, 相同为 1 不同为 0, 例如 4 &amp; 5 意思是 4 和 5 的二进制 100 和 101 按位与运算得到 110, 即十进制的6\n^, |: 前者为按位异或运算符, 后者为按位或运算符\n\n\n比较运算符, 返回布尔值\n&gt;, &lt;, &gt;=, &lt;=, 判断是否大于, 小于, 大于等于, 小于等于\n==, !=, 判断是否等于, 是否不等于\n\n\n身份运算符: is, is not\n成员运算符: in, not in\n逻辑运算符: and, or, not, 分别对应 与, 或, 非 运算\n与运算, 连接的两个表达式都为真时才为真, 例如 5 &gt; 4 and 6 &gt; 5 返回 True\n短路功能: 当与运算左侧为假时, 右侧表达式不进行计算, 整体即可判定为假\n\n\n或运算, 连接的两个表达式有一个为真时就为真, 例如 5 &gt; 4 or 5 &gt; 6 返回 True\n短路功能: 当或运算左侧为真时, 右侧表达式不进行计算, 整体即可判定为真\n\n\n非运算, 后接真时返回假, 后接假时返回真, 例如 not 5 == 4 返回真\n\n\n赋值运算符: =, +=, -=, *=, /=, %=, //=, **=, &amp;=\n= 是最常用的赋值运算符\n+= 加法赋值运算, 例如 a += 6 意思是 a = a + 6, 后面的其他运算符同理\n(不常用) &amp;= 是按位与赋值运算符\n(不常用) 赋值运算符链式调用时从左往右运算, 比如 a = b = c 意思是 a = (b = c), a = b += 4 意思是 a = (b = b + 4)\n\n\n\n集合类型类似数学中的集合, 向量, Python 中也有集合类型, 用于储存多个值\n有序集合不同于多数语言, Python 的有序集合类型不包括数组, 而是用列表取而代之, 除此之外还有元组. 作为有序集合类型, 那么自然而然地可以理解, 每一个元素都有一个对应的编号. 但需要注意的是, 在包括 Python 在内的绝大多数编程语言中, 索引都是从 0 开始的, 即不论是列表还是元组, 其第一个元素的编号或者说索引都是 0!\n还有一点特殊的是, Python 中的索引可以是 负值, 表示 倒数第几个元素, 比如 -1 表示最后一个元素\n\n列表 (List)\n使用 [] 包裹的一组用逗号隔开的值\n值可以是任何类型, 可以是不同的类型, 甚至包括列表本身\n列表是可以被改变的, 可以通过列表内置的方法进行增加, 删除, 修改, 查询元素\n方法可以理解为一种数据类型自带的函数, 通过 变量/值.[函数名]() 调用\n\n\n\n\n元组 (Tuple)\n使用 () 包裹的一组用逗号隔开的值, 但 () 可以省略不写\n值可以是任何类型, 可以是不同的类型, 甚至包括元组本身\n元组一旦确定就不可以被更改\n\n\n\npymy_list = [1, 1.5, &quot;a&quot;, [0, True]]\nmy_tuple = 1, 1.5, &quot;a&quot;, (0, True)\n\n# 可以通过列表内置的一些方法操作列表\nmy_list.append(1) # 添加单个元素在列表末尾\n# 此时 my_list = [1, 1.5, &quot;a&quot;, [0, True], 1]\nmy_list.extend((2, 3)) # 添加多个元素在列表末尾, 注意需要括号\n# 此时 my_list = [1, 1.5, &quot;a&quot;, [0, True], 1, 2, 3]\nmy_list.insert(2,&quot;b&quot;) # 在索引为 2 的元素后面插入值 &quot;b&quot;\n# 此时 my_list = [1, 1.5, &quot;a&quot;, &quot;b&quot;, [0, True], 1, 2, 3]\nmy_list.remove([0, True]) # 删除指定值的元素\n# 此时 my_list = [1, 1.5, &quot;a&quot;, &quot;b&quot;, 1, 2, 3]\nmy_list.pop(1) # 删除指定索引的元素\n# 此时 my_list = [1,&quot;a&quot;, &quot;b&quot;, 1, 2, 3]\na = my_list.index(1) # 获取指定索引的值\n# a = &quot;a&quot;\nmy_list.clear() # 清空列表除了通过方法获得列表的值, 还可以直接通过索引或切片来获取, 还记得 (运算符)[#运算符] 部分提到的 索引&#x2F;切片运算符 吗\n下面的内容不仅对列表有效, 对元组同样有效\n\n索引\n通过在变量后追加一个方括号来获取索引元素, 形如 variable[index]\n\n\n切片: 字面意思, 获取变量中的一段\n通过在变量后追加一个方括号来获取切片, 形如 variable[start:end:step]\nstart: 表示截取的起始索引, 且包含, 不写则截取到开头 (可以理解为从正方向的 0 号开始截取)\nend: 表示截取的终止索引, 但不包含, 不写则截取到结尾 (可以理解为从负数索引截取到 0 号)\nstep: 步长, 即从起始索引开始, 每隔多少个元素选取一个元素, 不写默认为 1\n总之, 切片相当于从集合中取了一个 “左闭右开区间”\n\n\n\npyarr = [1, 2, 3, 4, 5]\n# 通过在列表或元组变量后追加一个方括号来获取索引元素或切片\none = arr[0]\n# one 等于 arr 列表的第一个元素, 即 1\nfive = arr[-1]\n# five 等于 arr 列表的倒数第一个元素, 即 5\narr1 = arr[:3]\n# 根据参数省略规则, 截取索引为 0, 1, 2 的切片, 即 [1, 2, 3]\narr2 = arr[-2:]\n# 根据参数省略规则, 截取索引为 -2, -1 的切片, 即 [4, 5]\narr3 = arr[:]\n# 工具参数省略规则, 截取整个列表作为切片\n# 切片的最后, 可以通过 len() 函数获取集合元素的长度, 即内部有多少个元素\npyarr = [1, 2, 3, 4, 5]\n\nprint(len(arr)) # 输出 5字典字典 是一种无序集合类型, 在其它语言中通常被称为 哈希表, 是一种 键值对应 的数据结构, 用大括号包裹, 键值之间通过冒号隔开, 下面是一些基本示例\npy# 创建字典的字面量语法\nscores = {&#39;A&#39;: 1, &#39;B&#39;: 2, &#39;C&#39;: 3}\nprint(scores)\n\n# 创建字典的构造器语法\nitems1 = dict(one=1, two=2, three=3, four=4)\n\n# 通过 zip 函数将两个序列压成字典\nitems2 = dict(zip([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], &#39;123&#39;))\n\n# 创建字典的推导式语法\nitems3 = {num: num ** 2 for num in range(1, 10)}\nprint(items1, items2, items3)\n\n# 通过键可以获取字典中对应的值\nprint(scores[&#39;A&#39;])\nprint(scores[&#39;B&#39;])\n\n# 对字典中所有键值对进行遍历\nfor key in scores:\n    print(f&#39;{key}: {scores[key]}&#39;)\n\n# 更新字典中的元素\nscores[&#39;A&#39;] = 4\nscores[&#39;B&#39;] = 5\nscores.update(A=6, B=7)\nprint(scores)\n\n# 直接通过键获取对应的值\nif &#39;D&#39; in scores:\n    print(scores[&#39;D&#39;])\n\n# 通过 get 获取键对应的值, 且当键不存在时返回 None 而不是报错\nprint(scores.get(&#39;D&#39;))\n\n# get 方法当键不存在时可以设置默认值\nprint(scores.get(&#39;D&#39;, 0))\n\n# 删除字典中的元素\nprint(scores.popitem())\nprint(scores.popitem())\nprint(scores.pop(&#39;A&#39;, 6))\n\n# 清空字典\nscores.clear()\nprint(scores)语法结构之前我们所写的代码都是扁平结构的, 接下来我们就要学习 Python 的语法结构了. 不同于 C&#x2F;C++ 等语言靠分号和大括号区分层级结构, Python 采用空格缩进来区分层级结构, 如果不理解, 看下面的例子即可\n条件分支结构类似于数学中的分段函数, Python也可以根据不同的条件执行不同的语句, Python 有两种条件分支结构\nIf-Else 语句通过 if - else 关键字组合, if 后接一个布尔表达式, 通常直接为布尔类型或者由比较运算符参与构成, 如果表达式为真, 则执行 if 之下的内容, 如果表达式为假, 则执行 else 之下的内容. 这非常符合自然语言的直觉, “如果 … 为真, 那么 …, 否则 …”\n例如判断一个数是否是偶数\npya = 4\n\nif a % 2 == 0:\n    print(&quot;a 是偶数&quot;)\nelse:\n    print(&quot;a 是奇数&quot;)有的时候分支不止两条, 这时我们可以连用 else if 关键字, 后接一个布尔表达式, 意味”又如果 … 为真, 那么 …”, 但是这样略有冗长, 且容易让层级显得参差不齐, 所以我们可以把这两个单词合并成 elif, 比如下面的例子\npyscore = 98\n\nif score &gt; 90:\n    print(&quot;优秀!&quot;)\nelif score &gt; 80:\n    print(&quot;良好&quot;)\nelif score &gt; 60:\n    print(&quot;及格&quot;)\nelse:\n    print(&quot;不及格...&quot;)Match-Case 语句对于上面的最后一个例子, 如果分支条件是一些离散变量, 比如字符串, 或者一组固定的数字类型, 或是布尔变量, if-else 语句虽然也可以很好的解决, 但略显冗长. 好在在 Python 3.10 之后引入了一种类似于 Rust 语言中的模式匹配结构: match-case 语句, 下面来简单的看一个例子\npygender = &quot;男&quot;\n\nmatch gender:\n    case &quot;男&quot;:\n        print(&quot;是男孩子&quot;)\n    case &quot;女&quot;:\n        print(&quot;是女孩子&quot;)\n    case &quot;保密&quot;:\n        print(&quot;性别保密哦&quot;)\n    case _: # 通过一个通配符来匹配其他剩下的所有情况, 当然也可以省略, 不像 Rust 那样严格要求穷尽式匹配\n        print(&quot;也许是武装直升机)&quot;)通过这个简单的例子, 就应该能体会到, 离散的分支条件越多, 这种方法的优势就越大\n可以通过在 case 分支后面添加一个 if 语句增加额外的判断, 例如\npygender = &quot;女&quot;\nage = 18\n\nmatch gender:\n    case &quot;女&quot; if age &lt; 20:\n        print(&quot;是青春少女&quot;)case 关键字还可以捕获变量\npygreeting = &quot;Job&quot;\n\nmatch greeting:\n    case &quot;&quot;:\n        print(&quot;Hello!&quot;)\n    case name: # 这里新建了一个 name 变量用于捕获 greeting 这个变量\n        print(f&quot;Hello, {name}!&quot;)这样的 if 条件被称为 卫语句, 字面意思, 保卫条件分支的语句\nmatch-case 语句的其他功能这里就不再赘述, 感兴趣可以自行搜索\n循环结构类似于数学中的迭代, 当需要重复某件事若干次时, 就需要用到循环结构了, 循环结构同样有两种\nWhile 循环while 是最简单的一种循环, 通过后接一个布尔表达式, 很容易从字面上理解其含义, “当 … 为真时, 就 …”\n当然我们很少需要一个无法打破的无限循环, 因此需要在循环体内部加上一些可以帮助跳出循环的条件\npya = 0\n\nwhile a &lt; 10:\n    print(a)\n    a+=1如此一来, 每次循环结束前, 循环条件 a 都会加一, 当 a 等于 10 时, 循环条件不再满足, 循环结束, 继续向下运行其他代码, 那么这段时间里将会打印 0 到 9 这些数字\n当然我们也可以通过一些特殊手段提前跳出循环, 比如 break 关键字, 字面意思, 打破循环\npya = 0\n\nwhile a &lt; 10:\n    if a == 3:\n        break\n    print(a)\n    a+=1如此一来, 当 a 增加到 3 时, 就会触发 if 语句内部的 break, 提前结束循环, 只会打印 0, 1, 2 三个数字\n除此之外, 还有 continue 关键字, 字面意思, 继续循环, 但是不包括关键字下面的部分了, 即一旦遇到这个关键字, 立刻开始新一轮循环\npya = 0\n\nwhile a &lt; 10:\n    if a == 3:\n        a+=1 # 注意给循环条件加一, 以免无限循环\n        continue\n    print(a)\n    a+=1如此一来就会打印 0 到 9 里除了 3 的数字\n值得注意的一点是, 当有 多重嵌套 循环时, break 和 continue 都只影响它们外面紧挨着的那一层循环\nFor-In 迭代器对于遍历一个集合元素, 使用 while 循环当然也能做到, 但是需要我们提前知道集合元素的长度并小心的设定循环条件, 很不方便. 这时就需要专门遍历集合以及范围的 for-in 循环了, 形如 for item in range, 意思是 “从 range 里面取出一个 item 并 …” 并一直循环取遍每一个 item, 并且这个 item 是一个临时变量, 可以在循环体中使用\npycities = [&quot;北京&quot;, &quot;天津&quot;, &quot;上海&quot;]\n\nfor city in cities:\n    print(city)上面我们说到 for 循环还可以遍历一个范围, Python 中提供了一个非常灵活的函数用于生成整数范围: range(), 使用方法形如 range(start, end, step), 非常类似于切片的用法\n\nstart: 范围的起始, 且包括在范围中\nend: 范围的终止, 但不包括在范围中\nstep: 步长, 从起始开始数值递增的值, 默认为 1\n若 start &lt; end, 则表示一个 倒序 范围\n\n下面举几个简单的例子\n\nrange(10): 生成 0 - 10 但不包括 10 的整数范围, 即 0 到 9 十个数字\nrange(1, 10): 生成 1 - 10 但不包括 10 的整数范围\nrange(1, 10, 2): 生成 1 - 10 但不包括 10 的奇数范围\nrange(10, 0, -2): 生成 10 - 0 但不包括 0 的偶数范围\n\n下面是与 for 循环结合的示例\npy# 一个简单的 0 到 100 的求和\nsum = 0\n\nfor i in range(101):\n    sum+=1\nprint(sum)函数\n\n\n\n\n\n\n\n\n“代码有很多种坏味道, 重复是最坏的一种!” — Martin Fowler\n数学中, 如果我们有需要反复往一个冗长的表达式中代入不同的值并计算, 为了让卷面清爽一些, 我们通常会将这个冗长的表达式包装成一个 函数, 在编程中当然也可以这样做\n如果有一组相似且机械的行为, 那我们就可以将其抽象成函数以供调用, 比如阶乘的计算, 即使用循环来写这仍然是一个冗长的过程, 我们就可以定义一个函数, 输入数字, 就返回它的阶乘\n在 Python 中, 我们通过 def 关键字来定义函数, 后面跟上函数的名字, 在后面跟上一个小括号, 里面可选的可以加入若干的函数内部所需的参数, 由于此时参数并没有确切的值, 只是起到参与运算的形式作用, 因此称之为 形参, 多个形参之间可以用逗号隔开\n在函数内部的某个部分, 可选的可以使用 return 关键字返回一个变量作为函数的结果, 如果需要返回多个变量, 可以以元组或列表的形式返回\n类似于 break 和 continue 关键字, 此时函数会立即停止执行\n如果不显式写明的话, 则会默认返回函数最下面的一个变量\npydef fac(num):\n    result = 1\n    for n in range(1, num + 1):\n        result *= n\n    return result\n\n# 这样比如我们计算组合数时就不需要反复计算阶乘了\nm = 5\nn = 3\nprint(fac(m) // fac(n) // fac(m - n))与其它语言不同的是, Python 的函数参数可以有默认值, 使用起来就像变量赋值一样简单\npydef func(n=2):\n    print(n)\n\nfunc() # 输出 2\nfunc(3) # 输出 3Python 的函数还支持可变参数, 只需要在参数前面加上一个 *, 这表示可以传入 0 到任意个参数\npydef sum(*args):\n    total = 0\n    for val in args:\n        total += val\n    return total\n\nprint(sum()) # 输出 0\nprint(sum(1)) # 输出 1\nprint(sum(1, 2)) # 输出 3类类似于其他语言中的 结构体, 类 (Class) 是一种自定义的复合数据类型, 类成员可以包含任何类型的值\n可以通过 class 关键字定义一个类, 并为其实现一些类方法\npyclass Rectangle:\n    class_value = 0\n    # 下面几个是名字内定但须要手动实现的特殊方法\n\n    # 构造方法, 用于初始化一个类, 在创建对象的时候自动调用\n    # 用于创建一个矩形\n    def __init__(self, length, width):\n        self.length = length\n        self.width = width\n\n    # 用于返回对象的字符串表示, 通常用于 print 函数打印输出时\n    def __str__(self):\n        return f&quot;Rectangle&#39;s size is {self.length} * {self.width}&quot;\n\n    # 用于返回对象的调试表示, 通常在控制台输出时调用\n    __repr__ = __str__\n\n    # 下面几个是自定义方法\n\n    # 普通方法, 也叫实例方法, 第一个参数都是 self, 代表对象本身\n    # 用于计算矩形面积\n    def area(self):\n        return self.length * self.width\n\n    # 类方法是绑定到类而不是实例的方法\n    # 可以让类有更多的构造方法, 而无需修改 __init__\n    # 使用装饰器 @classmethod 来定义类方法\n    # 创建一个矩形\n    @classmethod\n    def build_rec(cls, length, width):\n        return cls(length, width)\n\n    # 静态方法不需要访问类或实例的属性\n    # 当一个函数和类本身无关, 但只被该类使用, 为了让代码结构更加有序, 可以将该函数移动到类的定义之下成为一个静态方法, 可以理解为一个纯粹的工具函数\n    # 使用装饰器 @staticmethod 来定义静态方法\n    # 仅仅是计算一下加法, 与类本身无关\n    @staticmethod\n    def just_add(a, b):\n        return a + b\n\nrec = Rectangle(10, 20)\nprint(rec) # 输出 &quot;Rectangle&#39;s size is 10 * 20&quot;\nprint(rec.area()) # 输出 200\nprint(Rectangle.build_rec(10,10))\nprint(Rectangle.just_add(1,2))模块将所有代码都放在同一个文件中是不现实的, 这个时候就需要把代码按一定组织分散到不同文件中, 通过 from-import 关键字, 我们就可以使用这些定义在其他文件的 Python 代码\npy###############\n# a.py\n###############\n\ndef func(){\n    print(&quot;Hello from a.py&quot;)\n}\n\n###############\n# b.py\n###############\n\nimport a # 只导入模块\na.func()\n# 或者\nimport a as my_module # 导入并重命名模块\nmy_module.func()\n# 或者\nfrom a import func # 只导入模块某一方法\nfunc()\n# 或者\nfrom a import * # 代表导入 a.py 中的所有代码\nfunc()\n\n# 运行 b.py 后, 以上几种方式都将打印 &quot;Hello from a.py&quot;很多时候, 我们的模块内部不仅仅有函数, 还有其他可以被直接运行的代码, 那么如果我们在某一文件导入了这个模块并运行该文件, Python 解释器就会执行这些代码, 可是有的时候我们并不希望如此, 我们只希望当该模块被直接执行时才运行这部分代码, 这种时候就可以利用 私有的实例属性, 还记得吗, 我们在 变量 的部分提到过\npy###############\n# nothing.py\n###############\n\ndef foo():\n    pass\n\n\n# __name__是Python中一个隐含的变量它代表了模块的名字\n# 只有被Python解释器直接执行的模块的名字才是__main__\nif __name__ == &#39;__main__&#39;:\n    print(&#39;call foo()&#39;)\n    foo()\n###############\n# test.py\n###############\nimport nothing\n\n# 导入模块时 不会执行模块中 `if` 条件成立时的代码 因为模块的名字是 `nothing` 而不是 `__main__`","slug":"2024-03-06","date":"2024-03-05T16:27:10.000Z","categories_index":"Course","tags_index":"Python","author_index":"芳塔洛斯"},{"id":"02235f1513e7db7d325ab085789e0935","title":"Tauri 2.0 Beta 版创建跨桌面和手机的应用","content":"安装 Tauri Cli这里默认大家已经装好了 Android Studio 及其相关组件\n然后到 Github 发布页面 下载到最新版本的 Tauri Cli, 截止到本文写作时间, 最新版本是 tauri-cli 2.0.0-beta.6, 下载解压后加入环境变量\n创建项目这里我们使用 Pnpm 来创建项目\nshpnpm create tauri-app --beta这将会提示几个问题, 前面按需填写, 最后是否创建安卓应用选择 yes\n修改配置打开 ./src-tauri/tauri.conf.json, 修改其中的 identifier 项\n随后运行\nsh# 初始化样板代码\npnpm tauri android init\n# 在 Android Studio 中打开项目\npnpm tauri android open配置签名文件我们只需要借助 Android Studio 生成签名文件, 在菜单栏 Build -&gt; Generate Signed Bundle/APK 选择创建新的 Key, 其中以下几条是关键信息\n\nKey store path: .jks Key 文件保存路径\nKey store password: Key 文件的密码\nKey Alias: Key 文件中的一个标识符\nKey password: 对应标识符的密码\n\n接下来创建 src-tauri/gen/android/key.properties 文件, 写入以下内容\ntxtstorePassword=&lt;Key store password&gt;\nkeyPassword=&lt;Key password&gt;\nkeyAlias=&lt;Key Alias&gt;\nstoreFile=&lt;Key store path, 注意是绝对路径, 且需要双斜杠&gt;接下来修改 src-tauri/gen/android/app/build.gradle.kts 文件, 下面仅展示了需要增添的内容\nktsimport java.util.Properties\nimport java.io.FileInputStream\n\n...\n\nval keyPropertiesFile = rootProject.file(&quot;key.properties&quot;)\nval keyProperties = Properties()\nkeyProperties.load(FileInputStream(keyPropertiesFile))\n\nandroid {\n    ...\n    defaultConfig {\n        ...\n    }\n    signingConfigs {\n       create(&quot;release&quot;) {\n           keyAlias = keyProperties[&quot;keyAlias&quot;] as String\n           keyPassword = keyProperties[&quot;keyPassword&quot;] as String\n           storeFile = file(keyProperties[&quot;storeFile&quot;] as String)\n           storePassword = keyProperties[&quot;storePassword&quot;] as String\n       }\n    }\n    buildTypes {\n        ...\n        getByName(&quot;release&quot;) {\n            ...\n            signingConfig = signingConfigs.getByName(&quot;release&quot;)\n            proguardFiles(\n                ...\n            )\n        }\n    }\n    ...\n}\n...接下来运行类似以下命令就可以正常编译且签名了\nshpnpm tauri android build --target aarch64","slug":"2024-03-04","date":"2024-03-04T13:44:23.000Z","categories_index":"Note","tags_index":"Rust,Tauri","author_index":"芳塔洛斯"},{"id":"058683a9fd69c6e65647f15e0808060d","title":"编译 Tauri 项目时无法下载 WixTools 或 Nsis 的解决方法","content":"WixTools 和 Nsis 是 Tauri 提供的 Bundle (包装器), 但在国内由于一些网络问题可能会出现无法下载的情况, 有时甚至在能连接到 Github 的情况下仍无法下载, 比如:\ntxtConnection Failed: tls connection init failed: invalid peer certificate: UnknownIssuer`这时可以通过以下步骤手动安装\nWixTools在 这里 下载预编译文件, 然后解压到 C:\\Users\\[User name]\\AppData\\Local\\tauri\\Wixtools, 至于具体需要的版本目前可以在 Tauri 的 源码 中找到\nNsis首先在 这里 下载预编译文件, 然后解压到 C:\\Users\\[User name]\\AppData\\Local\\tauri\\NSIS\n\n\n\n\n\n\n\n注意\nTauri 还依赖两个插件需要我们手动下载, 否则在编译时没有检测到插件会自动删除 Nsis 并尝试重新下载\n\n两个插件需要放置的位置和下载地址如下\nNSIS\\Plugins\\x86-unicode\\ApplicationID.dll\nNSIS\\Plugins\\x86-unicode\\nsis_tauri_utils.dll\n","slug":"2024-01-26","date":"2024-01-26T07:44:43.000Z","categories_index":"Note","tags_index":"Rust,Resolution,Tauri","author_index":"芳塔洛斯"},{"id":"d0c31e3894b3e43582a292091995aba6","title":"记一次国家税务总局查验发票显示网络异常的解决方法","content":"查验发票当然需要安装政府提供的证书, 安装完成后重启浏览器, 打开 税务总局官网, 但是这时我们导入发票后点击验证码仍然会显示网络异常, 此时打开控制台, 其中有多条这样的输出:\ntxtFailed to load resource: net::ERR_CERT_AUTHORITY_INVALID   https://fpcy.zhejiang.chinatax.gov.cn/NWebQuery/yzmQuery?callback=jQuery36103015628054093198_1702294772606&amp;fpdm=233320000000&amp;fphm=45614465&amp;r=0.09776293825096638&amp;v=2.0.16_050&amp;nowtime=1702294786323&amp;publickey=1702294786323&amp;key9=957eca867cc1c2d15d595cf11718a81e&amp;_=1702294772616&amp;flwq39=Mo2tvh7rMqEbltz3Rivax3JzIAMFYklxIOSLRHIT%2FaEEGIk0qzfIOui1LRb9b577795HiuVUJuUzpyrvqB%2Bw97vI7bTC4KohkJSwEsaXzcQEBfOwHyhJ1FOD74uChq9571bRc5GZiRBeL19NKgG%2FFifqPBTX3movmjWrKpJLPCo%3D我们访问这个网址, 浏览器会提醒我们当前网页不安全, 再次点击仍要访问, 访问成功后会输出类似以下内容:\ntxtjQuery36103015628054093198_1702294772606({&quot;key1&quot;:&quot;...&quot;,&quot;key2&quot;:&quot;2023-12-11 19:40:46&quot;,&quot;key3&quot;:&quot;620c53a476a5a4239fa00435624adf97&quot;,&quot;key4&quot;:&quot;00&quot;,&quot;key5&quot;:&quot;2&quot;,&quot;key6&quot;:&quot;3490b6b98b855613018c58adf92f54e9&quot;})这时我们再回到税务总局的网址, 点击验证码就可以正常刷新了\n","slug":"2023-12-11","date":"2023-12-11T12:37:43.000Z","categories_index":"Note","tags_index":"Resolution","author_index":"芳塔洛斯"},{"id":"2b7fe53c83778cdb6bbab88519dc8e10","title":"记一次 Rust 在 Windows 平台交叉编译 Android 时链接器报错的问题","content":"当尝试执行以下命令时\nshcargo build --release --target armv7-linux-androideabi输出了大量链接器错误, 如下\ntxterror: linking with `D:\\Programming\\Tool\\Android_SDK\\ndk\\26.1.10909125\\toolchains/llvm/prebuilt/windows-x86_64\\bin\\armv7a-linux-androideabi24-clang.cmd` failed: exit code: 255\n|\n= note: &quot;D:\\\\Programming\\\\Tool\\\\Android_SDK\\\\ndk\\\\26.1.10909125\\\\toolchains/llvm/prebuilt/windows-x86_64\\\\bin\\\\armv7a-linux-androideabi24-clang.cmd&quot; &quot;-march=armv7-a&quot; &quot;C:\\\\Users\\\\芳塔洛斯\\\\AppData\\\\Local\\\\Temp\\\\rustcXidorx\\\\symbols.o&quot; &quot;D:\\\\Programming\\\\Code\\\\Project\\\\Neno\\\\target\\\\armv7-linux-androideabi\\\\release\\\\deps\\\\neno_desktop-884e689b341ca3ff.neno_desktop.5bad0fe025bc0067-cgu.0.rcgu.o&quot; &quot;D:\\\\Programming\\\\Code\\\\Project\\\\Neno\\\\target\\\\armv7-linux-androideabi\\\\release\\\\deps\\\\neno_desktop-884e689b341ca3ff.160o3gui2v7nyyt0.rcgu.o&quot; &quot;-Wl,--as-needed&quot; &quot;-L&quot; &quot;D:\\\\Programming\\\\Code\\\\Project\\\\Neno\\\\target\\\\armv7-linux-androideabi\\\\release\\\\deps&quot; &quot;-L&quot; &quot;D:\\\\Programming\\\\Code\\\\Project\\\\Neno\\\\target\\\\release\\\\deps&quot; &quot;-L&quot; &quot;D:\\\\Programming\\\\Code\\\\Project\\\\Neno\\\\.cargo&quot; &quot;-L&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib&quot; &quot;-Wl,-Bstatic&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\libstd-8efdef55a48b6ede.rlib&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\libpanic_unwind-07cd329feb7291c7.rlib&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\libobject-6641e98bb52d50cc.rlib&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\libmemchr-2d91048f27d6b338.rlib&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\libaddr2line-084741aa5d6cd941.rlib&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\libgimli-2904fcb616c98a2a.rlib&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\librustc_demangle-1091b1d466e87f02.rlib&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\libstd_detect-babd879f83204512.rlib&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\libhashbrown-62f6523570fc14d7.rlib&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\librustc_std_workspace_alloc-fbf2621eda901e67.rlib&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\libminiz_oxide-5bcb0afe5fbf4dd6.rlib&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\libadler-a660143b5bd942ba.rlib&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\libunwind-943cfbb42cdd8649.rlib&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\libcfg_if-10240302b9880bbc.rlib&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\liblibc-c890c346954c3969.rlib&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\liballoc-4cf58211a4ab8478.rlib&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\librustc_std_workspace_core-203fca2270aba449.rlib&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\libcore-b05626a355470548.rlib&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib\\\\libcompiler_builtins-33cc9a2dc099b4f0.rlib&quot; &quot;-Wl,-Bdynamic&quot; &quot;-ldl&quot; &quot;-llog&quot; &quot;-lunwind&quot; &quot;-ldl&quot; &quot;-lm&quot; &quot;-lc&quot; &quot;-Wl,--eh-frame-hdr&quot; &quot;-Wl,-z,noexecstack&quot; &quot;-L&quot; &quot;D:\\\\Programming\\\\Lang\\\\Rust\\\\rustup\\\\toolchains\\\\nightly-x86_64-pc-windows-msvc\\\\lib\\\\rustlib\\\\armv7-linux-androideabi\\\\lib&quot; &quot;-o&quot; &quot;D:\\\\Programming\\\\Code\\\\Project\\\\Neno\\\\target\\\\armv7-linux-androideabi\\\\release\\\\deps\\\\neno_desktop-884e689b341ca3ff&quot; &quot;-Wl,--gc-sections&quot; &quot;-pie&quot; &quot;-Wl,-z,relro,-z,now&quot; &quot;-Wl,-O1&quot; &quot;-nodefaultlibs&quot; &quot;-landroid&quot; &quot;-llog&quot; &quot;-lOpenSLES&quot;\n= note: Non-UTF-8 output: \\xb4\\xcb\\xca\\xb1\\xb2\\xbb\\xd3\\xa6\\xd3\\xd0 =armv7-a\\&quot;\\&quot;\\xa1\\xa3\\r\\n\n\nerror: could not compile `neno` (bin &quot;neno-desktop&quot;) due to previous error目前暂时的解决办法是找到对应的链接器, 比如这里是 armv7a-linux-androideabi24-clang.cmd\nBug 出现的位置是 if &quot;%1&quot; == &quot;-cc1&quot; goto :L, 将这一行替换为 if &quot;%~1&quot; == &quot;-cc1&quot; goto :L 即可\nBug 出现的原因是 Rust 编译器传递的用于替换 %1 的参数 -march=armv7-a 以 &quot;-march=armv7-a&quot; 的形式传入, 原来的代码在传参后变成了 if &quot;&quot;-march=armv7-a&quot;&quot; == &quot;-cc1&quot; goto :L, 导致逻辑混乱\n这可能代表链接器无法接受一些特殊字符, 如 % 、 、 、 ! ^ &quot;\n而 %~1 参数可以删除周围的 &quot; ,然后可以安全地解析它. 虽然不确定这是否可以作用于其他特殊字符\n该 Bug 在 Github上也有提及\n\nWhen cross compiling Rust to Android on Windows, Rust 1.69.0+ can’t find the version script path. #113711\n[BUG] clang.cmd doesn’t work well with -march&#x3D;armv7-a #1856\n\n","slug":"2023-11-07","date":"2023-11-07T12:37:43.000Z","categories_index":"Note","tags_index":"Rust,Android,Resolution","author_index":"芳塔洛斯"},{"id":"6fd3072f35c36cdb6dca04682272855c","title":"基于 Hexo + Aurora + GitTalk 的博客项目, 并通过 Github Action 持续集成","content":"创建项目官方的教程 写的很清楚, 这里简单概括一下\n建议使用 Yarn 或 Pnpm, 这里我采用 Pnpm 作为演示\n首先安装全局 Hexo Cli 工具\nshpnpm i -g hexo-cli然后初始化一个 Hexo 项目\nshhexo init [ProjectName]接下来进入项目文件夹内, 安装相关依赖并安装 Aurora 主题\nshpnpm i\npnpm i hexo-theme-aurora hexo-plugin-aurora --save配置项目打开 Hexo 配置文件 _config.yml, 找到以下几项并修改\nymlurl: [BlogUrl]\npermalink: /post/:title.html\n...\n# Aurora 使用 shiki 引擎进行代码高亮, 因此关闭以下两个\nhighlight:\n    enable: false\nprismjs:\n    enable: false\n...\n# 主题选择\ntheme: aurora接下来在项目根目录创建一个名为 _config.aurora.yml 的文件作为主题配置, 下面给出一个配置示例\nymlsite:\n    subtitle: 芳塔洛斯\n    author: 芳塔洛斯\n    nick: Fontlos\n    description: description\n    link: &quot;/&quot;\n    language: zh-CN\n    multi_language: true\n    logo: https://fontlos.com/icons/logo.png\n    avatar: https://fontlos.com/icons/avatar.jpg\n    started_date: 2021-02-14\n    # 路径标识符\n    # uid: 使用唯一 ID\n    # slug: 生成基于标题的路径\n    pathSlug: &quot;slug&quot;\n\nauthors:\n    Fontlos:\n        name: Fontlos\n        avatar: https://fontlos.com/icons/avatar.jpg\n        link: https://github.com/fontlos\n        description: Debug the world.\n        socials:\n        github: https://github.com/fontlos\n\nmenu:\n    About: true\n    Tags: true\n    Archives: true\n    Links: true\n    Contact:\n        name: &quot;Contact&quot;\n        i18n:\n            en: Contact Me\n            zh-CN: 联系\n        path: &quot;mailto:fontlos@fontlos.com&quot;\n\ntheme:\n    dark_mode: &quot;auto&quot;\n    profile_shape: diamond # 支持 `circle`, `diamond`, `rounded`\n    feature: true\n    gradient:\n        color_1: &quot;#24c6dc&quot;\n        color_2: &quot;#5433ff&quot;\n        color_3: &quot;#ff0099&quot;\n\nsocials:\n    github: https://github.com/fontlos\n    customs:\n        bilibili:\n            icon: https://fontlos.com/icons/bilibili.svg\n            link: https://space.bilibili.com/362772872\n\nsite_meta:\n    cdn: cn\n    favicon:\n    description: &quot;Debug everything.&quot;\n    keywords: &quot;Programming, Web, Frontend, Backend ,Rust, Blog, Aurora, Fontlos, 芳塔洛斯&quot;\n    author: &quot;Fontlos&quot;\n\ncopy_protection:\n    enable: true\n    author:\n        cn: 作者 芳塔洛斯\n        en: Author Fontlos\n    link:\n        cn: 本文来自于 https://fontlos.com\n        en: Article is from https://fontlos.com\n    license:\n        cn: 博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议\n        en: This content is shared under the CC BY-NC-SA 4.0 protocol (Non-Commercial)\n\nfooter_links:\n    -   title: #总标题\n        links:\n            -   title: Friends\n                mode: &#39;links&#39;\n\nshiki:\n    enable: true\n    theme: one-dark-pro\n    backgroundColor: &quot;#1a1a1a&quot;创建一个 About 页面主题默认开启了 About 页面, 我们需要手动创建一下, 否则无法正常显示\nshhexo new page about这样 ./source 文件夹下就会多出一个 ./about/index.md 文件, 这个文件的内容将会显示在 About 页面上\n搜索引擎收录配置博客默认情况下是 无法被搜索引擎收录 的, 因此我们需要向搜索引擎提交我们的博客结构, 方法有以下几种\n\n自动提交\n主动推送: 通过搜索引擎相关 API 直接推送博客内容的链接\n优点: 快, 几分钟即可生效\n缺点: 提交量低, 可能需要自主申请搜索引擎的 API 接口\n\n\nSiteMap 推送: 生成一个描述博客结构的 sitemap.xml 文件让搜索引擎爬虫读取\n优点: 提交量大, 操作方便\n缺点: 需要等待搜索引擎爬虫主动读取, 时间较长\n\n\n自动推送: 通过在前端嵌入相关 JS 代码, 让博客内容在被访问的时候向搜索引擎主动推送\n\n\n手动提交: 纯手动向搜索引擎提交自己博客的链接\n\n建议上同时采用 主动推送 和 SiteMap 推送\n这里仅以配置 SiteMap 推送为例, 分别安装下面两个插件\nsh# 用于大多数搜索引擎\npnpm i hexo-generator-sitemap --save\n# 针对百度\npnpm i hexo-generator-baidu-sitemap --save别忘了 配置项目 时要设置博客的 URL, 配置完成后在接下来的 部署项目 中就会自动生成 sitemap.xml 文件而无需手动操作了\n部署配置配置完成后, 首先要确保我们的项目在本地是可以是可以正常编译的\nshhexo cl &amp; hexo g &amp; hexo server添加一个 Delpoyer 插件\nshpnpm i hexo-deployer-git然后在 _config.yml 配置 Hexo 的 deloy 参数\nymldeploy:\n    type: &quot;git&quot;\n    repository: &lt;repository url&gt; # 为了免密拉取, 我们使用 SSH, 比如 git@github.com:fontlos/blog.git\n    # 注意默认参数是 master, 不要让部署的文件覆盖了你的源码\n    branch: gh-pages部署项目你可以直接将生成的 public 文件夹推送到 Github, 但这里我选择推送源码, 并使用 Github Action 自动构建部署. 将源码推送到 Github 并自动部署有很多好处, 比如不用每次都 git push 那么多文件了, 毕竟每一次生成都会有大量文件发生改变的\n生成密钥对安装 ssh-keygen, 在命令行运行, 一路回车即可\n会得到两个文件, id_rsa 私钥 和 id_rsa.pub 公钥\nGithub 配置配置私钥新建一个 Repository 用于储存我们的源码. 打开 Settings -&gt; Secrets -&gt; Secrets and variables -&gt; Actions, 点击 New repository secret, 在 Name 框中给密钥起一个名字, 比如我这里用 HEXO_DEPLOY_KEY, 然后把 id_rsa 私钥的内容复制到下面的 Secret 框中, 点击 Add secret 保存\n配置公钥打开 Settings -&gt; Deploy keys, 点击右上角 Add deploy key, 同样的操作, 起个名字, 我这里用 HEXO_DEPLOY_PUB, 把 id_rsa.pub 公钥 复制进去, 然后勾选 Allow write access, 保存\n新建 .github/workflows 文件夹, 并在其中新建一个 yml 工作流文件, 名称随意\nymlname: Deploy\non:\n    push:\n        branches:\n            - main\njobs:\n    build:\n        runs-on: ubuntu-latest\n        if: github.event.repository.owner.id == github.event.sender.id\n        steps:\n            - name: Checkout source\n                uses: actions/checkout@v2\n                with:\n                    ref: main\n            - name: Setup Node.js\n                uses: actions/setup-node@v4\n                with:\n                    node-version: &#39;20&#39;\n            - name: Setup Pnpm\n                uses: pnpm/action-setup@v2\n                with:\n                    version: &#39;8&#39;\n            - name: Setup Hexo\n                env:\n                    ACTION_DEPLOY_KEY: ${{ secrets.HEXO_DEPLOY_KEY }}\n                run: |\n                    mkdir -p ~/.ssh/\n                    echo &quot;$ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa\n                    chmod 700 ~/.ssh\n                    chmod 600 ~/.ssh/id_rsa\n                    ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts\n                    git config --global user.email &quot;fontlos@fontlos.com&quot;\n                    git config --global user.name &quot;Fontlos&quot;\n                    pnpm install hexo-cli -g\n                    pnpm install\n            - name: Deploy\n                run: |\n                    hexo clean\n                    hexo deploy这段的意思是, 当源码推送到 main 分支时, 执行 job. 在 Ubuntu 中 checkout 源码, 然后引入 NodeJS 工具, 创建 SSH 相关文件, 配置 git config, 注意这里替换成自己的邮箱和用户名, 然后我选择了使用 Pnpm 安装 Hexo Cli 和其他依赖, 用其他的也可以, 不要忘了把 lock 文件一同上传. 最后执行部署\n最后, 上传源码, 部署开始\n使用 GitTalk 制作评论系统首先确保 Settings -&gt; General -&gt; Features -&gt; Issues 特性开启\n注册一个 OAuth applications\n\nApplication name: 随便取一个名字\nHomepage URL: Github Page 默认地址, .github.io 的那个\nAuthorization callback URL: Github 权限验证的回调地址, 没有自定义域名就同上, 有就填自己的域名\n\n注册成功后, 记录下 Client ID 和 Client Secret\n比如对于我使用的主题\nymlgitalk:\n    enable: true\n    autoExpand: true\n    clientID: &#39;&#39; # 这两个就是刚才复制的\n    clientSecret: &#39;&#39;\n    repo: &#39;blog&#39; # Github 对应的仓库名字, 注意是仓库的名字!\n    owner: &#39;fontlos&#39; # owner name\n    admin: [&#39;fontlos&#39;] # [&#39;admin name&#39;]\n    id: uid\n    language: zh-CN\n    distractionFreeMode: true # 无干扰模式\n    recentComment: true\n    proxy: &#39;&#39;","slug":"2023-08-30","date":"2023-08-30T02:33:17.000Z","categories_index":"Note","tags_index":"Frontend,Hexo,Web","author_index":"芳塔洛斯"},{"id":"29b1341e2b77e066dddc7ec9ddd945fe","title":"基于Bevy的扫雷游戏(2)","content":"\n\n\n\n\n\n\n注意\n文章重写中\n\nBoard Options下面我们来添加一个 board_options 模块, 现在我们的文件树类似于下面这样\ntxt│  lib.rs\n│  main.rs\n│\n├─components\n│      coordinates.rs\n│      mod.rs\n│\n└─resources\n        board_options.rs\n        mod.rs\n        tile.rs\n        tile_map.rs在 mod 文件中添加如下内容\nrust// src/resources/mod.rs\n\nmod board_options;\npub use board_options::*;在 board_options 文件中写入以下内容\nrust// src/resources/board_options.rs\n\nuse bevy::prelude::Vec3;\nuse serde::{Deserialize, Serialize};\n\n/// 格子大小设置\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum TileSize {\n    /// 固定大小格子\n    Fixed(f32),\n    /// 窗口响应式格子\n    Adaptive { min: f32, max: f32 },\n}\n\n/// 计分板位置设置\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum BoardPosition {\n    /// 居中\n    Centered { offset: Vec3 },\n    /// 自定义位置\n    Custom(Vec3),\n}\n\n/// 计分板生成选项 必须作为resource使用\n// 通过序列化保存和加载选项\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BoardOptions {\n    /// 地图大小\n    pub map_size: (u16, u16),\n    /// 地雷数量\n    pub bomb_count: u16,\n    /// 计分板位置\n    pub position: BoardPosition,\n    /// 格子大小\n    pub tile_size: TileSize,\n    /// 格子间距\n    pub tile_padding: f32,\n    /// 是否启用点开的第一个格子必然是安全格子\n    pub safe_start: bool,\n}下面为这些结构提供一些默认值\nrust// src/resources/board_options.rs\n\n/// 格子大小默认值\nimpl Default for TileSize {\n    fn default() -&gt; Self {\n        Self::Adaptive {\n            min: 10.0,\n            max: 50.0,\n        }\n    }\n}\n\n/// 计分板位置默认值\nimpl Default for BoardPosition {\n    fn default() -&gt; Self {\n        Self::Centered {\n            offset: Default::default(),\n        }\n    }\n}\n\n/// 计分板选项默认值\nimpl Default for BoardOptions {\n    fn default() -&gt; Self {\n        Self {\n            map_size: (15, 15),\n            bomb_count: 30,\n            position: Default::default(),\n            tile_size: Default::default(),\n            tile_padding: 0.,\n            safe_start: false,\n        }\n    }\n}下面把这些资源注册到我们的主程序中\nrust// src/main.rs\n\n// 新添加\nuse minesweeper::resources::BoardOptions;\n// ..\n\n// 此时的main函数\nfn main() {\n    let mut app = App::new();\n    app.insert_resource(WindowDescriptor {\n        title: &quot;Mine Sweeper&quot;.to_string(),\n        width: 700.,\n        height: 800.,\n        ..Default::default()\n    })\n    .add_plugins(DefaultPlugins);\n    #[cfg(feature = &quot;debug&quot;)]\n    app.add_plugin(WorldInspectorPlugin::new());\n    // 新加入内容 添加面板选项\n    app.insert_resource(BoardOptions{\n        map_size:(20,20),\n        bomb_count:40,\n        tile_padding:3.0,\n        ..Default::default()\n    });\n    app.add_plugin(BoardPlugin);\n    app.add_startup_system(camera_setup);\n    app.run();\n}生成面板还记得 lib 文件中 BoardPlugin 上的 create_board 方法吗, 现在让我们修改一下它的函数签名\nrust// src/lib.rs\n\nuse resources::BoardOptions;\n\n// ..\npub fn create_board(\n    mut commands: Commands,\n    board_options: Option&lt;Res&lt;BoardOptions&gt;&gt;,\n    window: Res&lt;WindowDescriptor&gt;,\n    ) {..}为上述函数添加以下内容\nrust        // 生成选项是可选的, 因此如果未设置可以选择直接返回默认值\n          let options = match board_options {\n            None =&gt; BoardOptions::default(),\n            Some(o) =&gt; o.clone(),\n        };\n\n        // 地图生成\n        let mut tile_map = TileMap::empty(options.map_size.0, options.map_size.1);\n        tile_map.set_bombs(options.bomb_count);\n        #[cfg(feature = &quot;debug&quot;)]\n        // 地图调试选项\n        log::info!(&quot;{}&quot;, tile_map.console_output());地砖大小地砖的大小不能是一成不变的, 所以我们需要一个计算地砖大小与地图大小关系的方法. 将如下内容添加到 BoardPlugin 的方法中\nrust    /// 根据地图大小计算格子大小, 自适应属性\n    fn adaptative_tile_size(\n        window: Res&lt;WindowDescriptor&gt;,\n        (min, max): (f32, f32),      // Tile size constraints\n        (width, height): (u16, u16), // Tile map dimensions\n    ) -&gt; f32 {\n        let max_width = window.width / width as f32;\n        let max_heigth = window.height / height as f32;\n        max_width.min(max_heigth).clamp(min, max)\n    }接下来我们在 create_board 方法中调用此功能\nrust// 定义格子大小\n        let tile_size = match options.tile_size {\n            TileSize::Fixed(v) =&gt; v,\n            TileSize::Adaptive { min, max } =&gt; Self::adaptative_tile_size(\n                window,\n                (min, max),\n                (tile_map.width(), tile_map.height()),\n            ),\n        };面板属性接下来我们在 create_board 方法中添加如下内容\nrust        // 计算完整面板大小\n        let board_size = Vec2::new(\n            tile_map.width() as f32 * tile_size,\n            tile_map.height() as f32 * tile_size,\n        );\n        log::info!(&quot;board size: {}&quot;, board_size);\n        // 面板板锚点位置（左下）\n        let board_position = match options.position {\n            BoardPosition::Centered { offset } =&gt; {\n                Vec3::new(-(board_size.x / 2.), -(board_size.y / 2.), 0.) + offset\n            }\n            BoardPosition::Custom(p) =&gt; p,\n        };\n\n\n\n\n\n\n\n\n注意：这里选择将面板锚定在左下角而不是中心, 相当于坐标原点位于左下角, 这样所有地砖的坐标相对就都是正数了\n接下来就可以生成面板了\n继续加入以下内容\nrust// 生成面板\ncommands\n    .spawn()\n    .insert(Name::new(&quot;Board&quot;))\n    .insert(Transform::from_translation(board_position))\n    .insert(GlobalTransform::default())这里添加名字是为了后期调试用的, 这个名字将会被用于这个刚开始提到的社区调试插件中下面我们添加背景, 用一些白色线条将地图切割成一个一个的小格子\nrust// ..\n\n.with_children(|parent| {\n    // 以计分板中间为锚点生成计分板背景\n    parent\n        .spawn_bundle(SpriteBundle {\n            sprite: Sprite {\n                color: Color::WHITE,\n                custom_size: Some(board_size),\n                ..Default::default()\n            },\n            transform: Transform::from_xyz(board_size.x / 2., board_size.y / 2., 0.),\n            ..Default::default()\n        })\n        .insert(Name::new(&quot;Background&quot;));\n})下面我们为每一个格子创建一个实体, 名字属性同样是用于后期调试的\nrust// ..\n\n.with_children(|parent| {\n    // 格子\n    for (y, line) in tile_map.iter().enumerate() {\n                for (x, tile) in line.iter().enumerate() {\n                    parent\n                        .spawn_bundle(SpriteBundle {\n                            sprite: Sprite {\n                                color: Color::GRAY,\n                                custom_size: Some(Vec2::splat(\n                                    tile_size - options.tile_padding as f32,\n                                )),\n                                ..Default::default()\n                            },\n                            transform: Transform::from_xyz(\n                                (x as f32 * tile_size) + (tile_size / 2.),\n                                (y as f32 * tile_size) + (tile_size / 2.),\n                                1.,\n                            ),\n                            ..Default::default()\n                        })\n                        .insert(Name::new(format!(&quot;Tile ({}, {})&quot;, x, y)))\n                        // 添加坐标组件到格子实体\n                        .insert(Coordinates {\n                            x: x as u16,\n                            y: y as u16,\n                        });\n                }\n            }\n});这次给 lib 文件添加了好多内容, 在此给出 lib 文件现在全部内容\nrust// src/lib.rs\n\npub mod components;\npub mod resources;\n\nuse bevy::log;\nuse bevy::prelude::*;\n\nuse resources::tile_map::TileMap;\nuse resources::BoardOptions;\nuse resources::BoardPosition;\nuse resources::TileSize;\n\nuse components::Coordinates;\n\n/// 面板插件\npub struct BoardPlugin;\n\nimpl Plugin for BoardPlugin {\n    fn build(&amp;self, app: &amp;mut App) {\n        app.add_startup_system(Self::create_board);\n        log::info!(&quot;Loaded Board Plugin&quot;);\n    }\n}\n\nimpl BoardPlugin {\n    /// 生成面板\n    pub fn create_board(\n        mut commands: Commands,\n        board_options: Option&lt;Res&lt;BoardOptions&gt;&gt;,\n        window: Res&lt;WindowDescriptor&gt;,\n    ) {\n        let mut tile_map = TileMap::empty(20, 20);\n        tile_map.set_bombs(40);\n        #[cfg(feature = &quot;debug&quot;)]\n        log::info!(&quot;{}&quot;, tile_map.console_output());\n\n        // 生成选项是可选的, 因此如果未设置可以选择直接返回默认值\n        let options = match board_options {\n            None =&gt; BoardOptions::default(),\n            Some(o) =&gt; o.clone(),\n        };\n\n        // 地图生成\n        let mut tile_map = TileMap::empty(options.map_size.0, options.map_size.1);\n        tile_map.set_bombs(options.bomb_count);\n        #[cfg(feature = &quot;debug&quot;)]\n        // 地图调试选项\n        log::info!(&quot;{}&quot;, tile_map.console_output());\n\n        // 定义格子大小\n        let tile_size = match options.tile_size {\n            TileSize::Fixed(v) =&gt; v,\n            TileSize::Adaptive { min, max } =&gt; Self::adaptative_tile_size(\n                window,\n                (min, max),\n                (tile_map.width(), tile_map.height()),\n            ),\n        };\n\n        // 计算完整面板大小\n        let board_size = Vec2::new(\n            tile_map.width() as f32 * tile_size,\n            tile_map.height() as f32 * tile_size,\n        );\n        log::info!(&quot;board size: {}&quot;, board_size);\n        // 面板板锚点位置（左下）\n        let board_position = match options.position {\n            BoardPosition::Centered { offset } =&gt; {\n                Vec3::new(-(board_size.x / 2.), -(board_size.y / 2.), 0.) + offset\n            }\n            BoardPosition::Custom(p) =&gt; p,\n        };\n\n        // 生成面板\n        commands\n            .spawn()\n            .insert(Name::new(&quot;Board&quot;))\n            .insert(Transform::from_translation(board_position))\n            .insert(GlobalTransform::default())\n\n            .with_children(|parent| {\n                // 以计分板中间为锚点生成计分板背景\n                parent\n                    .spawn_bundle(SpriteBundle {\n                        sprite: Sprite {\n                            color: Color::WHITE,\n                            custom_size: Some(board_size),\n                            ..Default::default()\n                        },\n                        transform: Transform::from_xyz(board_size.x / 2., board_size.y / 2., 0.),\n                        ..Default::default()\n                    })\n                    .insert(Name::new(&quot;Background&quot;));\n            })\n\n            .with_children(|parent| {\n                // 格子\n                for (y, line) in tile_map.iter().enumerate() {\n                            for (x, tile) in line.iter().enumerate() {\n                                parent\n                                    .spawn_bundle(SpriteBundle {\n                                        sprite: Sprite {\n                                            color: Color::GRAY,\n                                            custom_size: Some(Vec2::splat(\n                                                tile_size - options.tile_padding as f32,\n                                            )),\n                                            ..Default::default()\n                                        },\n                                        transform: Transform::from_xyz(\n                                            (x as f32 * tile_size) + (tile_size / 2.),\n                                            (y as f32 * tile_size) + (tile_size / 2.),\n                                            1.,\n                                        ),\n                                        ..Default::default()\n                                    })\n                                    .insert(Name::new(format!(&quot;Tile ({}, {})&quot;, x, y)))\n                                    // 添加坐标组件到格子实体\n                                    .insert(Coordinates {\n                                        x: x as u16,\n                                        y: y as u16,\n                                    });\n                            }\n                        }\n            });\n\n    }\n\n    /// 根据地图大小计算格子大小, 自适应属性\n    fn adaptative_tile_size(\n        window: Res&lt;WindowDescriptor&gt;,\n        (min, max): (f32, f32),      // Tile size constraints\n        (width, height): (u16, u16), // Tile map dimensions\n    ) -&gt; f32 {\n        let max_width = window.width / width as f32;\n        let max_heigth = window.height / height as f32;\n        max_width.min(max_heigth).clamp(min, max)\n    }\n}接下来运行 cargo run --features debug , 将会看到类似于这样的窗口\n调试窗口可以更改许多游戏数据\n地砖生成资源文件首先在根目录创建一个 assets 文件夹, Bevy 默认从此文件夹中寻找资源, 所以编译完成后, 也需要复制一份到二进制文件同级目录中, 我们需要地雷的贴图, 旗帜的贴图, 和一个你喜欢的字体文件\n接下来让我们再次修改 create_board 方法的签名\nrustpub fn create_board(\n    mut commands: Commands,\n    board_options: Option&lt;Res&lt;BoardOptions&gt;&gt;,\n    window: Res&lt;WindowDescriptor&gt;,\n    asset_server: Res&lt;AssetServer&gt;, // 新添加, 允许我们从 assets 文件夹中加载资源\n) {\n    // ...\n}\n接下来添加这两行内容\nrust// src/lib.rs\n// ..\n    let font = asset_server.load(&quot;font.ttf&quot;);//将会加载 assets/font.ttf 文件\n    let bomb_image = asset_server.load(&quot;img/bomb.png&quot;);\n// ..地砖组件声明为了让 ECS 知道哪些地砖是空的, 哪些有地雷, 我们需要如下组件\nrust// src/components/mod.rs\n\nmod bomb;\nmod bomb_neighbor;\nmod uncover;\n\npub use bomb::Bomb;\npub use bomb_neighbor::BombNeighbor;\npub use uncover::Uncover;其中每个文件的内容如下\nrust// src/components/bomb.rs\nuse bevy::prelude::Component;\n\n/// 地雷组件\n#[cfg_attr(feature = &quot;debug&quot;, derive(bevy_inspector_egui::Inspectable))]\n#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Component)]\npub struct Bomb;rust// src/components/bomb_neighbor.rs\n\nuse bevy::prelude::Component;\n\n/// 周围地雷组件\n#[cfg_attr(feature = &quot;debug&quot;, derive(bevy_inspector_egui::Inspectable))]\n#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Component)]\npub struct BombNeighbor {\n    /// 周围地雷数量\n    pub count: u8,\n}下面这个暂时用不到\nrust// src/components/uncover.rs\n\nuse bevy::prelude::Component;\n\n/// 未开启的地砖组件\n#[cfg_attr(feature = &quot;debug&quot;, derive(bevy_inspector_egui::Inspectable))]\n#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Component)]\npub struct Uncover;接下来把这些组件注册到我们的插件中\nrust// src/lib.rs\n#[cfg(feature = &quot;debug&quot;)]\nuse bevy_inspector_egui::RegisterInspectable;// 新添加\nuse components::*;//更改成全部引入\n\nimpl Plugin for BoardPlugin {\n    fn build(&amp;self, app: &amp;mut App) {\n        // ..\n        #[cfg(feature = &quot;debug&quot;)]// 新添加\n        {\n            // 将自定义组件注册到调试窗口\n            app.register_inspectable::&lt;Coordinates&gt;();\n            app.register_inspectable::&lt;BombNeighbor&gt;();\n            app.register_inspectable::&lt;Bomb&gt;();\n            app.register_inspectable::&lt;Uncover&gt;();\n        }\n    }\n}接下来为 BoardPlugin 创建一个生成 周围生成地雷数量 的方法\nrust// src/lib.rs\n\n/// 周围生成地雷数\nfn bomb_count_text_bundle(count: u8, font: Handle&lt;Font&gt;, size: f32) -&gt; Text2dBundle {\n    // We retrieve the text and the correct color\n    let (text, color) = (\n        count.to_string(),\n        match count {\n            1 =&gt; Color::WHITE,\n            2 =&gt; Color::GREEN,\n            3 =&gt; Color::YELLOW,\n            4 =&gt; Color::ORANGE,\n            _ =&gt; Color::PURPLE,\n        },\n    );\n    // 生成一段文本\n    Text2dBundle {\n        text: Text {\n            sections: vec![TextSection {\n                value: text,\n                style: TextStyle {\n                    color,\n                    font,\n                    font_size: size,\n                },\n            }],\n            alignment: TextAlignment {\n                vertical: VerticalAlign::Center,\n                horizontal: HorizontalAlign::Center,\n            },\n        },\n        transform: Transform::from_xyz(0., 0., 1.),\n        ..Default::default()\n    }\n}再为 BoardPlugin 创建一个生成生成地砖贴图的方法\nrust// src/lib.rs\n\nfn spawn_tiles(\n    parent: &amp;mut ChildBuilder,\n    tile_map: &amp;TileMap,\n    size: f32,\n    padding: f32,\n    color: Color,\n    bomb_image: Handle&lt;Image&gt;,\n    font: Handle&lt;Font&gt;,\n) {\n    // 地砖\n    for (y, line) in tile_map.iter().enumerate() {\n        for (x, tile) in line.iter().enumerate() {\n            let coordinates = Coordinates {\n              x: x as u16,\n              y: y as u16,\n            };\n            let mut cmd = parent.spawn();\n            cmd.insert_bundle(SpriteBundle {\n                sprite: Sprite {\n                    color,\n                    custom_size: Some(Vec2::splat(size - padding)),\n                    ..Default::default()\n                },\n                transform: Transform::from_xyz(\n                    (x as f32 * size) + (size / 2.),\n                    (y as f32 * size) + (size / 2.),\n                    1.,\n                ),\n                ..Default::default()\n            })\n            .insert(Name::new(format!(&quot;Tile ({}, {})&quot;, x, y)))\n            .insert(coordinates);\n        }\n    }\n}接着我们可以调用该方法生成地砖, 在create_board方法中, 大概在下面这个位置上\nrust// src/lib\n\ncommands\n    .spawn()\n    .insert(Name::new(&quot;Board&quot;))\n    .insert(Transform::from_translation(board_position))\n    .insert(GlobalTransform::default())\n    .with_children(|parent| {\n        parent\n            .spawn_bundle(SpriteBundle {\n                sprite: Sprite {\n                    color: Color::WHITE,\n                    custom_size: Some(board_size),\n                    ..Default::default()\n                },\n                transform: Transform::from_xyz(board_size.x / 2., board_size.y / 2., 0.),\n                ..Default::default()\n            })\n            .insert(Name::new(&quot;Background&quot;));\n            Self::spawn_tiles(//新添加\n                parent,\n                &amp;tile_map,\n                tile_size,\n                options.tile_padding,\n                Color::GRAY,\n                bomb_image,\n                font,\n            );\n    });最后, 完成上面那个生成贴图, 在双循环中加入贴图与文本\nrust// src/lib.rs\n\nuse resources::tile::Tile;\n\n// ..\nmatch tile {// 放入spawn_tiles方法内层for循环下部\n    // 如果是地雷就添加对应组件和贴图\n    Tile::Bomb =&gt; {\n        cmd.insert(Bomb);\n        cmd.with_children(|parent| {\n            parent.spawn_bundle(SpriteBundle {\n                sprite: Sprite {\n                    custom_size: Some(Vec2::splat(size - padding)),\n                    ..Default::default()\n                },\n                transform: Transform::from_xyz(0., 0., 1.),\n                texture: bomb_image.clone(),\n                ..Default::default()\n            });\n        });\n    }\n    // 如果是地雷周围的格子及空格子就添加对应文本的组件\n    Tile::BombNeighbor(v) =&gt; {\n        cmd.insert(BombNeighbor { count: *v });\n        cmd.with_children(|parent| {\n            parent.spawn_bundle(Self::bomb_count_text_bundle(\n                *v,\n                font.clone(),\n                size - padding,\n            ));\n        });\n    }\n    Tile::Empty =&gt; (),\n}\n// ..接下来运行 cargo run --features debug, 将会看到类似于这样的窗口\n","slug":"2022-03-27","date":"2022-03-27T06:02:47.000Z","categories_index":"Course","tags_index":"Bevy,Rust","author_index":"芳塔洛斯"},{"id":"649086876175b6262b284227d70ea0a8","title":"基于Bevy的扫雷游戏(1)","content":"\n\n\n\n\n\n\n注意\n文章重写中\n\n介绍Bevy 是一个免费开源的游戏引擎, 用 Rust 编写, 采用 ECS 范式, 接下来让我们基于 Bevy 实现一个扫雷游戏\n准备首先新建一个 Crate\nshcargo new minesweeper我习惯将 Lib Crate 与 Bin Crate 放在同一个 Project 里, 所以我们在 src 下新建一个 lib.rs 文件, 现在的文件目录大概是这样:\ntxt├── src\n│   ├── main.rs\n│ \t└── lib.rs\n├── Cargo.toml接下来添加一下需要用到的 Crate将以下内容添加到 Cargo.toml 中\ntoml[features]\ndefault = []\n# 用于调试的feature\ndebug = [&quot;colored&quot;, &quot;bevy-inspector-egui&quot;]\n\n[dependencies]\n# bevy引擎本体\nbevy = &quot;0.6.1&quot;\n# 用于序列化数据\nserde = &quot;1.0&quot;\n# 生成随机数\nrand = &quot;0.8&quot;\n# 控制台调试, 可彩色输出\ncolored = { version = &quot;2.0&quot;, optional = true }\n# 这是bevy社区的一个用于在游戏内调试数据的插件\nbevy-inspector-egui = { version = &quot;0.8&quot;, optional = true }编写基本结构首先我们在 lib.rs 里创建一个 Bevy 的 Plugin, 也就是一个结构体\nrust// src/lib.rs\n\n/// 游戏面板插件\npub struct BoardPlugin;接着我们在 main.rs 中添加如下内容\nrust// src/main.rs\n\nuse bevy::prelude::*;\n\nfn main() {\n    let mut app = App::new();\n    // 窗口基本设定\n    app.insert_resource(WindowDescriptor {\n        title: &quot;Mine Sweeper&quot;.to_string(),\n        width: 700.,\n        height: 800.,\n        ..Default::default()\n    })\n    // 添加bevy的默认插件\n    .add_plugins(DefaultPlugins);\n    #[cfg(feature = &quot;debug&quot;)]\n    // 仅在debug feature下添加调试器\n    app.add_plugin(WorldInspectorPlugin::new());\n    // 添加启动system, 用于初始化相机\n    app.add_startup_system(camera_setup);\n    // Run\n    app.run();\n}\n\nfn camera_setup(mut commands: Commands) {\n    // 新建一个 2D 正交相机\n    commands.spawn_bundle(OrthographicCameraBundle::new_2d());\n}\n执行 cargo run 将会得到一个空窗口\n执行 cargo run --feature debug 会多一个游戏数据调试框, 类似于下面这样\n\n\n至此, 一个基本框架算是搭建完成了\n制作雷区网格在 lib.rs 内添加如下内容\nrustmod components;\npub mod resources;坐标组件新建以下文件\nrust// src/components/mod.rs\n\nmod coordinates\npub use coordinates::Coordinates;rust// src/components/coordinates.rs\n\nuse std::fmt::{self, Display, Formatter};\nuse std::ops::{Add, Sub};\nuse bevy::prelude::Component;\n\n#[cfg_attr(feature = &quot;debug&quot;, derive(bevy_inspector_egui::Inspectable))]\n#[derive(Debug, Default, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Component)]\npub struct Coordinates {\n    pub x: u16,\n    pub y: u16,\n}\n\n// 定义坐标和运算, 以通过 + 直接使坐标相加\nimpl Add for Coordinates {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -&gt; Self::Output {\n        Self {\n            x: self.x + rhs.x,\n            y: self.y + rhs.y,\n        }\n    }\n}\n\n// 定义坐标差运算\nimpl Sub for Coordinates {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -&gt; Self::Output {\n        Self {\n            x: self.x.saturating_sub(rhs.x),\n            y: self.y.saturating_sub(rhs.y),\n        }\n    }\n}\n\n// 用于调试输出\nimpl Display for Coordinates {\n    fn fmt(&amp;self, f: &amp;mut Formatter&lt;&#39;_&gt;) -&gt; fmt::Result {\n        write!(f, &quot;({}, {})&quot;, self.x, self.y)\n    }\n}地砖接下来为游戏添加一些资源, 新建以下文件, 制作游戏中的地砖\nrust// src/resources/mod.rs\n\npub(crate) mod tile;\npub(crate) mod tile_map;rust// src/resources/tile.rs\n\n#[cfg(feature = &quot;debug&quot;)]\nuse colored::Colorize;\n\n/// 游戏中的地砖枚举\n#[derive(Debug, Copy, Clone, Eq, PartialEq)]\npub enum Tile {\n    /// 地雷\n    Bomb,\n    /// 周围地雷数\n    BombNeighbor(u8),\n    /// 空地砖\n    Empty,\n}\n\nimpl Tile {\n    /// 判断是否为地雷\n    pub const fn is_bomb(&amp;self) -&gt; bool {\n        matches!(self, Self::Bomb)\n    }\n\n    // 在命令行调试中输出字符串形式的地图, 并附带有颜色\n    #[cfg(feature = &quot;debug&quot;)]\n    pub fn console_output(&amp;self) -&gt; String {\n        format!(\n            &quot;{}&quot;,\n            match self {\n                Tile::Bomb =&gt; &quot;*&quot;.bright_red(),\n                Tile::BombNeighbor(v) =&gt; match v {\n                    1 =&gt; &quot;1&quot;.cyan(),\n                    2 =&gt; &quot;2&quot;.green(),\n                    3 =&gt; &quot;3&quot;.yellow(),\n                    _ =&gt; v.to_string().red(),\n                },\n                Tile::Empty =&gt; &quot; &quot;.normal(),\n            }\n        )\n    }\n}生成雷区地图新建如下文件\nrust//  src/resources/tile_map.rs\n\nuse crate::resources::tile::Tile;\nuse std::ops::{Deref, DerefMut};\n\n/// 基本地图\n#[derive(Debug, Clone)]\npub struct TileMap {\n    bomb_count: u16,\n    height: u16,\n    width: u16,\n    map: Vec&lt;Vec&lt;Tile&gt;&gt;,\n}\n\nimpl TileMap {\n    /// 生成空地图\n    pub fn empty(width: u16, height: u16) -&gt; Self {\n        let map = (0..height)\n            .into_iter()\n            .map(|_| (0..width).into_iter().map(|_| Tile::Empty).collect())\n            .collect();\n        Self {\n            bomb_count: 0,\n            height,\n            width,\n            map,\n        }\n    }\n\n    #[cfg(feature = &quot;debug&quot;)]\n    pub fn console_output(&amp;self) -&gt; String {\n        let mut buffer = format!(\n            &quot;Map ({}, {}) with {} bombs:\\n&quot;,\n            self.width, self.height, self.bomb_count\n        );\n        let line: String = (0..=(self.width + 1)).into_iter().map(|_| &#39;-&#39;).collect();\n        buffer = format!(&quot;{}{}\\n&quot;, buffer, line);\n        for line in self.iter().rev() {\n            buffer = format!(&quot;{}|&quot;, buffer);\n            for tile in line.iter() {\n                buffer = format!(&quot;{}{}&quot;, buffer, tile.console_output());\n            }\n            buffer = format!(&quot;{}|\\n&quot;, buffer);\n        }\n        format!(&quot;{}{}&quot;, buffer, line)\n    }\n\n    // 获得宽度\n    pub fn width(&amp;self) -&gt; u16 {\n        self.width\n    }\n\n    // 获得高度\n    pub fn height(&amp;self) -&gt; u16 {\n        self.height\n    }\n\n    // 获得周围地雷数\n    pub fn bomb_count(&amp;self) -&gt; u16 {\n        self.bomb_count\n    }\n}\n\nimpl Deref for TileMap {\n    type Target = Vec&lt;Vec&lt;Tile&gt;&gt;;\n\n    fn deref(&amp;self) -&gt; &amp;Self::Target {\n        &amp;self.map\n    }\n}\n\nimpl DerefMut for TileMap {\n    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {\n        &amp;mut self.map\n    }\n}\n\n/// 每个格子周围八个坐标\nconst SQUARE_COORDINATES: [(i8, i8); 8] = [\n    // 左下\n    (-1, -1),\n    // 正下\n    (0, -1),\n    // 右下\n    (1, -1),\n    // 正左\n    (-1, 0),\n    // 正右\n    (1, 0),\n    // 左上\n    (-1, 1),\n    // 正上\n    (0, 1),\n    // 右上\n    (1, 1),\n];为了检索每个格子周围的八个格子, 添加以下方法\nrust//  src/resources/tile_map.rs\nuse crate::components::Coordinates;\n\n// ..\n\n    pub fn safe_square_at(&amp;self, coordinates: Coordinates) -&gt; impl Iterator&lt;Item = Coordinates&gt; {\n        SQUARE_COORDINATES\n            .iter()\n            .copied()\n            .map(move |tuple| coordinates + tuple)\n    }为了能让坐标与u8元组相加, 我们需要再添加一个坐标相加方法\nrust// src/components/coordinates.rs\n\nimpl Add&lt;(i8, i8)&gt; for Coordinates {\n    type Output = Self;\n\n    fn add(self, (x, y): (i8, i8)) -&gt; Self::Output {\n        let x = ((self.x as i16) + x as i16) as u16;\n        let y = ((self.y as i16) + y as i16) as u16;\n        Self { x, y }\n    }\n}现在我们可以检索周围的地砖, 并计算坐标周围的地雷数来填充格子了\nrust// src/resources/tile_map.rs\n\n// ..\n\n    pub fn is_bomb_at(&amp;self, coordinates: Coordinates) -&gt; bool {\n        if coordinates.x &gt;= self.width || coordinates.y &gt;= self.height {\n            return false;\n        };\n        self.map[coordinates.y as usize][coordinates.x as usize].is_bomb()\n    }\n\n    pub fn bomb_count_at(&amp;self, coordinates: Coordinates) -&gt; u8 {\n        if self.is_bomb_at(coordinates) {\n            return 0;\n        }\n        let res = self\n            .safe_square_at(coordinates)\n            .filter(|coord| self.is_bomb_at(*coord))\n            .count();\n        res as u8\n    }下面通过随机数来生成地图, 放置地雷\nrust// src/resources/tile_map.rs\nuse rand::{thread_rng, Rng};\n// ..\n    /// 放置地雷及普通格子\n    pub fn set_bombs(&amp;mut self, bomb_count: u16) {\n        self.bomb_count = bomb_count;\n        let mut remaining_bombs = bomb_count;\n        let mut rng = thread_rng();\n        // 生成地雷\n        while remaining_bombs &gt; 0 {\n            let (x, y) = (\n                rng.gen_range(0..self.width) as usize,\n                rng.gen_range(0..self.height) as usize,\n            );\n            if let Tile::Empty = self[y][x] {\n                self[y][x] = Tile::Bomb;\n                remaining_bombs -= 1;\n            }\n        }\n        // 生成普通地砖\n        for y in 0..self.height {\n            for x in 0..self.width {\n                let coords = Coordinates { x, y };\n                if self.is_bomb_at(coords) {\n                    continue;\n                }\n                let num = self.bomb_count_at(coords);\n                if num == 0 {\n                    continue;\n                }\n                let tile = &amp;mut self[y as usize][x as usize];\n                *tile = Tile::BombNeighbor(num);\n            }\n        }\n    }测试插件下面把我们目前所做的封装成插件\n在 lib.rs 中加入如下内容\nrust// src/lib.rs\npub mod components;\npub mod resources;\n\nuse bevy::log;\nuse bevy::prelude::*;\nuse resources::tile_map::TileMap;\n\n/// 游戏面板插件\npub struct BoardPlugin;\n\nimpl Plugin for BoardPlugin {\n    fn build(&amp;self, app: &amp;mut App) {\n        app.add_startup_system(Self::create_board);\n        log::info!(&quot;Loaded Board Plugin&quot;);\n    }\n}\n\nimpl BoardPlugin {\n    /// 生成面板\n    pub fn create_board() {\n        let mut tile_map = TileMap::empty(20, 20);\n        tile_map.set_bombs(40);\n        #[cfg(feature = &quot;debug&quot;)]\n        log::info!(&quot;{}&quot;, tile_map.console_output());\n    }\n}接下来在 main.rs 文件中调用插件进行测试吧\nrust// src/main.rs\n\nuse minesweeper::BoardPlugin;\n\n// ..\n// 添加雷区地图\napp.add_plugin(BoardPlugin);\n执行 cargo run --features debug, 会有类似于以下输出\ntxt2022-03-05T10:45:33.299087Z  INFO bevy_render::renderer: AdapterInfo { name: &quot;NVIDIA GeForce GTX 1660 Ti with Max-Q Design&quot;, vendor: 4318, device: 8593, device_type: DiscreteGpu, backend: Vulkan }\n2022-03-05T10:45:33.777658Z  INFO minesweeper: Loaded Board Plugin\n2022-03-05T10:45:33.808146Z  INFO minesweeper: Map (20, 20) with 40 bombs:\n----------------------\n|  12211111221     11|\n|  1**11*12**1     1*|\n|  12322112*31111 122|\n|    1*1  111 1*1 1*1|\n|11  111      1111221|\n|*1      11211   1*1 |\n|2311  112*3*1   111 |\n|*2*21 1*33*21       |\n|233*1123*321 111111 |\n|1*2111*22*21 1*11*1 |\n|1111121112*1 2221232|\n|   1*2111221 1*1 1**|\n|   123*11*1  111 122|\n|   12*21111         |\n| 112*211221         |\n| 1*211 1**1         |\n| 111   1221         |\n|           111      |\n|     111   1*1 111  |\n|     1*1   111 1*1  |\n----------------------","slug":"2022-03-05","date":"2022-03-05T06:01:03.000Z","categories_index":"Course","tags_index":"Bevy,Rust","author_index":"芳塔洛斯"},{"id":"1bce5ded41dcb5c5e4afc4fd8cbdf1b2","title":"Zola使用教程(3) Templates","content":"\n\n\n\n\n\n\n注意\n文章重写中\n\n分页有两种东西可以分页，Section 和 Taxonomy\nSectionTaxonomy虽然 List 无法分页 (因为它始终能获得 list.html 下的所有变量), 但 Single 可以分页, 这里以 Tag 为例, 首先将配置文件中 Tag 分类改成下面这样\ntomltaxonomies = [\n    {name = &quot;tags&quot;, paginate_by= 1, paginate_path=&quot;tags&quot;},\n]第二个参数表示多少个tag分一页, 为了效果明显, 这里设置为1, 后面的参数是 Tag 所在的文件夹\n分类法","slug":"2022-01-26","date":"2022-01-26T13:56:37.000Z","categories_index":"Note","tags_index":"Zola,Frontend","author_index":"芳塔洛斯"},{"id":"d8b5640b29df9f7ffeb623c03831a256","title":"Katex 轻量级数学排版工具","content":"\n\n\n\n\n\n\n注意\n数学公式渲染有问题, 文章重写中\n\n概述Html 本身有一定的排版功能，比如上下标签\nhtmlH&lt;sub&gt;2&lt;/sub&gt;O\nX&lt;sup&gt;n&lt;/sup&gt; + Y&lt;sup&gt;n&lt;/sup&gt; = Z&lt;sup&gt;n&lt;/sup&gt;\n按 &lt;kbd&gt;&lt;kbd&gt;CTRL&lt;/kbd&gt;+&lt;kbd&gt;ALT&lt;/kbd&gt;+&lt;kbd&gt;Z&lt;/kbd&gt;&lt;/kbd&gt; 撤销比如以上内容会渲染成\nH2OXn + Yn &#x3D; Zn按 CTRL+ALT+Z 撤销\n更复杂的功能, 就需要专业的排版工具了, 最常用的工具之一就是 Latex, 可 Latex 太笨重了, 那有什么替代品吗？\nKatex简介相比 Latex，Katex 是一个更加轻量迅速的数学排版库, 简单的 API, 没有依赖性, 而且在所有主流浏览器上运行都超快\n安装Katex 既可以用 NodeJS 安装, 也可以直接在浏览器中使用, 这里我们展示后者, 在 Html 文件中的 &lt;head&gt; 标签中加入如下内容\nhtml&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css&quot;&gt;\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js&quot; onload=&quot;renderMathInElement(document.body);&quot;&gt;&lt;/script&gt;完成了, 很简单, 不是吗?\nJSDelivr 是一个是一个免费的速度很快的公用 CDN, 并且其在中国也有服务器, Katex 官网也建议我们用这种方式引入库\n接下来, 让我们写几个试一试, 直接在body标签中添加一个 &lt;p&gt; 标签\nhtml&lt;p&gt;\n行内公式: \\(\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…\\)\n&lt;/p&gt;\n&lt;p&gt;块公式:\n$$\n\\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } }\n$$&lt;/p&gt;上面的内容会被渲染成这样\n\n行内公式: \\(\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…\\)\n\n\n块公式:$$\\varphi &#x3D; 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } }$$\n接下来整个复杂的, 直接上代码, 注意 Katex 中的换行是 \\newline, 而不是 \\\\\nhtml&lt;p&gt;$$\nH&#39;&#39;(r)-aH&#39;(r)=0满足H&#39;(0)=\\frac 1{p^2}，\n\\newline H(0)=\\frac{H&#39;(0)}a(1+\\frac NYe^w)的特解\n\\newline 解:\\lambda^2+a\\lambda=0,\\lambda=a,\\lambda=0\n\\newline 通解H(r)=C_0+C_1e^{ar}.\\therefore H(0)=C_0+C_1,\n\\newline H&#39;(0)=aC\n\\newline \\therefore C_1=\\frac1{ap^2},C_0=H(0)-C_1=\\frac1{ap^2}\\cdot\\frac NYe^w\n\\newline \\therefore H=\\frac1{ap^2}\\cdot\\frac NYe^w+\\frac1{ap^2}e^{ar}\n\\newline 即,Hap^2Y=Ne^w+Ye^{ar}\n\\newline \\Huge{\\textcolor{red}{\\mathscr{Happy\\ New\\ Year}}}\n$$&lt;/p&gt;会输出以下内容\n$$H’’(r)-aH’(r)&#x3D;0 满足 H’(0)&#x3D;\\frac 1{p^2}H(0)&#x3D;\\frac{H’(0)}a(1+\\frac NYe^w) 的特解解:\\lambda^2+a\\lambda&#x3D;0,\\lambda&#x3D;a,\\lambda&#x3D;0通解 H(r)&#x3D;C_0+C_1e^{ar}.\\therefore H(0)&#x3D;C_0+C_1,H’(0)&#x3D;aC\\therefore C_1&#x3D;\\frac1{ap^2},C_0&#x3D;H(0)-C_1&#x3D;\\frac1{ap^2}\\cdot\\frac NYe^w\\therefore H&#x3D;\\frac1{ap^2}\\cdot\\frac NYe^w+\\frac1{ap^2}e^{ar}即, Hap^2Y&#x3D;Ne^w+Ye^{ar}\\Huge{\\textcolor{red}{\\mathscr{Happy\\ New\\ Year}}}$$\n在这里提前祝大家新年快乐, 更多 Katex 语法可以在官网查到\n","slug":"2022-01-24","date":"2022-01-24T14:55:37.000Z","categories_index":"Share","tags_index":"Frontend,Katex","author_index":"芳塔洛斯"},{"id":"34996d157a20fe53332a98eb287335c4","title":"Zola使用教程(2) Content","content":"\n\n\n\n\n\n\n注意\n文章重写中\n\n目录结构Zola 以目录结构确定站点结构\ntxt└── content\n    ├── content\n    │   └── something.md // -&gt; https://mywebsite.com/content/something/\n    ├── blog\n    │   ├── first.md // -&gt; https://mywebsite.com/blog/first/\n    │   ├── _index.md // -&gt; https://mywebsite.com/blog/\n    │   └── second.md // -&gt; https://mywebsite.com/blog/second/\n    └── other\n        └── _index.md // -&gt; https://mywebsite.com/other/每个页面路径 (base_url 之后的部分, 例如 blog/first/) 都可以通过更改页面的 path 或 slug 属性来自定义._index.md 用于存储 Section 本身的元数据和内容, 不作为页面. 理论上 Section 可以无限嵌套\nSection 不限于 md 文件. 可以将页面和一些相关文件 (例如图片或 js) 放在一起. 构建站点时, 所有非 md 文件都将与生成的页面一起复制, 所以我们可以吃使用相对路径来调用它们\n可以通过 config.toml 中的 ignored_content 来指定忽视某些文件, 支持通配符, 如 ignored_content = [&quot;*.xlsx&quot;]\n还可以将静态文件放置在 static 中. 放在其中的任何文件都将直接复制到 public 中\n分类系统通过在 config.toml 中写入以下内容来启用 Tag 分类方式\ntomltaxonomies = [\n    {name = &quot;tags&quot;},\n]接下来，让我们创建一篇博客, 并写入以下内容\nmd+++\ntitle = &quot;My second blog&quot;\ndate = 2022-01-23\n\n[taxonomies]\ntags = [&quot;tag1&quot;,&quot;tag2&quot;]\n+++\n\nWrite something这样就为我们的博客打上了标签, 接下来让我们在 Blog 页面中显示这些 Tag ,并为 Tag 创建索引页面\n显示tag先来完成第一件事, 显示这些 Tag，进入 Blog 的 Section 文件\nhtml{% extends &quot;base.html&quot; %}\n\n{% block content %}\n&lt;h1 class=&quot;title&quot;&gt;\n    {{ section.title }}\n&lt;/h1&gt;\n&lt;ul&gt;\n    {% for page in section.pages %}\n    &lt;li&gt;&lt;a href=&quot;{{ page.permalink | safe }}&quot;&gt;{{ page.title }}&lt;/a&gt;&lt;/li&gt;\n    {% endfor %}\n&lt;/ul&gt;\n{% endblock content %}在 for 循环中即 &lt;li&gt; 下面添加以下内容\nhtml{% if page.taxonomies.tags %}\n    &lt;div class=&quot;tags&quot;&gt;\n        {% for tag in page.taxonomies.tags %}\n            &lt;a class=&quot;tag&quot; href=&quot;{{ get_taxonomy_ur(kind=&quot;tags&quot;, name=tag) | safe }}&quot;&gt;#{{ tag }}&lt;/a&gt;\n        {% endfor %}\n    &lt;/div&gt;\n{% endif %}第一行的 if 用于判断这个 Page 有没有 Tag, 如果有, 就在内部的 for 循环中遍历这些 Tag, get_taxonomy_url方法将获取这个 Tag 的地址\n这时这些 Tag 就显示出来了, 但此时 a 标签指向的 Tag 地址是不存在的, 接下来让我们创建这个页面\n创建tag索引页面首先我们创建单独的 Tag 的索引页面, 并统计对应每一个 Tag 下有多少篇文章\n在模板文件夹下创建 tags/single.html, 并写入以下内容\nhtml{% extends &quot;base.html&quot; %}\n\n{% block content %}\n&lt;h1 class=&quot;tag-name&quot;&gt;Tag: #{ { term.name }}&lt;/h1&gt;\n&lt;a class=&quot;to-tags-list&quot; href=&quot;{{ get_url(path=&quot;/tags&quot;) }}&quot;&gt;To all tags&lt;/a&gt;\n{% for page in term.pages %}\n    &lt;a class=&quot;link&quot; href=&quot;{{ page.permalink | safe }}&quot; target=&quot;_blank&quot;&gt;{ { page.title }}&lt;/a&gt;\n{% endfor %}\n{% endblock content %}term 变量是分类中的特定组, 在这里就只特定的 Tag, &lt;h1&gt; 标签获取了这个 term 的名字, 也就是这个 Tag 的名字, &lt;a&gt; 标签指向了一个 Tag 列表页面, 目前这个页面还不存在, 我们稍后创建它, 下面的 for 循环遍历了这个 term 下所有的Page, 并通过a标签显示出来, 这个模板在编译后将生成 [url]/tags/[tag]/index.html 文件\n下面我们来创建 Tag 列表页面, 创建 tags/list.html 文件, 并在其中写入以下内容\nhtml{% extends &quot;base.html&quot; %}\n\n{% block content %}\n&lt;h1&gt;Tags&lt;/h1&gt;\n&lt;div class=&quot;tags-list&quot;&gt;\n    {% for term in terms %}\n        &lt;a href=&quot;{{ term.permalink }}&quot;&gt;\n        #{ { term.name }}\n        &lt;/a&gt;\n    {% endfor %}\n&lt;/div&gt;\n{% endblock content %}terms 是 term 的集合, 通过一个 for 循环遍历 terms, 并通过 &lt;a&gt; 标签指向先前提到的 [url]/tags/[tag]/index.html 文件, 这个模板编译后, 会生成 [url]/tags/index.html 文件\n至此, 一个简单的基于 Tag 的分类系统完成了, 接下来要做的就是亿点点了\n","slug":"2022-01-23","date":"2022-01-22T16:01:03.000Z","categories_index":"Note","tags_index":"Zola,Frontend","author_index":"芳塔洛斯"},{"id":"95f2e6cc37d8e9265a49ea0ed5ffc5cb","title":"在 Hexo 中使用更强大的 Markdown 引擎","content":"Hexo 的默认引擎Hexo 默认的 Markdown 渲染器是 hexo-renderer-marked, 针对于普通的 Markdown 文章书写, 该渲染器已经足够, 但是还是有着诸多缺陷, 比如不支持 Mathjax, 不支持插件扩展, 不支持 emoji 表情…\n以及有的时候会出现奇怪的 bug, 比如在 html 代码块中的 {{ }} {% %} 会被当成 Tag-Plugins, 破坏了代码块的密封性, 导致部分 Html 标签被渲染, 使页面变得十分奇怪\nMarkdown-it 引擎优点采用 Markdown-it 内核, 基本支持 Mathjax 语法, 支持 Markdown 以及 CommonMark 语法, 渲染速度比 hexo-renderer-marked 快, 支持插件配置, 支持标题带安全的 ID 信息, 支持脚注等\n安装和配置安装只需要两行命令\nsh# 卸载默认引擎\nnpm un hexo-renderer-marked -S\n# 安装新引擎\nnpm i hexo-renderer-markdown-it -S需要的话可以再安装一些插件, 可以 NPM 里进行搜索，关键字是 keywords:markdown-it-plugin\n比如, 如果有渲染公式的需要, 可以考虑 Katex, 对比 Mathjax 更加轻量\nshnpm i katex\nnpm i @andatoshiki/markdown-it-katex然后在&lt;head&gt;加入Katex的css\nhtml&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css&quot;&gt;然后 _config.yml 添加相关配置\nymlmarkdown:\n    render:\n        html: true # 在 md 文件中直接内联 html\n        xhtmlOut: false # 输出为符合 xhtml 的文件\n        breaks: true # 可以用 &lt;br&gt; 换行\n        linkify: true # 自动将可能是链接的内容转换成链接\n        typographer: true # 渲染(C), TM 等印刷标识\n    plugins:\n        - markdown-it-abbr\n        - markdown-it-footnote\n        - markdown-it-ins\n        - markdown-it-sub\n        - markdown-it-sup\n        - name: &#39;@andatoshiki/markdown-it-katex&#39;\n    anchors:\n        level: 2\n        collisionSuffix: &#39;&#39;\n        permalink: false,\n        permalinkClass: &#39;header-anchor&#39;\n        permalinkSymbol: &#39;&#39;\n        case: 0\n        separator: &#39;&#39;","slug":"2022-01-22-03","date":"2022-01-22T07:59:52.000Z","categories_index":"Note","tags_index":"Hexo,Markdown","author_index":"芳塔洛斯"},{"id":"d3bcecf34684df8d91318c48f7472df1","title":"禁用 Hexo 的 Tag Plugins","content":"有的时候 markdown 的代码块里会有一些 Nunjucks代码, 比如{{ }}, {% %}, 但不巧的是 Hexo 的 markdown 渲染引擎也用了这套语法, 被称为 Tag Plugins, 更不巧的是, 如果 Hexo 的代码块中含有这些语法, 它可能会被渲染, 所以当 Nunjucks 语法出现在 Html 代码块中时, 可能会破坏代码块的边界, 导致部分 Html 标签被渲染\n这时可以通过安装下面这个插件来禁用 Tag Plugins\nshnpm i hexo-stop-tag-plugins -S","slug":"2022-01-22-02","date":"2022-01-21T16:04:09.000Z","categories_index":"Note","tags_index":"Hexo","author_index":"芳塔洛斯"},{"id":"12da3e48d8c23028fedbec1829c337a9","title":"Zola使用教程(1) 初识Zola","content":"Zola 速览Zola 是一个静态站点生成器, 采用 Rust 编写, 并使用 Tera 模板引擎, 通过动态模板将内容转化为静态 HTML 页面. Zola 可以帮助您更快的构造站点, 并完成大量重复性工作, 即使以后不想在使用 Zola, 也可以将站点编译为普通的 HTML 文件导出\n开始在官网下载 Zola 的二进制文件, 并把它放入环境变量, 接下来在命令行终端运行\nshzola init [name]Zola 将会向您提出几个问题\ntxt&gt; What is the URL of your site? (https://example.com): #站点的url是什么\n&gt; Do you want to enable Sass compilation? [Y/n]: #是否启用sass编译\n&gt; Do you want to enable syntax highlighting? [y/N]: #是否启用语法高亮\n&gt; Do you want to build a search index of the content? [y/N]: #是否构造索引接下来, Zola 将会为我们初始化以下文件\ntxt├── config.toml\n├── content\n├── sass\n├── static\n├── templates\n└── themes你可以通过 zola build 命令来编译生成站点, 也可以通过 zola serve 命令开启一个本地服务器, 实时监听文件更新并即时编译站点, 这时打开服务器的链接应该会看到 zola 的欢迎页面\n主页Templates (模板) 是我们存放页面模板的地方\n首先在模板文件夹下创建一个 base.html 文件, 写入以下内容\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot; /&gt;\n        &lt;title&gt;MyBlog&lt;/title&gt;\n    &lt;/head&gt;\n\n    &lt;body&gt;\n        {% block content %} {% endblock %}\n    &lt;/body&gt;\n&lt;/html&gt;目前 Zola 对中文的支持不是很好, 所以默认语言用 en 就好\n其中 {% block content %} {% endblock %} 代表这里将会被一个名为 content 的块取代, 如果不希望编译生成的 Html 文件在这里有换行, 可以替换为 {%- block content %} {% endblock -%}\n接下来, 在模板目录创建一个 index.html 文件, 并写入以下内容\nhtml{% extends &quot;base.html&quot; %} {% block content %}\n&lt;h1 class=&quot;title&quot;&gt;\n    This is my blog made with Zola.\n&lt;/h1&gt;\n{% endblock content %}其中, {% extends &quot;base.html&quot; %} 表示该页面继承自 base.html. {% block content %} 与 {% endblock content %} 中间夹着的就是一个名为 content 的块, index.html 将以 base.html 为模板并将 content 块替换进去生成 Html 文件\n博客内容Content 文件夹是分类存放我们的博客内容的文件夹\n首先在内容文件夹下新建一个 blog 文件夹, 在 Content 中, 每一个子文件夹被称为一个 Section, 在 blog 文件夹下新建 _index.md 文件, 这将会被编译成名为 blog 的导航页面, 在其中以 Toml 格式写下如下变量\nmd+++\ntitle = &quot;List of blog posts&quot;\nsort_by = &quot;date&quot;\ntemplate = &quot;blog/section.html&quot;\npage_template = &quot;blog/page.html&quot;\n+++其中的变量不是必须的, 但两排 + 是必须的\n\ntitle: 文章标题, 并且你可以在 Section 模板中调用 section.title 这个变量\nsort_by: 文章排列的标准, 这里是按照日期排序\ntemplate:  这个 Section 所采用的模板\npage_template 这个 Section 下的 Page 所使用的模板\n\n完整的 Section 变量可在官方文档或者之后的文章中查询\n现在让我们为 Blog Section 创建模板\n在模板文件夹下创建 blog/section.html, 并写入以下内容\nhtml{% extends &quot;base.html&quot; %} {% block content %}\n&lt;h1 class=&quot;title&quot;&gt;{{ section.title }}&lt;/h1&gt;\n&lt;ul&gt;\n    {% for page in section.pages %}\n    &lt;li&gt;&lt;a href=&quot;{{ page.permalink | safe }}&quot;&gt;{{ page.title }}&lt;/a&gt;&lt;/li&gt;\n    {% endfor %}\n&lt;/ul&gt;\n{% endblock content %}{{ section.title }} 在编译时会被 Section 的 title 变量所取代, { % for page in section.pages %} 是 Zola 的一种短代码, 类似 Rust 中的迭代器, 迭代 Section 中所有的 Page (在 Section 下除了 _index.md 之外, 其他的 markdown 文件被称为 Page).\n{{ page.permalink | safe }} 前半部分是 Page 下的变量, 代表这个 Page 的 URL, | 后面是一个过滤器, 使用它的原因是固定链接不需要进行转义 (转义会导致/变成&amp;#x2F)\n这时进入浏览器中的 [Root]/blog 将会看到 Blog 页面, 这个页面是空的因为我们还没有任何一篇博客\n撰写第一篇博客在 Blog 文件夹下新建 first.md, 并写入\nmd+++\ntitle = &quot;First Blog&quot;\ndate = 2022-01-22\n+++\n\nHello World！其中的变量可以在 blog/page.html 下被使用, 变量之下是博客内容, 可作为 page.content 变量被使用\n现在进入 blog/page.html, 并写入如下内容\nhtml{% extends &quot;base.html&quot; %} {% block content %}\n&lt;h1 class=&quot;title&quot;&gt;{{ page.title }}&lt;/h1&gt;\n&lt;p class=&quot;subtitle&quot;&gt;&lt;strong&gt;{{ page.date }}&lt;/strong&gt;&lt;/p&gt;\n{{ page.content | safe }} {% endblock content %}接下来, 让我们创建第二篇博客, 之后再次进入 Blog 页面, 你将看到这两条博客按照 Page 中的 date 变量排列了\n最后, 你可以在主页放入一个 Blog 页面的超链接. 我们的初识 Zola 之旅就到此为止了\n附Zola 一共有四条子命令\n\ninit 初始化站点, 后面可不加名称参数\nbuild\nserve\ncheck 用于检查模板文件等是否存在错误\n更多信息可运行zola --help\n\n文件结构\n\npublic 编译输出默认目录\nstatic 存放静态文件, 如 js, image, css\nsass 存放 sass/scss 文件, 推荐使用 scss, 其兼容 css, 编译后会放到 public 文件夹下\nthemes 存放主题, 主题可在官网下载\n\nconfig.toml\n\n其中的变量可通过 config. 调用, 完整变量表如下:\n\ntoml# 站点 Root URL, 唯一必要变量\nbase_url = &quot;mywebsite.com&quot;\n\n# 站点标题与描述, 在 feed 中使用\ntitle = &quot;&quot;\ndescription = &quot;&quot;\n\n# 默认语言, 用于搜索框建立索引, 目前不支持中文\ndefault_language = &quot;en&quot;\n\n# 站点所用主题\ntheme = &quot;&quot;\n\n# 输出文件夹, 默认是 public\noutput_dir = &quot;public&quot;\n\n# 是否启用 sass 编译\ncompile_sass = false\n\n# 是否压缩 html 文件\nminify_html = false\n\n# 用于指定被忽略的文件目录\n# 例如:\n# ignored_content = [&quot;*.{graphml,xlsx}&quot;, &quot;temp.*&quot;]\nignored_content = []\n\n# 是否自动生成 feed\ngenerate_feed = false\n\n# 用于 feed 的文件名\nfeed_filename = &quot;atom.xml&quot;\n\n# 提要中的文章数, 默认未设置\n# feed_limit = 20\n\n# 当静态文件较大时可启用硬链接避免复制\nhard_link_static = false\n\n# 为站点呈现分类和默认语言配置\n# 例如:\n#     taxonomies = [\n#       {name = &quot;tags&quot;, feed = true}, # each tag will have its own feed\n#       {name = &quot;tags&quot;}, # you can have taxonomies with the same name in multiple languages\n#       {name = &quot;categories&quot;, paginate_by = 5},  # 5 items per page for a term\n#       {name = &quot;authors&quot;}, # Basic definition: no feed or pagination\n#     ]\n#\ntaxonomies = []\n\n# 是否由默认语言构造索引\nbuild_search_index = false\n\n[markdown]\n# markdown 语法高亮\nhighlight_code = false\n\n# 用于搜索附加 `.sublime-syntax` 文件的目录列表\nextra_syntaxes = []\n\n# 语法高亮主题\nhighlight_theme = &quot;base16-ocean-dark&quot;\n\n# makedown 中 emoji转义\n# 例如: `:smile:` =&gt; 😄\nrender_emoji = false\n\n# 是否在新建标签打开外部选项卡\n# 如果开启, 出于安全原因, 将始终自动添加 `rel=&quot;noopener&quot;`\nexternal_links_target_blank = false\n\n# 是否为所有外部链接设置 rel=&quot;nofollow&quot;\nexternal_links_no_follow = false\n\n# 是否为所有外部链接设置 rel=&quot;noreferrer&quot;\nexternal_links_no_referrer = false\n\n# 是否启用智能标点符号 (更改排版形式的引号, 破折号, 圆点)\n# 比如, `...` 到 `…`, `&quot;quote&quot;` 到 `“curly”`\nsmart_punctuation = false\n\n# 链接检查器的配置\n[link_checker]\n# 跳过以这些前缀开头的外部 URL 的链接检查\nskip_prefixes = [\n    &quot;http://&quot;,\n]\n\n# 跳过以这些前缀开头的外部 URL 的锚点检查\nskip_anchor_prefixes = [\n    &quot;https://&quot;,\n]\n\n[slugify]\npaths = &quot;on&quot;\ntaxonomies = &quot;on&quot;\nanchors = &quot;on&quot;\n\n[search]\n# 是否在索引中包含页面/部分的标题\ninclude_title = true\ninclude_description = false\ninclude_path = false\ninclude_content = true\n\n# 将内容截断到哪个字符. 如果您有很多页面并且索引会变得太大\n#而无法在站点上加载, 则很有用. 默认为未设置.\n# truncate_content_length = 100\n\n[translations]\n# default_language = &quot;fr&quot;\n# [translations]\n# title = &quot;Un titre&quot;\n#\n\n# 语言配置, 详见官网\n[languages]\n# [languages.fr]\n# title = &quot;Mon blog&quot;\n# generate_feed = true\n# taxonomies = [\n#    {name = &quot;auteurs&quot;},\n#    {name = &quot;tags&quot;},\n# ]\n# build_search_index = false\n\n# 在这放自定义变量\n# 例如:\n#     [extra]\n#     author = &quot;Famous author&quot;\n#\n# author 可作为 {{ config.extra.author }} 在模板中使用\n[extra]","slug":"2022-01-22-01","date":"2022-01-21T16:02:09.000Z","categories_index":"Course","tags_index":"Zola,Frontend","author_index":"芳塔洛斯"},{"id":"46bce36be5583ac102dad5fd1ec30a3e","title":"Neovim 基本配置","content":"介绍Neovim 是 Vim 的重构版本, 是 Vim 在这个时代的重生, 其完美继承了 Vim 的操作方式, 集成了 Lua 引擎, 能够使用 Lua 以及各种脚本来编写插件, 并为扩展编辑器提供更大的灵活性. 在 Neovim 0.5 版本中引入了语言服务器协议 (LSP),这意味着 Neovim 可以充当 LSP 服务器 (如 rust-analyzer)的客户端, 并协助构建增强的 LSP 工具\n安装官方主要提供了两种安装方法, 通过包管理器安装和手动安装, 包管理器只需一行命令, 这里我们介绍一下手动安装\n首先到 Releases · neovim&#x2F;neovim (github.com) 下载打包好的文件, 可以将其解压在任意文件夹, 将其中的bin文件夹添加到环境变量, 然后进入终端, 输入:\nshnvim -version这将输出类似以下内容:\ntxtNVIM v0.7.0-dev+905-gfcf5dd34f\nBuild type: RelWithDebInfo\nLuaJIT 2.1.0-beta3\nCompiled by runneradmin@fv-az152-721\n\nFeatures: -acl +iconv +tui\nSee &quot;:help feature-compile&quot;\n\n   system vimrc file: &quot;$VIM\\sysinit.vim&quot;\n  fall-back for $VIM: &quot;C:/Program Files/nvim/share/nvim&quot;\n\nRun :checkhealth for more info接下来可以通过在终端输入 nvim 直接在终端打开 Neovim 或者输入 nvim-qt 打开带有 GUI 的 Neovim\n初步设置最基本的使用为了防止初学者可能会出现 “无法退出” Neovim 的现象, 我们先熟悉一下 Neovim 最基本的操作\n\n进入 Neovim 时默认为 Normal 模式, 可以通过按下 i 键进入 Insert 编辑模式输入内容\n可以在任何模式下按下 Esc 键进入 Normal 模式\n输入 : 进入 Command 命令模式, 最基本的命令如下\n:q 退出 nvim\n:w 保存\n:wq 保存并退出\n\n\n每条命令后都可以加上 ! 来 强制执行\n\n执行 :checkhealth 可以看到更多信息\n指定配置文件的位置(可选)Windows 下 Neovim 的默认配置文件目录在 C:\\Users\\Username\\AppData\\Local\\nvim (用于保存自定义配置) 和 C:\\Users\\Username\\AppData\\Local\\nvim-data (用于保存插件等)\n但如果恰好用了 非纯 ASCII 字符 的用户名, 截止到目前, Neovim 可能会无法识别, 这时你就需要指定以下系统变量\ntxtXDG_CONFIG_HOME\nD:\\XDG_HOME\n\nXDG_DATA_HOME\nD:\\XDG_HOME这样你的配置文件就可以被转移到 D:\\XDG_HOME\\nvim 和 D:\\XDG_HOME\\nvim-data\n使用 Lua 配置 NeovimNeovim 的一大特点就是可以使用更加灵活高效的 Lua, 所以这里我们选择 Lua 作为我们的配置语言\n在 nvim 文件夹下新建 init.lua 文件, 既然都要使用 Neovim了, 那么就用 Neovim 在里面写入以下内容\nlua-- 关闭 vim 自带的文件管理\nvim.g.loaded_netrw = 1\nvim.g.loaded_netrwPlugin = 1\n\n-- 将 Leader 键映射为空格\nvim.g.mapleader = &#39; &#39;\nvim.g.maplocalleader = &#39; &#39;\n\n-- 始终显示分页标签栏\nvim.o.showtabline = 2\n\n-- 这是一种分模块的示例\n-- 核心配置\nrequire(&#39;core&#39;)\n-- 插件配置\nrequire(&#39;config&#39;)\n\n\n\n\n\n\n\n\nLeader 键可以用于快捷键重映射, 比如经过配置后, 可以键入 &lt;Leader&gt; + &lt;设置的键&gt; 快捷启动某功能\n新建 lua 文件夹并在里面新建 core 和 config 文件夹, 并分别新建 init.lua\nlua-- ===============================================\n-- core/init.lua\n-- ===============================================\n-- 加载插件\nrequire(&#39;core.plugins-manager&#39;)\n-- 加载一些基本设置\nrequire(&#39;core.base&#39;)\n\n-- ===============================================\n-- config/init.lua\n-- ===============================================\nrequire(&#39;config.ui&#39;)\nrequire(&#39;config.color-scheme&#39;)\nrequire(&#39;config.nvim-tree&#39;)\nrequire(&#39;config.telescope&#39;)\nrequire(&#39;config.lsp&#39;)插件管理器Vim 的 插件管理器很好, 但基于 Lua 的 lazy.nvim 更强大\nlua-- ===============================================\n-- core/plugins-manager.lua\n-- ===============================================\n-- 插件管理\n-- 检测lazy.nvim是否存在\nlocal lazypath = vim.fn.stdpath(&quot;data&quot;) .. &quot;/lazy/lazy.nvim&quot;\nif not vim.loop.fs_stat(lazypath) then\nvim.fn.system({\n    &quot;git&quot;,\n    &quot;clone&quot;,\n    &quot;--filter=blob:none&quot;,\n    &quot;https://github.com/folke/lazy.nvim.git&quot;,\n    &quot;--branch=stable&quot;, -- latest stable release\n    lazypath,\n})\nend\n\n-- 将lazypath设为运行时路径\nvim.opt.rtp:prepend(lazypath)\n\n-- 加载lazy.nvim模块\nrequire(&quot;lazy&quot;).setup{\n    -- 这将会直接自动加载lua/core/plugins下的所有文件\n    spec = { import = &quot;core.plugins&quot; },\n    git = {\n        log = { &quot;-8&quot; },\n        timeout = 120, -- 杀死超过两分钟无反应的进程\n        url_format = &quot;https://githubfast.com/%s.git&quot;, -- 启用代理下载\n        filter = true,\n    },\n    ui = {\n        icons = {\n            cmd = &quot;⌘&quot;,\n            config = &quot;🛠&quot;,\n            event = &quot;📅&quot;,\n            ft = &quot;📂&quot;,\n            init = &quot;⚙&quot;,\n            keys = &quot;🗝&quot;,\n            plugin = &quot;🔌&quot;,\n            runtime = &quot;💻&quot;,\n            source = &quot;📄&quot;,\n            start = &quot;🚀&quot;,\n            task = &quot;📌&quot;,\n            lazy = &quot;💤 &quot;,\n        },\n    },\n}之后每次配置新的插件, 重启 Neovim 就可以看到安装面板了\n一些基本设置lua-- ===============================================\n-- core/base.lua\n-- ===============================================\nlocal set = vim.opt\n\nset.tabstop = 4     -- tab=4空格\nset.shiftwidth = 4\nset.softtabstop = 4\nset.expandtab = true    -- tab转空格\n\nset.number = true   -- 绝对行号\nset.rnu = true  -- 相对行号\n\nset.scrolloff = 5   -- 垂直滚动时光标距底部行数\nset.cursorline = true   -- 高亮光标所在行\n\nset.textwidth=1000   -- 关闭自动换行\nset.wrap = falseLSP 配置为了写代码时能有语法高亮和代码提示, 这里我们选择 cmp-nvim-lsp 引擎\nlua-- ===============================================\n-- core/plugins/lsp.lua\n-- ===============================================\n-- LSP 引擎\nreturn {\n    &#39;hrsh7th/cmp-nvim-lsp&#39;,\n    &#39;hrsh7th/cmp-buffer&#39;,\n    &#39;hrsh7th/cmp-path&#39;,\n    &#39;hrsh7th/cmp-cmdline&#39;,\n    &#39;hrsh7th/nvim-cmp&#39;,\n    -- snippet 引擎\n    &#39;dcampos/nvim-snippy&#39;,\n    &#39;rafamadriz/friendly-snippets&#39;,\n    -- lsp 美化\n    &#39;onsails/lspkind-nvim&#39;,\n    -- lsp 支持\n    &quot;neovim/nvim-lspconfig&quot;,\n    &quot;williamboman/nvim-lsp-installer&quot;,\n    -- 语法高亮, 折叠代码, 缩进处理\n    {\n        &quot;nvim-treesitter/nvim-treesitter&quot;,\n        build = &quot;:TSUpdate&quot;,\n    }\n}\n\n-- ===============================================\n-- core/plugins/neodev.lua\n-- ===============================================\n-- 代码补全\nreturn {\n    &quot;folke/neodev.nvim&quot;,\n}\n\n-- ===============================================\n-- config/lsp.lua\n-- ===============================================\nlocal cmp = require(&#39;cmp&#39;)\nlocal lspkind = require(&#39;lspkind&#39;)\ncmp.setup{\n    snippet = {\n    expand = function(args)\n        require(&#39;snippy&#39;).expand_snippet(args.body)\n    end\n    },\n    sources = cmp.config.sources({\n        { name = &#39;nvim_lsp&#39; },\n        { name = &#39;snippy&#39; },\n        { name = &#39;buffer&#39; },\n        { name = &#39;path&#39; },\n    }),\n    -- 快捷键\n    mapping = {\n        -- 上一个\n        [&#39;&lt;C-k&gt;&#39;] = cmp.mapping.select_prev_item(),\n        -- 下一个\n        [&#39;&lt;C-j&gt;&#39;] = cmp.mapping.select_next_item(),\n        -- 出现补全\n        [&#39;&lt;A-.&gt;&#39;] = cmp.mapping(cmp.mapping.complete(), { &#39;i&#39;, &#39;c&#39; }),\n        -- 取消\n        [&#39;&lt;A-,&gt;&#39;] = cmp.mapping({\n            i = cmp.mapping.abort(),\n            c = cmp.mapping.close(),\n        }),\n        -- 确认\n        [&#39;&lt;CR&gt;&#39;] = cmp.mapping.confirm({\n            select = true ,\n            behavior = cmp.ConfirmBehavior.Replace\n        }),\n        -- [&#39;&lt;C-y&gt;&#39;] = cmp.config.disable, -- Specify `cmp.config.disable` if you want to remove the default `&lt;C-y&gt;` mapping.\n        [&#39;&lt;C-u&gt;&#39;] = cmp.mapping(cmp.mapping.scroll_docs(-4), { &#39;i&#39;, &#39;c&#39; }),\n        [&#39;&lt;C-d&gt;&#39;] = cmp.mapping(cmp.mapping.scroll_docs(4), { &#39;i&#39;, &#39;c&#39; }),\n    },\n        -- 使用lspkind-nvim显示类型图标\n    formatting = {\n        format = lspkind.cmp_format({\n        with_text = true, -- do not show text alongside icons\n        maxwidth = 50, -- prevent the popup from showing more than provided characters (e.g 50 will not show more than 50 characters)\n        before = function (entry, vim_item)\n            -- Source 显示提示来源\n            vim_item.menu = &quot;[&quot;..string.upper(entry.source.name)..&quot;]&quot;\n            return vim_item\n        end\n        })\n    },\n}\n\ncmp.setup.cmdline(&#39;/&#39;, {\n    sources = {\n      { name = &#39;buffer&#39; }\n    }\n})\n\ncmp.setup.cmdline(&#39;:&#39;, {\n    sources = cmp.config.sources({\n      { name = &#39;path&#39; }\n    }, {\n        { name = &#39;cmdline&#39; }\n      })\n})\n\n\n-- 设置语言服务器\nlocal lspconfig = require(&#39;lspconfig&#39;)\nlspconfig.rust_analyzer.setup {\n    settings = {\n      [&#39;rust-analyzer&#39;] = {},\n    },\n}\n\n\n-- 全局快捷键\nvim.keymap.set(&#39;n&#39;, &#39;&lt;space&gt;e&#39;, vim.diagnostic.open_float)\nvim.keymap.set(&#39;n&#39;, &#39;[d&#39;, vim.diagnostic.goto_prev)\nvim.keymap.set(&#39;n&#39;, &#39;]d&#39;, vim.diagnostic.goto_next)\nvim.keymap.set(&#39;n&#39;, &#39;&lt;space&gt;q&#39;, vim.diagnostic.setloclist)\n\nvim.api.nvim_create_autocmd(&#39;LspAttach&#39;, {\n    group = vim.api.nvim_create_augroup(&#39;UserLspConfig&#39;, {}),\n    callback = function(ev)\n        vim.bo[ev.buf].omnifunc = &#39;v:lua.vim.lsp.omnifunc&#39;\n\n        local opts = { buffer = ev.buf }\n        vim.keymap.set(&#39;n&#39;, &#39;gD&#39;, vim.lsp.buf.declaration, opts)\n        vim.keymap.set(&#39;n&#39;, &#39;gd&#39;, vim.lsp.buf.definition, opts)\n        vim.keymap.set(&#39;n&#39;, &#39;K&#39;, vim.lsp.buf.hover, opts)\n        vim.keymap.set(&#39;n&#39;, &#39;gi&#39;, vim.lsp.buf.implementation, opts)\n        vim.keymap.set(&#39;n&#39;, &#39;&lt;C-k&gt;&#39;, vim.lsp.buf.signature_help, opts)\n        vim.keymap.set(&#39;n&#39;, &#39;&lt;space&gt;wa&#39;, vim.lsp.buf.add_workspace_folder, opts)\n        vim.keymap.set(&#39;n&#39;, &#39;&lt;space&gt;wr&#39;, vim.lsp.buf.remove_workspace_folder, opts)\n        vim.keymap.set(&#39;n&#39;, &#39;&lt;space&gt;wl&#39;, function()\n            print(vim.inspect(vim.lsp.buf.list_workspace_folders()))\n        end, opts)\n        vim.keymap.set(&#39;n&#39;, &#39;&lt;space&gt;D&#39;, vim.lsp.buf.type_definition, opts)\n        vim.keymap.set(&#39;n&#39;, &#39;&lt;space&gt;rn&#39;, vim.lsp.buf.rename, opts)\n        vim.keymap.set({ &#39;n&#39;, &#39;v&#39; }, &#39;&lt;space&gt;ca&#39;, vim.lsp.buf.code_action, opts)\n        vim.keymap.set(&#39;n&#39;, &#39;gr&#39;, vim.lsp.buf.references, opts)\n        vim.keymap.set(&#39;n&#39;, &#39;&lt;space&gt;f&#39;, function()\n            vim.lsp.buf.format { async = true }\n        end, opts)\n    end,\n})为 Neovim 添加一个漂亮的 TUIlua-- ===============================================\n-- core/plugins/ui.lua\n-- ===============================================\n\n-- 需要安装 Nerd 字体来使用图标\n-- 图标到 https://www.nerdfonts.com/cheat-sheet 复制\nreturn {\n    {-- 首页\n        &#39;goolord/alpha-nvim&#39;,\n        event = &quot;VimEnter&quot;,\n        dependencies = {\n            &#39;nvim-tree/nvim-web-devicons&#39;\n        },\n    },\n    {-- 顶部标签栏\n        &#39;romgrk/barbar.nvim&#39;,\n        dependencies = {\n            &#39;lewis6991/gitsigns.nvim&#39;, -- git 状态\n            &#39;nvim-tree/nvim-web-devicons&#39;, -- 文件图标\n        },\n        init = function()\n            vim.g.barbar_auto_setup = false\n        end,\n        opts = {    -- lazy.nvim会自动加载配置\n            animation = true,\n            -- insert_at_start = true,\n        },\n        version = &#39;*&#39;,\n    },\n    {-- 侧边文件管理\n        &quot;nvim-tree/nvim-tree.lua&quot;,\n        version = &quot;*&quot;,\n        dependencies = {\n            &quot;nvim-tree/nvim-web-devicons&quot;,\n        },\n        event = &quot;VimEnter&quot;,\n        config = function()\n            require(&quot;nvim-tree&quot;).setup {}\n        end,\n    },\n    {-- 侧边滚动条\n        &quot;petertriho/nvim-scrollbar&quot;,\n        config = function()\n        require(&quot;scrollbar&quot;).setup()\n        end,\n    },\n    {-- 单文件全文查找, 直接输入/内容, 用:nohl清除\n        &quot;kevinhwang91/nvim-hlslens&quot;,\n        config = function()\n        -- require(&#39;hlslens&#39;).setup() is not required\n        require(&quot;scrollbar.handlers.search&quot;).setup()\n        end,\n    },\n    {-- 显示文件大纲\n        &#39;stevearc/aerial.nvim&#39;,\n        config = function()\n            require(&quot;aerial&quot;).setup()\n        end,\n    },\n    {-- 底部状态栏\n        &#39;nvim-lualine/lualine.nvim&#39;,\n        config = function()\n            require(&#39;lualine&#39;).setup()\n        end,\n    },\n    -- 缩进对齐线\n    &quot;lukas-reineke/indent-blankline.nvim&quot;,\n}\n-- ===============================================\n-- config/ui.lua\n-- ===============================================\n-- 主页配置\nlocal alpha = require(&quot;alpha&quot;)\nlocal dashboard = require(&quot;alpha.themes.dashboard&quot;)\n\n-- 这里替换成你自己的 ASCII Logo\ndashboard.section.header.val = {\n    [[                                                   ]],\n    [[                                                   ]],\n    [[███████╗ ██████╗ ███╗   ██╗████████╗██╗      ██████╗ ███████╗]],\n    [[██╔════╝██╔═══██╗████╗  ██║╚══██╔══╝██║     ██╔═══██╗██╔════╝]],\n    [[█████╗  ██║   ██║██╔██╗ ██║   ██║   ██║     ██║   ██║███████╗]],\n    [[██╔══╝  ██║   ██║██║╚██╗██║   ██║   ██║     ██║   ██║╚════██║]],\n    [[██║     ╚██████╔╝██║ ╚████║   ██║   ███████╗╚██████╔╝███████║]],\n    [[╚═╝      ╚═════╝ ╚═╝  ╚═══╝   ╚═╝   ╚══════╝ ╚═════╝ ╚══════╝]],\n    [[                                                   ]],\n    [[\t\t\t\t\t\t╔═╗╦ ╦ ╦╔═╗╦╔═╗\t\t\t\t\t\t]],\n    [[\t\t\t\t\t\t║╣ ║ ╚╦╝╚═╗║╠═╣\t\t\t\t\t\t]],\n    [[\t\t\t\t\t\t╚═╝╩═╝╩ ╚═╝╩╩ ╩\t\t\t\t\t\t]],\n}\n\ndashboard.section.buttons.val = {\n    -- 图标到 https://www.nerdfonts.com/cheat-sheet 复制\n    dashboard.button(&quot;h&quot;, &quot;󱋡  &gt; History&quot;, &quot;:History&lt;CR&gt;&quot;),\n    dashboard.button(&quot;n&quot;, &quot;  &gt; New file&quot;, &quot;:ene &lt;BAR&gt; startinsert &lt;CR&gt;&quot;),\n    dashboard.button(&quot;t&quot;, &quot;󰙅  &gt; Open filetree&quot;, &quot;:NvimTreeOpen&lt;CR&gt;&quot;),\n    dashboard.button(&quot;f&quot;, &quot;󰈞  &gt; Find File&quot;, &quot;:Telescope find_files&lt;CR&gt;&quot;),\n    dashboard.button(&quot;w&quot;, &quot;  &gt; Find word&quot;, &quot;:Telescope live_grep&lt;CR&gt;&quot;),\n    dashboard.button(&quot;l&quot;, &quot;󱧕  &gt; Lazy manager&quot;, &quot;:Lazy&lt;CR&gt;&quot;),\n    dashboard.button(&quot;q&quot;, &quot;  &gt; Quit Nvim&quot;, &quot;:qa&lt;CR&gt;&quot;),\n}\n\n-- 自定义页脚文字\ndashboard.section.footer = {\n    [[ Debug the World ]],\n}\n\nalpha.setup(dashboard.opts)\n\n-- 缩进线配置\n-- 彩色缩进线\nvim.opt.termguicolors = true\n\nvim.cmd [[highlight IndentBlanklineIndent1 guifg=#E06C75 gui=nocombine]]\nvim.cmd [[highlight IndentBlanklineIndent2 guifg=#E5C07B gui=nocombine]]\nvim.cmd [[highlight IndentBlanklineIndent3 guifg=#98C379 gui=nocombine]]\nvim.cmd [[highlight IndentBlanklineIndent4 guifg=#56B6C2 gui=nocombine]]\nvim.cmd [[highlight IndentBlanklineIndent5 guifg=#61AFEF gui=nocombine]]\nvim.cmd [[highlight IndentBlanklineIndent6 guifg=#C678DD gui=nocombine]]\n\nvim.opt.list = true\nvim.opt.listchars:append &quot;space:⋅&quot; -- 用·占用空格位置\nvim.opt.listchars:append &quot;eol:↴&quot; -- 追加换行标识\n\nrequire(&quot;indent_blankline&quot;).setup {\n    -- 上下文链接关联缩进线\n    show_current_context = true,\n    show_current_context_start = true,\n    show_end_of_line = true, -- 缩进末端显示直线\n    -- 彩色缩进线部分\n    space_char_blankline = &quot; &quot;,\n    char_highlight_list = {\n        &quot;IndentBlanklineIndent1&quot;,\n        &quot;IndentBlanklineIndent2&quot;,\n        &quot;IndentBlanklineIndent3&quot;,\n        &quot;IndentBlanklineIndent4&quot;,\n        &quot;IndentBlanklineIndent5&quot;,\n        &quot;IndentBlanklineIndent6&quot;,\n    },\n}\n\n-- ===============================================\n-- config/color-scheme\n-- ===============================================\n\n-- 颜色主题\nlocal M = {}\n\nM.highlight = function(group, options)\n    local guifg = options.fg or &quot;NONE&quot;\n    local guibg = options.bg or &quot;NONE&quot;\n    local guisp = options.sp or &quot;NONE&quot;\n    local gui = options.gui or &quot;NONE&quot;\n    local blend = options.blend or 0\n    local ctermfg = options.ctermfg or &quot;NONE&quot;\n\n    vim.cmd(\n        string.format(\n            &quot;highlight %s guifg=%s ctermfg=%s guibg=%s guisp=%s gui=%s blend=%d&quot;,\n            group,\n            guifg,\n            ctermfg,\n            guibg,\n            guisp,\n            gui,\n            blend\n        )\n    )\nend\n\nM.link = function(groupa, groupb)\n    vim.cmd(string.format(&quot;highlight link %s %s&quot;, groupa, groupb))\nend\n\nM.colors = {\n    red = &quot;#E06C75&quot;,\n    dark_red = &quot;#BE5046&quot;,\n    diff_red = &quot;#2c1517&quot;,\n    green = &quot;#98C379&quot;,\n    dark_green = &quot;#59843b&quot;,\n    dimm_green = &quot;#41602b&quot;,\n    diff_green = &quot;#1e2718&quot;,\n    yellow = &quot;#E5C07B&quot;,\n    diff_yellow = &quot;#3e2e1e&quot;,\n    dark_yellow = &quot;#D19A66&quot;,\n    blue = &quot;#61AFEF&quot;,\n    dimm_blue = &quot;#0d4c7f&quot;,\n    purple = &quot;#C678DD&quot;,\n    dimm_purple = &quot;#633c6e&quot;,\n    diff_purple = &quot;#27182C&quot;,\n    cyan = &quot;#56B6C2&quot;,\n    white = &quot;#ABB2BF&quot;,\n    black = &quot;#1f1f1f&quot;,\n    dimm_black = &quot;#1c1c1c&quot;,\n    dark_black = &quot;#1a1a1a&quot;,\n    comment_grey = &quot;#5C6370&quot;,\n    gutter_fg_grey = &quot;#4B5263&quot;,\n    cursor_grey = &quot;#2C323C&quot;,\n    dimm_cursor_grey = &quot;#21262d&quot;,\n    dark_cursor_grey = &quot;#1d2228&quot;,\n    visual_grey = &quot;#3E4452&quot;,\n    special_grey = &quot;#3B4048&quot;,\n    bracket_grey = &quot;#7C828C&quot;,\n}\n\nM.setup = function()\n    vim.g.colors_name = &quot;onedark&quot;\n    -- vim.cmd [[highlight clear]]\n    -- vim.cmd [[syntax reset]]\n\n    M.highlight(&quot;Comment&quot;, { fg = M.colors.comment_grey, gui = &quot;italic,bold&quot; })\n    M.highlight(&quot;Constant&quot;, { fg = M.colors.cyan })\n    M.highlight(&quot;String&quot;, { fg = M.colors.green, gui = &quot;italic&quot; })\n    M.highlight(&quot;Character&quot;, { fg = M.colors.green })\n    M.highlight(&quot;Number&quot;, { fg = M.colors.dark_yellow })\n    M.highlight(&quot;Boolean&quot;, { fg = M.colors.dark_yellow })\n    M.highlight(&quot;Float&quot;, { fg = M.colors.dark_yellow })\n    M.highlight(&quot;Identifier&quot;, { fg = M.colors.red })\n    M.highlight(&quot;Function&quot;, { fg = M.colors.blue })\n    M.highlight(&quot;Statement&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;Conditional&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;Repeat&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;Label&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;Operator&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;Keyword&quot;, { fg = M.colors.red })\n    M.highlight(&quot;Exception&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;PreProc&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;Include&quot;, { fg = M.colors.blue })\n    M.highlight(&quot;Define&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;Macro&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;PreCondit&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;Type&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;StorageClass&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;Structure&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;Typedef&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;Special&quot;, { fg = M.colors.blue })\n    M.highlight(&quot;SpecialChar&quot;, {})\n    M.highlight(&quot;Tag&quot;, {})\n    M.highlight(&quot;Delimiter&quot;, {})\n    M.highlight(&quot;SpecialComment&quot;, { fg = M.colors.comment_grey, gui = &quot;italic&quot; })\n    M.highlight(&quot;Debug&quot;, {})\n    M.highlight(&quot;Underlined&quot;, { gui = &quot;underline&quot; })\n    M.highlight(&quot;Bold&quot;, { gui = &quot;bold&quot; })\n    M.highlight(&quot;CursorWord0&quot;, { gui = &quot;bold&quot; })\n    M.highlight(&quot;CursorWord1&quot;, { gui = &quot;bold&quot; })\n    M.highlight(&quot;Ignore&quot;, {})\n    M.highlight(&quot;Error&quot;, { fg = M.colors.dark_red })\n    M.highlight(&quot;Todo&quot;, { fg = M.colors.purple })\n\n    M.highlight(&quot;ColorColumn&quot;, {})\n    M.highlight(&quot;VirtColumn&quot;, { fg = M.colors.dark_black })\n    M.highlight(&quot;Conceal&quot;, { fg = M.colors.red })\n    M.highlight(&quot;Cursor&quot;, { fg = M.colors.black, bg = M.colors.green })\n    M.highlight(&quot;LspCodeLens&quot;, { fg = M.colors.bracket_grey })\n    M.highlight(&quot;LspCodeLensSeparator&quot;, { fg = M.colors.bracket_grey })\n    M.highlight(&quot;LspInlayHint&quot;, { fg = M.colors.visual_grey })\n    M.highlight(&quot;LSPDeprecated&quot;, { fg = M.colors.comment_grey, gui = &quot;strikethrough&quot; })\n    M.highlight(&quot;CursorIM&quot;, {})\n    M.highlight(&quot;CursorColumn&quot;, { bg = M.colors.dark_black })\n    M.highlight(&quot;CursorLine&quot;, { bg = M.colors.dark_black })\n    M.highlight(&quot;Directory&quot;, { fg = M.colors.blue })\n    M.highlight(&quot;DiffAdd&quot;, { bg = M.colors.diff_green })\n    M.highlight(&quot;DiffChange&quot;, { bg = M.colors.diff_yellow })\n    M.highlight(&quot;DiffDelete&quot;, { fg = M.colors.cursor_grey })\n    M.highlight(&quot;DiffDeleteOld&quot;, { bg = M.colors.diff_red })\n    M.highlight(&quot;DiffText&quot;, { bg = M.colors.diff_yellow })\n    M.highlight(&quot;ErrorMsg&quot;, { fg = M.colors.red })\n    M.highlight(&quot;VertSplit&quot;, { fg = M.colors.dark_black, bg = M.colors.dark_black })\n    M.highlight(&quot;Folded&quot;, { fg = M.colors.comment_grey, bg = M.colors.dimm_black })\n    M.highlight(&quot;FoldColumn&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;SignColumn&quot;, {})\n    M.highlight(&quot;IncSearch&quot;, { fg = M.colors.comment_grey, bg = M.colors.green })\n    M.highlight(&quot;LineNr&quot;, { fg = M.colors.gutter_fg_grey })\n    M.highlight(&quot;CursorLineNr&quot;, { fg = M.colors.green })\n    M.highlight(&quot;MatchParen&quot;, { fg = M.colors.blue, gui = &quot;underline&quot; })\n    M.highlight(&quot;ModeMsg&quot;, {})\n    M.highlight(&quot;MoreMsg&quot;, {})\n    M.highlight(&quot;NonText&quot;, { fg = M.colors.special_grey })\n    M.highlight(&quot;Normal&quot;, { fg = M.colors.white })\n    M.highlight(&quot;Pmenu&quot;, { bg = M.colors.dark_black, blend = 10 })\n    M.highlight(&quot;PmenuSel&quot;, { fg = M.colors.black, bg = M.colors.green })\n    M.highlight(&quot;PmenuSbar&quot;, { bg = M.colors.special_grey })\n    M.highlight(&quot;PmenuThumb&quot;, { bg = M.colors.white })\n    M.highlight(&quot;Question&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;Search&quot;, { fg = M.colors.black, bg = M.colors.comment_grey })\n    M.highlight(&quot;ESearchMatch&quot;, { fg = M.colors.black, bg = M.colors.comment_grey })\n    M.highlight(&quot;QuickFixLine&quot;, { gui = &quot;bold&quot; })\n    M.highlight(&quot;SpecialKey&quot;, { fg = M.colors.special_grey })\n    M.highlight(&quot;SpellBad&quot;, { gui = &quot;undercurl&quot;, sp = M.colors.red })\n    M.highlight(&quot;SpellCap&quot;, { gui = &quot;undercurl&quot;, sp = M.colors.special_grey })\n    M.highlight(&quot;SpellLocal&quot;, { gui = &quot;undercurl&quot;, sp = M.colors.special_grey })\n    M.highlight(&quot;SpellRare&quot;, { gui = &quot;undercurl&quot;, sp = M.colors.special_grey })\n    M.highlight(&quot;StatusLine&quot;, { fg = M.colors.white, bg = M.colors.dark_black })\n    M.highlight(&quot;StatusLineNC&quot;, { fg = M.colors.comment_grey, bg = M.colors.dark_black })\n    M.highlight(&quot;TabLine&quot;, { fg = M.colors.comment_grey })\n    M.highlight(&quot;TabLineFill&quot;, {})\n    M.highlight(&quot;TabLineSel&quot;, { fg = M.colors.white })\n    M.highlight(&quot;Title&quot;, { fg = M.colors.green })\n    M.highlight(&quot;Visual&quot;, { fg = M.colors.visual_black, bg = M.colors.visual_grey })\n    M.highlight(&quot;VisualNOS&quot;, { bg = M.colors.visual_grey })\n    M.highlight(&quot;WarningMsg&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;WildMenu&quot;, { fg = M.colors.black, bg = M.colors.blue })\n    M.highlight(&quot;WinNormalNC&quot;, { bg = M.colors.dark_black })\n    M.highlight(&quot;HighlightedyankRegion&quot;, { bg = M.colors.comment_grey })\n\n    --- Languages\n\n    -- Markdown\n    M.highlight(&quot;markdownCode&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;markdownCodeBlockBGBorder&quot;, { bg = M.colors.dark_black })\n    M.highlight(&quot;markdownCodeBlockBGBorderSign&quot;, { fg = M.colors.gutter_fg_grey })\n    M.highlight(&quot;markdownCodeBlock&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;markdownCodeDelimiter&quot;, { fg = M.colors.cursor_grey })\n    M.highlight(&quot;markdownHeadingDelimiter&quot;, { fg = M.colors.gutter_fg_grey })\n    M.highlight(&quot;markdownRule&quot;, { fg = M.colors.comment_grey })\n    M.highlight(&quot;markdownHeadingRule&quot;, { fg = M.colors.comment_grey })\n    M.highlight(&quot;markdownH1&quot;, { fg = M.colors.green, gui = &quot;bold,italic&quot; })\n    M.highlight(&quot;markdownH2&quot;, { fg = M.colors.yellow, gui = &quot;bold,italic&quot; })\n    M.highlight(&quot;markdownH3&quot;, { fg = M.colors.green, gui = &quot;bold,italic&quot; })\n    M.highlight(&quot;markdownH4&quot;, { fg = M.colors.green, gui = &quot;bold,italic&quot; })\n    M.highlight(&quot;markdownH5&quot;, { fg = M.colors.green, gui = &quot;bold,italic&quot; })\n    M.highlight(&quot;markdownH6&quot;, { fg = M.colors.green, gui = &quot;bold,italic&quot; })\n    M.highlight(&quot;markdownIdDelimiter&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;markdownId&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;markdownBlockquote&quot;, { fg = M.colors.comment_grey })\n    M.highlight(&quot;markdownItalic&quot;, { gui = &quot;italic&quot; })\n    M.highlight(&quot;markdownBold&quot;, { fg = M.colors.dark_yellow, gui = &quot;bold&quot; })\n    M.highlight(&quot;markdownListMarker&quot;, { fg = M.colors.red })\n    M.highlight(&quot;markdownOrderedListMarker&quot;, { fg = M.colors.red })\n    M.highlight(&quot;markdownIdDeclaration&quot;, { fg = M.colors.blue })\n    M.highlight(&quot;markdownLinkText&quot;, { fg = M.colors.blue })\n    M.highlight(&quot;markdownLinkDelimiter&quot;, { fg = M.colors.white })\n    M.highlight(&quot;markdownUrl&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;MDTSFencedCodeBlock&quot;, { fg = M.colors.red })\n    M.highlight(&quot;MDTSFencedCodeBlockInfo&quot;, { fg = M.colors.dark_yellow })\n    M.highlight(&quot;@text.reference&quot;, { fg = M.colors.blue })\n    M.highlight(&quot;MDTSLinkText&quot;, { fg = M.colors.white })\n\n    M.highlight(&quot;CodeBlock&quot;, { bg = M.colors.dimm_black })\n    M.highlight(&quot;HeadlineGreen&quot;, { bg = M.colors.diff_green })\n    M.highlight(&quot;HeadlineBlue&quot;, { bg = M.colors.dimm_cursor_grey })\n    M.highlight(&quot;HeadlineRed&quot;, { bg = M.colors.diff_red })\n    M.highlight(&quot;HeadlinePurple&quot;, { bg = M.colors.diff_purple })\n    M.highlight(&quot;HeadlineYellow&quot;, { bg = M.colors.diff_yellow })\n    M.highlight(&quot;@OrgTSHeadlineLevel1&quot;, { fg = M.colors.green, gui = &quot;bold&quot; })\n    M.highlight(&quot;@OrgTSHeadlineLevel2&quot;, { fg = M.colors.blue, gui = &quot;bold&quot; })\n    M.highlight(&quot;@OrgTSHeadlineLevel3&quot;, { fg = M.colors.red, gui = &quot;bold&quot; })\n    M.highlight(&quot;@OrgTSHeadlineLevel4&quot;, { fg = M.colors.purple, gui = &quot;bold&quot; })\n    M.highlight(&quot;@OrgTSHeadlineLevel5&quot;, { fg = M.colors.yellow, gui = &quot;bold&quot; })\n    M.highlight(&quot;@OrgTSHeadlineLevel6&quot;, { fg = M.colors.green, gui = &quot;bold&quot; })\n    M.highlight(&quot;@OrgTSHeadlineLevel7&quot;, { fg = M.colors.blue, gui = &quot;bold&quot; })\n    M.highlight(&quot;@OrgTSHeadlineLevel8&quot;, { fg = M.colors.red, gui = &quot;bold&quot; })\n\n    --- Treesitter\n    -- Misc\n    M.highlight(&quot;TSError&quot;, { fg = M.colors.red })\n    M.highlight(&quot;TSPunctDelimiter&quot;, { fg = M.colors.bracket_grey })\n    M.highlight(&quot;TSPunctBracket&quot;, { fg = M.colors.bracket_grey })\n    M.highlight(&quot;TSPunctSpecial&quot;, { fg = M.colors.bracket_grey })\n\n    -- -- Constants\n    -- -- M.highlight(&quot;TSConstant&quot;, {})\n    M.highlight(&quot;TSConstBuiltin&quot;, { fg = M.colors.dark_yellow, gui = &quot;bold&quot; })\n    -- -- Not sure about this guy\n    -- M.highlight(&quot;TSConstMacro&quot;, {})\n    -- M.highlight(&quot;TSString&quot;, {})\n    -- M.highlight(&quot;TSStringRegex&quot;, {})\n    M.highlight(&quot;TSStringEscape&quot;, { fg = M.colors.yellow })\n    -- M.highlight(&quot;TSCharacter&quot;, {})\n    -- M.highlight(&quot;TSNumber&quot;, {})\n    -- M.highlight(&quot;TSBoolean&quot;, {})\n    -- M.highlight(&quot;TSFloat&quot;, {})\n    -- M.highlight(&quot;TSAnnotation&quot;, {})\n    -- M.highlight(&quot;TSAttribute&quot;, {})\n    -- M.highlight(&quot;TSNamespace&quot;, {})\n\n    -- -- Functions\n    M.highlight(&quot;TSFuncBuiltin&quot;, { fg = M.colors.dark_yellow, gui = &quot;bold&quot; })\n    -- M.highlight(&quot;TSFunction&quot;, {})\n    -- M.highlight(&quot;TSFuncMacro&quot;, {})\n    -- M.highlight(&quot;TSParameter&quot;, {})\n    -- M.highlight(&quot;TSParameterReference&quot;, {})\n    -- M.highlight(&quot;TSMethod&quot;, {})\n    -- M.highlight(&quot;TSField&quot;, {})\n    -- M.highlight(&quot;TSProperty&quot;, {})\n    M.highlight(&quot;TSConstructor&quot;, { fg = M.colors.red, gui = &quot;bold&quot; })\n\n    -- -- Keywords\n    -- M.highlight(&quot;TSConditional&quot;, {})\n    -- M.highlight(&quot;TSRepeat&quot;, {})\n    -- M.highlight(&quot;TSLabel&quot;, {})\n    -- M.highlight(&quot;TSKeyword&quot;, {})\n    -- M.highlight(&quot;TSKeywordFunction&quot;, {})\n    -- M.highlight(&quot;TSKeywordOperator&quot;, {})\n    -- M.highlight(&quot;TSOperator&quot;, {})\n    -- M.highlight(&quot;TSException&quot;, {})\n    -- M.highlight(&quot;TSType&quot;, {})\n    M.highlight(&quot;TSTypeBuiltin&quot;, { fg = M.colors.dark_yellow, gui = &quot;bold&quot; })\n    M.highlight(&quot;TSTextReference&quot;, { fg = M.colors.blue, gui = &quot;underline&quot; })\n    -- M.highlight(&quot;TSStructure&quot;, {})\n    -- M.highlight(&quot;TSInclude&quot;, {})\n\n    -- -- Variable\n    -- M.highlight(&quot;TSVariable&quot;, {})\n    M.highlight(&quot;TSVariableBuiltin&quot;, { fg = M.colors.dark_yellow, gui = &quot;bold&quot; })\n\n    -- -- Text\n    -- M.highlight(&quot;TSText&quot;, {})\n    -- M.highlight(&quot;TSStrong&quot;, {})\n    -- M.highlight(&quot;TSEmphasis&quot;, {})\n    -- M.highlight(&quot;TSUnderline&quot;, {})\n    -- M.highlight(&quot;TSTitle&quot;, {})\n    -- M.highlight(&quot;TSLiteral&quot;, {})\n    M.highlight(&quot;TSURI&quot;, { fg = M.colors.blue, gui = &quot;underline&quot; })\n\n    -- -- Tags\n    -- M.highlight(&quot;TSTag&quot;, {})\n    -- M.highlight(&quot;TSTagDelimiter&quot;, {})\n\n    --- Plugins\n    M.highlight(&quot;illuminatedWord&quot;, { gui = &quot;bold&quot; })\n\n    M.highlight(&quot;diffAdded&quot;, { fg = M.colors.green })\n    M.highlight(&quot;diffRemoved&quot;, { fg = M.colors.red })\n    M.highlight(&quot;gitcommitComment&quot;, { fg = M.colors.gutter_fg_grey, gui = &quot;italic,bold&quot; })\n    M.highlight(&quot;gitcommitUnmerged&quot;, { fg = M.colors.green })\n    M.highlight(&quot;gitcommitOnBranch&quot;, {})\n    M.highlight(&quot;gitcommitBranch&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;gitcommitDiscardedType&quot;, { fg = M.colors.red })\n    M.highlight(&quot;gitcommitSelectedType&quot;, { fg = M.colors.green })\n    M.highlight(&quot;gitcommitHeader&quot;, {})\n    M.highlight(&quot;gitcommitUntrackedFile&quot;, { fg = M.colors.cyan })\n    M.highlight(&quot;gitcommitDiscardedFile&quot;, { fg = M.colors.red })\n    M.highlight(&quot;gitcommitSelectedFile&quot;, { fg = M.colors.green })\n    M.highlight(&quot;gitcommitUnmergedFile&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;gitcommitFile&quot;, {})\n    M.highlight(&quot;gitcommitSummary&quot;, { fg = M.colors.white })\n    M.highlight(&quot;gitcommitOverflow&quot;, { fg = M.colors.red })\n\n    M.highlight(&quot;GitHubUserName&quot;, { fg = M.colors.purple, gui = &quot;italic&quot; })\n    M.highlight(&quot;GitHubDate&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;GitHubCommentLength&quot;, { fg = M.colors.comment_grey, gui = &quot;italic&quot; })\n    M.highlight(&quot;GitHubAuthorAssociation&quot;, { fg = M.colors.special_grey, gui = &quot;italic,bold&quot; })\n\n    M.highlight(&quot;Defx_git_Untracked&quot;, { fg = M.colors.red })\n    M.link(&quot;Defx_git_4_Untracked&quot;, &quot;gitcommitUntrackedFile&quot;)\n    M.link(&quot;Defx_git_4_Ignored&quot;, &quot;gitcommitSummary&quot;)\n    M.link(&quot;Defx_git_4_Unknown&quot;, &quot;gitcommitSummary&quot;)\n    M.link(&quot;Defx_git_4_Renamed&quot;, &quot;gitcommitBranch&quot;)\n    M.link(&quot;Defx_git_4_Modified&quot;, &quot;gitcommitUnmergedFile&quot;)\n    M.link(&quot;Defx_git_4_Unmerged&quot;, &quot;diffRemoved&quot;)\n    M.link(&quot;Defx_git_4_Deleted&quot;, &quot;diffRemoved&quot;)\n    M.link(&quot;Defx_git_4_Staged&quot;, &quot;diffAdded&quot;)\n\n    M.highlight(&quot;VimwikiHR&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;VimwikiPre&quot;, { fg = M.colors.cursor_grey })\n    M.highlight(&quot;VimwikiItalic&quot;, { gui = &quot;italic&quot; })\n    M.highlight(&quot;OrgColorTagRed&quot;, { fg = M.colors.red })\n    M.highlight(&quot;OrgColorTagCyan&quot;, { fg = M.colors.cyan })\n    M.highlight(&quot;OrgColorTagGreen&quot;, { fg = M.colors.green })\n    M.highlight(&quot;OrgColorTagBlue&quot;, { fg = M.colors.blue })\n    M.highlight(&quot;OrgColorTagPurple&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;OrgColorTagYellow&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;OrgColorTagOrange&quot;, { fg = M.colors.dark_yellow })\n    M.highlight(&quot;VimwikiDate&quot;, { fg = M.colors.dark_yellow, gui = &quot;bold&quot; })\n    M.highlight(&quot;VimwikiHeaderChar&quot;, { fg = M.colors.comment_grey })\n    M.highlight(&quot;OrgQuote&quot;, { fg = M.colors.bracket_grey, gui = &quot;italic&quot; })\n\n    M.highlight(&quot;Whitespace&quot;, { fg = M.colors.cursor_grey })\n\n    M.link(&quot;gwitcommitNoBranch&quot;, &quot;gitcommitBranch&quot;)\n    M.link(&quot;gitcommitUntracked&quot;, &quot;gitcommitComment&quot;)\n    M.link(&quot;gitcommitDiscarded&quot;, &quot;gitcommitComment&quot;)\n    M.link(&quot;gitcommitSelected&quot;, &quot;gitcommitComment&quot;)\n    M.link(&quot;gitcommitDiscardedArrow&quot;, &quot;gitcommitDiscardedFile&quot;)\n    M.link(&quot;gitcommitSelectedArrow&quot;, &quot;gitcommitSelectedFile&quot;)\n    M.link(&quot;gitcommitUnmergedArrow&quot;, &quot;gitcommitUnmergedFile&quot;)\n\n    M.link(&quot;gitmessengerPopupNormal&quot;, &quot;WinNormalNC&quot;)\n\n    M.highlight(&quot;GitGutterAdd&quot;, { fg = M.colors.green })\n    M.highlight(&quot;GitGutterChange&quot;, { fg = M.colors.dark_yellow })\n    M.highlight(&quot;GitGutterDelete&quot;, { fg = M.colors.red })\n\n    M.highlight(&quot;EchoDocFloat&quot;, { bg = M.colors.dark_black })\n\n    M.highlight(&quot;DiagnosticError&quot;, { fg = M.colors.dark_red, gui = &quot;bold&quot; })\n    M.highlight(&quot;DiagnosticWarn&quot;, { fg = M.colors.dark_yellow, gui = &quot;bold&quot; })\n    M.highlight(&quot;DiagnosticInfo&quot;, { fg = M.colors.cyan, gui = &quot;bold&quot; })\n    M.highlight(&quot;DiagnosticHint&quot;, { fg = M.colors.comment_grey, gui = &quot;bold&quot; })\n    M.highlight(&quot;DiagnosticUnderlineError&quot;, { sp = M.colors.dark_red, gui = &quot;undercurl&quot; })\n    M.highlight(&quot;DiagnosticUnderlineWarn&quot;, { sp = M.colors.dark_yellow, gui = &quot;undercurl&quot; })\n    M.highlight(&quot;DiagnosticUnderlineInfo&quot;, { sp = M.colors.cyan, gui = &quot;undercurl&quot; })\n    M.highlight(&quot;DiagnosticUnderlineHint&quot;, { sp = M.colors.comment_grey, gui = &quot;undercurl&quot; })\n    M.highlight(&quot;FloatBorder&quot;, { fg = M.colors.comment_grey })\n    M.highlight(&quot;FloatBorderDark&quot;, { fg = M.colors.comment_grey, bg = M.colors.dark_black })\n    M.highlight(&quot;FloatShadow&quot;, { bg = M.colors.black, blend = 80 })\n    M.highlight(&quot;FloatShadowThrough&quot;, { bg = M.colors.black, blend = 100 })\n\n    M.highlight(&quot;TSDefinitionUsage&quot;, { gui = &quot;bold&quot; })\n    M.highlight(&quot;TSDefinition&quot;, { gui = &quot;bold&quot; })\n\n    M.highlight(&quot;IndentBlanklineContextChar&quot;, { fg = M.colors.visual_grey, gui = &quot;nocombine&quot; })\n    M.highlight(&quot;IndentBlanklineContextStart&quot;, { sp = M.colors.visual_grey, gui = &quot;underline&quot; })\n    M.highlight(&quot;IndentBlanklineContextSpaceChar&quot;, { gui = &quot;nocombine&quot; })\n\n    M.highlight(&quot;RenamePrompt&quot;, { fg = M.colors.dark_yellow, gui = &quot;bold&quot; })\n    M.highlight(&quot;DiagnosticSource&quot;, { fg = M.colors.cursor_grey, gui = &quot;bold&quot; })\n\n    M.link(&quot;BqfPreviewRange&quot;, &quot;DiffChange&quot;)\n\n    M.link(&quot;Dash&quot;, &quot;markdownBold&quot;)\n\n    M.highlight(&quot;CmpItemAbbr&quot;, { fg = M.colors.white })\n    M.highlight(&quot;CmpItemAbbrDeprecated&quot;, { fg = M.colors.comment_grey })\n    M.highlight(&quot;CmpItemAbbrMatchFuzzy&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;CmpItemMenu&quot;, { fg = M.colors.comment_grey })\n    M.highlight(&quot;CmpItemKindMethod&quot;, { fg = M.colors.blue })\n    M.highlight(&quot;CmpItemKindFunction&quot;, { fg = M.colors.blue })\n    M.highlight(&quot;CmpItemKindVariable&quot;, { fg = M.colors.red })\n    M.highlight(&quot;CmpItemKindConstant&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;CmpItemKindProperty&quot;, { fg = M.colors.red })\n    M.highlight(&quot;CmpItemKindField&quot;, { fg = M.colors.red })\n    M.highlight(&quot;CmpItemKindEnumMember&quot;, { fg = M.colors.cyan })\n    M.highlight(&quot;CmpItemKindText&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;CmpItemKindClass&quot;, { fg = M.colors.dark_yellow })\n    M.highlight(&quot;CmpItemKindInterface&quot;, { fg = M.colors.dark_yellow })\n    M.highlight(&quot;CmpItemKindStruct&quot;, { fg = M.colors.dark_yellow })\n    M.highlight(&quot;CmpItemKindModule&quot;, { fg = M.colors.cyan })\n\n    M.highlight(&quot;LightspeedUnlabeledMatch&quot;, { bg = M.colors.red, fg = M.colors.black, gui = &quot;bold&quot; })\n    M.highlight(&quot;LightspeedLabel&quot;, { fg = M.colors.purple, gui = &quot;bold&quot; })\n    M.highlight(&quot;LightspeedShortcut&quot;, { bg = M.colors.purple, fg = M.colors.black, gui = &quot;bold&quot; })\n\n    M.highlight(&quot;org_hyperlink&quot;, { fg = M.colors.blue, gui = &quot;underline&quot; })\n    M.highlight(&quot;org_verbatim&quot;, { fg = M.colors.bracket_grey, gui = &quot;italic&quot; })\n    M.highlight(&quot;org_code&quot;, { fg = M.colors.yellow, bg = M.colors.dimm_black })\n    M.highlight(&quot;OrgTSTable&quot;, { bg = M.colors.dark_cursor_grey })\n\n    M.highlight(&quot;CodeBlock&quot;, { bg = M.colors.dimm_black })\n    M.highlight(&quot;Quote&quot;, { fg = M.colors.dark_yellow })\n\n    M.highlight(&quot;NotifyERRORBorder&quot;, { fg = M.colors.red })\n    M.highlight(&quot;NotifyWARNBorder&quot;, { fg = M.colors.dark_yellow })\n    M.highlight(&quot;NotifyINFOBorder&quot;, { fg = M.colors.green })\n    M.highlight(&quot;NotifyDEBUGBorder&quot;, { fg = M.colors.comment_grey })\n    M.highlight(&quot;NotifyTRACEBorder&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;NotifyERRORIcon&quot;, { fg = M.colors.red })\n    M.highlight(&quot;NotifyWARNIcon&quot;, { fg = M.colors.dark_yellow })\n    M.highlight(&quot;NotifyINFOIcon&quot;, { fg = M.colors.green })\n    M.highlight(&quot;NotifyDEBUGIcon&quot;, { fg = M.colors.comment_grey })\n    M.highlight(&quot;NotifyTRACEIcon&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;NotifyERRORTitle&quot;, { fg = M.colors.red })\n    M.highlight(&quot;NotifyWARNTitle&quot;, { fg = M.colors.dark_yellow })\n    M.highlight(&quot;NotifyINFOTitle&quot;, { fg = M.colors.green })\n    M.highlight(&quot;NotifyDEBUGTitle&quot;, { fg = M.colors.comment_grey })\n    M.highlight(&quot;NotifyTRACETitle&quot;, { fg = M.colors.purple })\n\n    M.highlight(&quot;NavicSeparator&quot;, { fg = M.colors.comment_grey, bg = M.colors.dark_black })\n\n    M.highlight(&quot;NavicIconsFunction&quot;, { fg = M.colors.green, bg = M.colors.dark_black })\n    M.highlight(&quot;NavicIconsMethod&quot;, { fg = M.colors.green, bg = M.colors.dark_black })\n    M.highlight(&quot;NavicIconsVariable&quot;, { fg = M.colors.blue, bg = M.colors.dark_black })\n    M.highlight(&quot;NavicIconsConstant&quot;, { fg = M.colors.purple, bg = M.colors.dark_black })\n    M.highlight(&quot;NavicIconsProperty&quot;, { fg = M.colors.blue, bg = M.colors.dark_black })\n    M.highlight(&quot;NavicIconsStruct&quot;, { fg = M.colors.purple, bg = M.colors.dark_black })\n    M.highlight(&quot;NavicIconsInterface&quot;, { fg = M.colors.cyan, bg = M.colors.dark_black })\n    M.highlight(&quot;NavicIconsEnum&quot;, { fg = M.colors.yellow, bg = M.colors.dark_black })\n    M.highlight(&quot;NavicIconsField&quot;, { fg = M.colors.yellow, bg = M.colors.dark_black })\n    M.highlight(&quot;NavicIconsClass&quot;, { fg = M.colors.purple, bg = M.colors.dark_black })\n\n    M.highlight(&quot;NavicText&quot;, { fg = M.colors.comment_grey, bg = M.colors.dark_black })\n\n    M.highlight(&quot;CCovered&quot;, { fg = M.colors.dark_green })\n    -- M.highlight(&quot;CUncovered&quot;, { fg = M.colors.red })\n\n    M.highlight(&quot;DapUIScope&quot;, { fg = M.colors.blue })\n    M.highlight(&quot;DapUIType&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;DapUIVariable&quot;, { fg = M.colors.red })\n    M.highlight(&quot;DapUIDecoration&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;DapUIModifiedValue&quot;, { fg = M.colors.dark_yellow, gui = &quot;bold&quot; })\n    M.highlight(&quot;DapUIThread&quot;, { fg = M.colors.green })\n    M.highlight(&quot;DapUIStoppedThread&quot;, { fg = M.colors.cyan })\n    M.highlight(&quot;DapUISource&quot;, { fg = M.colors.green })\n    M.highlight(&quot;DapUILineNumber&quot;, { fg = M.colors.dark_yellow })\n    M.highlight(&quot;DapUIFloatBorder&quot;, { fg = M.colors.comment_grey })\n    M.highlight(&quot;DapUIWatchesHeader&quot;, { fg = M.colors.cyan })\n    M.highlight(&quot;DapUIWatchesEmpty&quot;, { fg = M.colors.red })\n    M.highlight(&quot;DapUIWatchesValue&quot;, { fg = M.colors.green })\n    M.highlight(&quot;DapUIWatchesError&quot;, { fg = M.colors.dark_red })\n    M.highlight(&quot;DapUIWatchesFrame&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;DapUIBreakpointsPath&quot;, { fg = M.colors.green })\n    M.highlight(&quot;DapUIBreakpointsInfo&quot;, { fg = M.colors.green })\n    M.highlight(&quot;DapUIBreakpointsCurrentLine&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;DapUIBreakpointsLine&quot;, { fg = M.colors.cyan })\n    M.highlight(&quot;DapUIFrameName&quot;, { fg = M.colors.red })\n\n    M.highlight(&quot;OctoEditable&quot;, { bg = M.colors.dimm_black })\n\n    M.highlight(&quot;SjLabel&quot;, { fg = M.colors.black, bg = M.colors.purple, gui = &quot;bold&quot; })\n    M.highlight(&quot;SjSearch&quot;, { fg = M.colors.green })\n\n    M.highlight(&quot;PackageInfoUpToDateVersion&quot;, { fg = M.colors.cyan })\n    M.highlight(&quot;PackageInfoOutdatedVersion&quot;, { fg = M.colors.dark_yellow })\n\n    M.highlight(&quot;NeotestUnknown&quot;, { fg = M.colors.comment_grey })\n    M.highlight(&quot;NeotestSkipped&quot;, { fg = M.colors.yellow })\n    M.highlight(&quot;NeotestRunning&quot;, { fg = M.colors.purple })\n    M.highlight(&quot;NeotestPassed&quot;, { fg = M.colors.green })\n    M.highlight(&quot;NeotestFailed&quot;, { fg = M.colors.dark_red })\nend\n\nreturn M\n\n-- ===============================================\n-- config/nvim-tree.lua\n-- ===============================================\n\n-- 侧边文件树\nvim.opt.termguicolors = true\n\nrequire(&quot;nvim-tree&quot;).setup({\n    sort_by = &quot;case_sensitive&quot;,\n    hijack_cursor = true,\n    system_open = {\n        cmd = &quot;open&quot;,\n    },\n    view = {\n        width = 30,\n        number = true,\n        adaptive_size = false,\n    },\n    renderer = {\n        group_empty = true,\n        -- 图标\n        icons = {\n            show = {\n                git = true,\n                file = true,\n                folder = true,\n                folder_arrow = true,\n            },\n            glyphs = {\n                bookmark = &quot; &quot;,\n                folder = {\n                    arrow_closed = &quot;⏵&quot;,\n                    arrow_open = &quot;⏷&quot;,\n                },\n                git = {\n                    unstaged = &quot;✗&quot;,\n                    staged = &quot;✓&quot;,\n                    unmerged = &quot;⌥&quot;,\n                    renamed = &quot;➜&quot;,\n                    untracked = &quot;★&quot;,\n                    deleted = &quot;⊖&quot;,\n                    ignored = &quot;◌&quot;,\n                },\n            },\n        },\n        special_files = { &quot;Cargo.toml&quot;, &quot;Makefile&quot;, &quot;README.md&quot;, &quot;readme.md&quot; },\n    },\n    filters = {\n        dotfiles = true,\n    },\n})命令补全lua-- ===============================================\n-- core/plugins/which-key.lua\n-- ===============================================\n-- 弹出一个窗口, 显示所有可能的绑定的快捷键\nreturn {\n    {\n        &#39;folke/which-key.nvim&#39;,\n        config = function()\n            require(&#39;which-key&#39;).setup()\n        end\n    }\n}全局设置插件lua-- ===============================================\n-- core/plugins/neoconf.lua\n-- ===============================================\nreturn {\n    {\n        &quot;folke/neoconf.nvim&quot;,\n        cmd = &quot;Neoconf&quot;\n    },\n}全局搜索插件需要先安装 ripgrep\nlua-- ===============================================\n-- core/plugins/telescope.lua\n-- ===============================================\nreturn {\n    {\n        &#39;nvim-telescope/telescope.nvim&#39;,\n        tag = &#39;0.1.1&#39;,\n        dependencies = { &#39;nvim-lua/plenary.nvim&#39; },\n        config = function()\n            require(&#39;telescope&#39;).setup {}\n        end\n    }\n}\n\n-- ===============================================\n-- config/telescope.lua\n-- ===============================================\nrequire(&#39;telescope&#39;).setup {\n    defaults = {\n        layout_config = {\n            center = {\n                height = 0.6,\n                preview_cutoff = 80,\n                prompt_position = &quot;top&quot;,\n                width = 0.5\n            },\n        },\n    },\n    pickers = {\n        find_files = {\n            theme = &quot;dropdown&quot;,\n        }\n    },\n    extensions = {\n        fzf = {\n            fuzzy = true,                    -- false will only do exact matching\n            override_generic_sorter = true,  -- override the generic sorter\n            override_file_sorter = true,     -- override the file sorter\n            case_mode = &quot;smart_case&quot;,        -- or &quot;ignore_case&quot; or &quot;respect_case&quot;\n        }\n    }\n}其他的一些可选插件lua-- ===============================================\n-- core/plugins/effect.lua\n-- ===============================================\n-- 显示光标所在的行\nreturn {\n    {\n        &#39;edluffy/specs.nvim&#39;,\n        config = function()\n            require(&#39;specs&#39;).setup{\n                show_jumps  = true,\n                min_jump = 30,\n                popup = {\n                    delay_ms = 0, -- delay before popup displays\n                    inc_ms = 10, -- time increments used for fade/resize effects\n                    blend = 10, -- starting blend, between 0-100 (fully transparent), see :h winblend\n                    width = 10,\n                    winhl = &quot;PMenu&quot;,\n                    fader = require(&#39;specs&#39;).sinus_fader,\n                    resizer = require(&#39;specs&#39;).shrink_resizer\n                },\n                ignore_filetypes = {},\n                ignore_buftypes = {\n                    nofile = true,\n                },\n            }\n        end,\n    },\n}键盘重映射为了方便操作, 可以将一些常用快捷键进行重映射\n新建 core/keymap.lua, 随后可以选择在 core/base.lua 中加载它\nlua-- 键盘映射\nlocal map = vim.api.nvim_set_keymap\nlocal opts = { noremap = true, silent = true }\n-- map(&#39;模式&#39;,&#39;按键&#39;,&#39;映射为XX&#39;,opt)\n-- map(&#39;n/i/v&#39;,&#39;&lt;leader已被init映射为空格&gt;xx&#39;,&#39;&lt;Cmd&gt;xx&lt;CR&gt;&#39;,opts)\n\n-- 一些习惯性按键\n-- i 模式下将 qq 映射为 esc 键,键入q等待后可再次输入q\nmap(&#39;i&#39;, &#39;qq&#39;, &#39;&lt;Esc&gt;&#39;, opts)\n-- 快速上下跳转9行\nmap(&#39;n&#39;, &#39;&lt;C-u&gt;&#39;, &#39;9k&#39;, opts)\nmap(&#39;n&#39;, &#39;&lt;C-d&gt;&#39;, &#39;9j&#39;, opts)\n\n-- 侧边文件树\nmap(&#39;n&#39;, &#39;&lt;leader&gt;t&#39;, &#39;:NvimTreeToggle&lt;CR&gt;&#39;, opts)\n\n-- 分屏相关\nmap(&quot;n&quot;, &quot;sv&quot;, &quot;:vsp&lt;CR&gt;&quot;, opts) -- 垂直分屏\nmap(&quot;n&quot;, &quot;sh&quot;, &quot;:sp&lt;CR&gt;&quot;, opts) -- 水平分屏\nmap(&quot;n&quot;, &quot;sc&quot;, &quot;&lt;C-w&gt;c&quot;, opts) -- 关闭当前分屏\nmap(&quot;n&quot;, &quot;so&quot;, &quot;&lt;C-w&gt;o&quot;, opts) -- 关闭其他分屏 close others\n\n-- 窗口转跳相关\nmap(&quot;n&quot;, &quot;&lt;A-h&gt;&quot;, &quot;&lt;C-w&gt;h&quot;, opts)\nmap(&quot;n&quot;, &quot;&lt;A-j&gt;&quot;, &quot;&lt;C-w&gt;j&quot;, opts)\nmap(&quot;n&quot;, &quot;&lt;A-k&gt;&quot;, &quot;&lt;C-w&gt;k&quot;, opts)\nmap(&quot;n&quot;, &quot;&lt;A-l&gt;&quot;, &quot;&lt;C-w&gt;l&quot;, opts)\n-- 一些类似Windows习惯的按键\n-- map(&#39;n&#39;, &#39;&lt;C-d&gt;&#39;, &#39;&lt;dd&gt;&#39;, opts)\n-- map(&#39;n&#39;, &#39;&lt;C-c&gt;&#39;, &#39;&lt;yy&gt;&#39;, opts)\n-- map(&#39;n&#39;, &#39;&lt;C-p&gt;&#39;, &#39;&lt;p&gt;&#39;, opts)\n\n-- barbar buffer标签栏按键\n-- Move to previous/next\nmap(&#39;n&#39;, &#39;&lt;A-,&gt;&#39;, &#39;&lt;Cmd&gt;BufferPrevious&lt;CR&gt;&#39;, opts)\nmap(&#39;n&#39;, &#39;&lt;A-.&gt;&#39;, &#39;&lt;Cmd&gt;BufferNext&lt;CR&gt;&#39;, opts)\n-- Re-order to previous/next\nmap(&#39;n&#39;, &#39;&lt;A-&lt;&gt;&#39;, &#39;&lt;Cmd&gt;BufferMovePrevious&lt;CR&gt;&#39;, opts)\nmap(&#39;n&#39;, &#39;&lt;A-&gt;&gt;&#39;, &#39;&lt;Cmd&gt;BufferMoveNext&lt;CR&gt;&#39;, opts)\n-- Goto buffer in position...\nmap(&#39;n&#39;, &#39;&lt;A-1&gt;&#39;, &#39;&lt;Cmd&gt;BufferGoto 1&lt;CR&gt;&#39;, opts)\nmap(&#39;n&#39;, &#39;&lt;A-2&gt;&#39;, &#39;&lt;Cmd&gt;BufferGoto 2&lt;CR&gt;&#39;, opts)\nmap(&#39;n&#39;, &#39;&lt;A-3&gt;&#39;, &#39;&lt;Cmd&gt;BufferGoto 3&lt;CR&gt;&#39;, opts)\nmap(&#39;n&#39;, &#39;&lt;A-4&gt;&#39;, &#39;&lt;Cmd&gt;BufferGoto 4&lt;CR&gt;&#39;, opts)\nmap(&#39;n&#39;, &#39;&lt;A-5&gt;&#39;, &#39;&lt;Cmd&gt;BufferGoto 5&lt;CR&gt;&#39;, opts)\nmap(&#39;n&#39;, &#39;&lt;A-6&gt;&#39;, &#39;&lt;Cmd&gt;BufferGoto 6&lt;CR&gt;&#39;, opts)\nmap(&#39;n&#39;, &#39;&lt;A-7&gt;&#39;, &#39;&lt;Cmd&gt;BufferGoto 7&lt;CR&gt;&#39;, opts)\nmap(&#39;n&#39;, &#39;&lt;A-8&gt;&#39;, &#39;&lt;Cmd&gt;BufferGoto 8&lt;CR&gt;&#39;, opts)\nmap(&#39;n&#39;, &#39;&lt;A-9&gt;&#39;, &#39;&lt;Cmd&gt;BufferGoto 9&lt;CR&gt;&#39;, opts)\nmap(&#39;n&#39;, &#39;&lt;A-0&gt;&#39;, &#39;&lt;Cmd&gt;BufferLast&lt;CR&gt;&#39;, opts)\n-- Pin/unpin buffer\nmap(&#39;n&#39;, &#39;&lt;A-p&gt;&#39;, &#39;&lt;Cmd&gt;BufferPin&lt;CR&gt;&#39;, opts)\n-- Close buffer\nmap(&#39;n&#39;, &#39;&lt;A-c&gt;&#39;, &#39;&lt;Cmd&gt;BufferClose&lt;CR&gt;&#39;, opts)\n-- Wipeout buffer\n--                 :BufferWipeout\n-- Close commands\n--                 :BufferCloseAllButCurrent\n--                 :BufferCloseAllButPinned\n--                 :BufferCloseAllButCurrentOrPinned\n--                 :BufferCloseBuffersLeft\n--                 :BufferCloseBuffersRight\n-- Magic buffer-picking mode\nmap(&#39;n&#39;, &#39;&lt;C-p&gt;&#39;, &#39;&lt;Cmd&gt;BufferPick&lt;CR&gt;&#39;, opts)\n-- 标签自动排序\nmap(&#39;n&#39;, &#39;&lt;leader&gt;bb&#39;, &#39;&lt;Cmd&gt;BufferOrderByBufferNumber&lt;CR&gt;&#39;, opts)\nmap(&#39;n&#39;, &#39;&lt;leader&gt;bd&#39;, &#39;&lt;Cmd&gt;BufferOrderByDirectory&lt;CR&gt;&#39;, opts)\nmap(&#39;n&#39;, &#39;&lt;leader&gt;bl&#39;, &#39;&lt;Cmd&gt;BufferOrderByLanguage&lt;CR&gt;&#39;, opts)\nmap(&#39;n&#39;, &#39;&lt;leader&gt;bw&#39;, &#39;&lt;Cmd&gt;BufferOrderByWindowNumber&lt;CR&gt;&#39;, opts)\n\n-- 切换aerial大纲是否显示\nmap(&#39;n&#39;, &#39;&lt;leader&gt;a&#39;, &#39;&lt;cmd&gt;AerialToggle!&lt;CR&gt;&#39;, opts)\n\n-- telescope\nmap(&#39;n&#39;, &#39;&lt;leader&gt;ff&#39;, &#39;:Telescope find_files&lt;CR&gt;&#39;, opts)\nmap(&#39;n&#39;, &#39;&lt;leader&gt;fw&#39;, &#39;:Telescope live_grep&lt;CR&gt;&#39;, opts)\n\n-- specs.nvim 定位光标\nmap(&#39;n&#39;, &#39;ss&#39;, &#39;:lua require(&quot;specs&quot;).show_specs()&lt;CR&gt;&#39;, opts)","slug":"2022-01-18","date":"2022-01-17T16:02:09.000Z","categories_index":"Share","tags_index":"Neovim,Lua","author_index":"芳塔洛斯"},{"id":"6fa92a5a1866681cec9c47f16fa37ac2","title":"初识 Rust(7) | 生命周期, 格式化输出与文件 IO","content":"生命周期生命周期是 Rust 中的一个特殊概念, 简而言之, 它标注了作用域的范围. 早期的 Rust 需要手动标注所有生命周期, 但后来人们发现有一些生命周期格式经常重复性出现, 于是 Rust 就制定了一些规则, 在非必要是通过编译器推理消除生命周期参数\n生命周期的标注通常是单引号 &#39; 加上一个小写字母, 下面一段会造成悬垂引用的代码, 让我们加上生命周期标注看看为什么\nrust{\n    let r;                // ---------+-- &#39;a\n                          //          |\n    {                     //          |\n        let x = 5;        // -+-- &#39;b  |\n        r = &amp;x;           //  |       |\n    }                     // -+       |\n                          //          |\n    println!(&quot;r: {}&quot;, r); //          |\n}                         // ---------+r 的生命周期范围是 &#39;a, x 的生命周期范围是 &#39;b, 很明显, x 的生命周期更短, 我们将 x 的引用赋值给 r, 当 x 的生命结束时, r 依然存在, 但此时这个被引用的 x 已经被 Drop 了, 因此就会报错\n手动标注生命周期与生命周期消除生命周期的标注只发生在引用中, 使用前像泛型那样须要事先声明, 使用时标注需要紧随 &amp; 操作符, 各一个空格后跟上具体的引用类型, 而声明时不需要\nrustfn func&lt;&#39;a&gt;(arg: &amp;&#39;a str) -&gt; &amp;&#39;a str {\n\n}\n\nstruct Strs&lt;&#39;a&gt; {\n    strs: &amp;&#39;a str,\n}就像我们说过的, 生命周期的格式经常重复, 通过实践我们可以发现, 有些生命周期标注就没有存在的必要, 因此我们制定了三条规则, 满足以下条件的, 即使删除生命周期, 编译器也可以进行推导\n\n每一个引用都有自己的生命周期\n例如: fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32), fn foo&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a i32, y: &amp;&#39;b i32)\n\n\n若只有一个输入生命周期, 那么该生命周期会被赋给所有的输出生命周期\n例如 fn foo(x: &amp;i32) -&gt; &amp;i32, x 的生命周期会被自动赋给返回值 &amp;i32, 即 fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32\n\n\n若存在多个输入生命周期, 且其中一个是 &amp;self 或 &amp;mut self, 则 &amp;self 的生命周期被赋给所有的输出生命周期\n拥有 &amp;self参数, 说明该函数是一个 方法, 该规则让方法的使用便利度大幅提升\n若一个方法，它的返回值的生命周期就是跟参数 &amp;self 的不一样, 这时答案就很简单了: 手动标注生命周期. 因为这些规则只是当你没标注时编译器默认加上的\n\n\n\n让我们通过模拟编译器理解一下这些规则\nrust// 单引用参数\nfn foo(s: &amp;str) -&gt; &amp;str\n// 首先, 为每个参数标注一个生命周期\n\nfn foo&lt;&#39;a&gt;(s: &amp;&#39;a str) -&gt; &amp;str\n// 函数只有一个输入生命周期, 被赋予所有的输出生命周期\n\nfn foo&lt;&#39;a&gt;(s: &amp;&#39;a str) -&gt; &amp;&#39;a str\n// 编译器自动为返回值添加生命周期, 检查通过\n\n// 多引用参数\nfn bar(x: &amp;str, y: &amp;str) -&gt; &amp;str\n// 首先, 为每个参数标注一个生命周期\n\nfn bar&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a str, y: &amp;&#39;b str) -&gt; &amp;str\n// 第二条规则失效, 因为输入生命周期有两个\n// 第三条规则也不符合\n// 编译器依然无法为返回值标注合适的生命周期\n//标错并提示我们需要手动标注生命周期注意: 通过函数签名指定生命周期参数只是给编译器的提示性标注, 并不能真正改变变量的作用域, 而是告诉编译器当不满足此约束条件时, 就拒绝编译通过, 比如下面的代码会报错\nrustfn return_str&lt;&#39;a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;&#39;a str {\n    let result = String::from(&quot;string&quot;);\n    result.as_str()\n}不总是靠谱的生命周期检查rust#[derive(Debug)]\nstruct Foo;\n\nimpl Foo {\n    fn take_mutable(&amp;mut self) -&gt; &amp;Self {\n        &amp;*self\n    }\n    fn take_immutable(&amp;self) {}\n}\n\nfn main() {\n    let mut foo = Foo;\n    let bar = foo.take_mutable();\n    foo.take_immutable();\n    println!(&quot;{:?}&quot;, bar);\n}虽然 take_mutable 方法借用了 &amp;mut self, 但是它最终返回的是一个 &amp;Self, 因此理论上带来的结果只是一个不可变借用, 同时 take_immutable 也进行了不可变借用, 那根据借用规则, 这段代码是合理的, 只发生了两次不可变借用. 然而却无法编译通过, 编译器仍然会固执的认为 take_mutable 借用了可变的 foo, 所以下面不可以再发生不可变借用. 但是按照逻辑, 可变借用的作用域仅在 take_mutable 内, 离开该作用域回到 main 函数后应该已经不存在了\n对于这个反直觉的事情, 可以用生命周期来解释\nruststruct Foo;\n\nimpl Foo {\n    fn take_mutable&lt;&#39;a&gt;(&amp;&#39;a mut self) -&gt; &amp;&#39;a Self {\n        &amp;&#39;a *self\n    }\n    fn take_immutable&lt;&#39;a&gt;(&amp;&#39;a self) {}\n}\n\nfn main() {\n    &#39;b: {\n        let mut foo: Foo = Foo;\n        &#39;c: {\n            let bar: &amp;&#39;c Foo = Foo::take_mutable::&lt;&#39;c&gt;(&amp;&#39;c mut foo);\n            &#39;d: {\n                Foo::take_immutable::&lt;&#39;d&gt;(&amp;&#39;d foo);\n            }\n            println!(&quot;{:?}&quot;, bar);\n        }\n    }\n}我们发现 &amp;mut foo 和 bar 的生命周期都是 &#39;c. 还记得 生命周期消除规则 第三条吗, 这导致了 take_mutable 方法中参数 &amp;mut self 和返回值 &amp;Self 拥有相同的生命周期, 因此, 若返回值的生命周期在 main 函数有效, 那 &amp;mut self 的借用也是在 main 函数有效, 于是就违背了可变借用与不可变借用不能同时存在的规则, 最终导致了编译错误\n实际上, 上述代码逻辑上完全正确, 但是因为生命周期系统的的死板, 导致了编译错误, 不幸的是, 截止到现在, 遇到这种因为生命周期系统的不靠谱导致的编译错误没有什么特别好的解决办法, 基本只能去修改代码. 期待后续堆生命周期系统继续完善, 让它足够聪明来理解这个问题\n无界生命周期Unsafe 块经常会凭空产生引用或生命周期, 这些生命周期被称为是 Unbound (无界) 的\n比如解引用一个 Raw Pointer (裸指针), 它并没有任何生命周期, 然后通过 unsafe 关键字操作后, 它被进行了解引用, 变成了一个 Rust 的标准引用类型, 该类型必须要有生命周期, 也就是 &#39;a, 这个生命周期就是凭空产生的, 因为输入参数根本就没有这个生命周期\nrustfn foo&lt;&#39;a, T&gt;(x: *const T) -&gt; &amp;&#39;a T {\n    unsafe {\n        &amp;*x\n    }\n}这种生命周期由于没有受到任何约束, 因此它想要多大就多大, 它实际上比 &#39;static 还要强大. 例如 &amp;&#39;static &amp;&#39;a T 是无效类型, 但是无界生命周期 &amp;&#39;unbounded &amp;&#39;a T 会被视为 &amp;&#39;a &amp;&#39;a T 从而通过编译检查, 因为它的大小完全取决于需要它多大\n因此我们要尽量避免这种无界生命周期. 最简单方式就是在函数声明中运用生命周期消除规则. 若一个输出生命周期被消除了, 那么必定因为有一个输入生命周期与之对应\n生命周期约束 HRTB生命周期约束跟特征约束类似, 都是通过形如 &#39;a: &#39;b 的语法, 来说明两个生命周期的长短关系, 比如这里就是 &#39;a &gt;= &#39;b\n被引用者的生命周期必须要比引用长, 比如\nruststruct Ref&lt;&#39;a, T: &#39;a&gt; {\n    r: &amp;&#39;a T\n}因为 r 引用了 T, 因此 r 的生命周期 &#39;a 必须要比 T 的生命周期更短. 在早期版本的 Rust 中上述标注是必须的, 而在新版本中, 编译器可以自动推导 T: ‘a 类型的约束, 因此我们只需这样写即可\nruststruct Ref&lt;&#39;a, T&gt; {\n    r: &amp;&#39;a T\n}实际上这也被称作 结构体生命周期消除\nImpl 块生命周期消除rustimpl&lt;&#39;a&gt; Foo for Bar&lt;&#39;a&gt; {\n    // 内部实际上没有用到 &#39;a\n}如果发现写出了这样的代码, 那实际上可以改写成下面这样\nrustimpl Foo for Bar&lt;&#39;_&gt; {\n    // Methods ...\n}&#39;_ 生命周期表示 BufReader 有一个不使用的生命周期, 我们可以忽略它, 无需为它创建一个名称, 那既然用不到为何还要写出来呢? 别忘了, 生命周期参数也是类型的一部分, 因此 BufReader&lt;&#39;a&gt; 是一个完整的类型, 在实现它的时候, 你不能把 &#39;a 给丢了\n闭包的生命周期消除规则先来看一段简单的代码\nrustfn foo(x: &amp;i32) -&gt; &amp;i32 { x }\nlet bar = |x: &amp;i32| -&gt; &amp;i32 { x };乍一看, 这不一样吗? 编译下试试? 编译不通过! 错误原因是编译器无法推测返回的引用和传入的引用谁活得更久\n回忆一下生命周期消除规则: 如果函数参数中只有一个引用类型, 那该引用的生命周期会被自动分配给所有的返回引用. 完全一致, 而且 foo 函数也没有报错, 那这是为什么呢?\n这是因为对于函数的生命周期而言, 它的消除规则之所以能生效是因为它的 生命周期完全体现在签名的引用类型 上, 在函数体中无需任何体现, 因此编译器可以做各种编译优化, 也很容易根据参数和返回值进行生命周期的分析, 最终得出消除规则\n可闭包的生命周期分散在参数和闭包函数体中, 编译器就必须深入到函数体中, 去分析和推导, 复杂度因此急剧提升\n日常遇到这个问题, 还是老老实实用函数吧. 这个问题很难解决, 但不是无法解决, 比如通过使用 Fn trait\nrustfn fun&lt;T, F: Fn(&amp;T) -&gt; &amp;T&gt;(f: F) -&gt; F {\n   f\n}\nlet closure_slision = fun(|x: &amp;i32| -&gt; &amp;i32 { x });NLL (Non-Lexical Lifetime)引用的生命周期正常来说应该从借用开始一直持续到作用域结束, 但是这种规则会让多引用共存的情况变得更复杂. 好在新版 Rust 提供了 NLL, 我们在之前已经提过这个概念, 这里再解释一下: 引用的生命周期从借用处开始, 一直持续到最后一次使用的地方\n再来看一段关于 NLL 的代码解释\nrustlet mut u = 0i32;\nlet mut v = 1i32;\nlet mut w = 2i32;\n\n// lifetime of `a` = α ∪ β ∪ γ\nlet mut a = &amp;mut u;     // --+ α. lifetime of `&amp;mut u`  --+ lexical &quot;lifetime&quot; of `&amp;mut u`,`&amp;mut u`, `&amp;mut w` and `a`\nuse(a);                 //   |                            |\n*a = 3; // &lt;-----------------+                            |\n...                     //                                |\na = &amp;mut v;             // --+ β. lifetime of `&amp;mut v`    |\nuse(a);                 //   |                            |\n*a = 4; // &lt;-----------------+                            |\n...                     //                                |\na = &amp;mut w;             // --+ γ. lifetime of `&amp;mut w`    |\nuse(a);                 //   |                            |\n*a = 5; // &lt;-----------------+ &lt;--------------------------+这段代码一目了然, a 有三段生命周期：α, β, γ, 每一段生命周期都随着当前值的最后一次使用而结束\n再借用以 NLL 为基础, 让我们再了解一个高级概念: Reborrow (再借用)\n直接先上码\nrust#[derive(Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Point {\n    fn uodate(&amp;mut self, x: i32, y: i32) {\n        self.x = x;\n        self.y = y;\n    }\n}\n\nfn main() {\n    let mut p = Point { x: 0, y: 0 };\n    let r = &amp;mut p;\n    let rr: &amp;Point = &amp;*r;\n\n    println!(&quot;{:?}&quot;, rr);\n    r.update(10, 10);\n    println!(&quot;{:?}&quot;, r);\n}乍一看, 同时有了可变引用 r 和不可变引用 rr, 这不是违反了借用规则吗? 但实际上并没有, 因为 rr 是对 r 的再借用\nrustlet mut p = Point { x: 0, y: 0 };\nlet r = &amp;mut p;\n// Reborrow! 此时借用 r 与 r 借用 p 不冲突\nlet rr: &amp;Point = &amp;*r;\n// rr 最后一次使用在这里, 期间我们并没有使用原来的借用 r , 因此不会报错, 根据 NLL, rr 在这里离开作用域\nprintln!(&quot;{:?}&quot;, rr);\n// rr 已 Drop, 使用 r 完全没有问题\nr.move_to(10, 10);\nprintln!(&quot;{:?}&quot;, r);&amp;’static 和 T: ‘static&#39;static 在 Rust 中是相当常见的, 例如字符串字面值, 特征对象就具有 &#39;static 生命周期. 除了 &amp;&#39;static 有时我们还可以把 &#39;static 作为生命周期约束, 比如 T: Display + &#39;static\n那么问题来了, 这两者有什么区别吗?\n&amp;’static&amp;&#39;static 对于生命周期有着非常强的要求: 这个引用必须要活到程序结束\n对于字符串字面量来说, 它直接被打包到二进制文件中, 永远不会被 Drop, 因此它能跟程序活得一样久, 自然它的生命周期是 &#39;static, 这针对的仅仅是引用, 而不是持有该引用的变量, 变量还是要该 Drop 就 Drop 的\nrustuse std::{slice::from_raw_parts, str::from_utf8_unchecked};\n\nfn get_memory_location() -&gt; (usize, usize) {\n    // “Hello World” 是字符串字面量, 因此它的生命周期是 `&#39;static`\n    // 但持有它的变量 string 的生命周期完全取决于作用域\n    let string = &quot;Hello World!&quot;;\n    let pointer = string.as_ptr() as usize;\n    let length = string.len();\n    (pointer, length)\n    // string 被 Drop, 但其对应的数据依然存在\n}\n\nfn get_str_at_location(pointer: usize, length: usize) -&gt; &amp;&#39;static str {\n    unsafe { from_utf8_unchecked(from_raw_parts(pointer as *const u8, length)) }\n}\n\nlet (pointer, length) = get_memory_location();\nlet message = get_str_at_location(pointer, length);\nprintln!(\n    &quot;The {} bytes at 0x{:X} stored: {}&quot;,\n    length, pointer, message\n);T: ‘static比起 &amp;&#39;static, 这种形式的约束就有些复杂了\n首先, 在以下两种情况下, T: &#39;static 对 T 的约束与 &amp;&#39;static 有相同的意义\nrustuse std::fmt::Debug;\n\nfn print&lt;T: Debug + &#39;static&gt;( input: T) {\n    println!(&quot;&#39;static value passed in is: {:?}&quot;, input);\n}\n\n// 或者 impl 类型\n// fn print( input: impl Debug + &#39;static ) {\n//     println!(&quot;&#39;static value passed in is: {:?}&quot;, input);\n// }\n\nfn main() {\n    let i = 0;\n\n    print(&amp;i);\n}这会报错, 原因很简单: &amp;i 的生命周期无法满足 ‘static 的约束\n但只需要小小的修改一下函数签名\nrust// print_impl 同理\nfn print&lt;T: Debug + &#39;static&gt;( input: &amp;T) {\n    println!(&quot;&#39;static value passed in is: {:?}&quot;, input);\n}居然就修好了, 这是因为我们约束的是 T, 但使用的是 &amp;T, 因此编译器不会检查 T 的约束, 只要确保 &amp;T 的生命周期符合规则即可, 而这段代码显然是符合的. 这也说明了 &#39;static 这个约束有多么脆弱\n那么 &#96;&#96;static到底针对谁, 是&amp;’static&#96; 这个引用还是该引用指向的数据活得跟程序一样久呢\n答案是引用指向的数据, 而引用本身是要遵循其作用域范围的, 就像这个简单的例子\nrust{\n    let static_str = &quot;I&#39;m static&quot;;\n    println!(&quot;{}&quot;, static_str);\n    // 该变量被 Drop, 但是数据依然存在\n}\nprintln!(&quot;{}&quot;, static_str);最后, 一个经验是: 如果你需要添加 &amp;’static 来让代码工作, 那很可能是设计上出问题了\n格式化输出宏在上一篇文章我们一上来就接触到了一个在其它语言初学中不会上来就学的东西 — 宏\n格式化输出都需要宏可见 Rust 是比较依赖宏的语言\nRust 的宏基于 AST 语法树而非 C++ 中简单的字符串替换, 所以更加强大, 甚至可以扩展 Rust 自身的 “语法”\n将字符打印到控制台的操作由 std::fmt 里面的一系列宏来处理:\n\nformat!: 格式化一系列字符串和参数为 String\nprint!: 与 format! 类似, 但将最终结果输出到控制台标准输出\nprintln!: 与 print! 类似, 但输出结果追加一个换行符\neprint!: 与 format! 类似, 但将文本输出到控制台标准错误\neprintln!: 与 eprint! 类似, 但输出结果追加一个换行符\n\n之前的文章中我们也进行了许多打印操作, 但 println! 宏远比你想象的强大得多\nrustfn main() {\n    // `{}` 会被任意变量内容所替换\n    // 变量内容会转化成字符串\n    println!(&quot;{} days&quot;, 31);\n\n    // 不加后缀的话, 31 就自动成为 i32 类型\n    // 你可以添加后缀来改变 31 的类型\n\n    // 用变量替换字符串有多种写法\n    // 比如可以使用位置参数\n    println!(&quot;{0}, this is {1}. {1}, this is {0}&quot;, &quot;A&quot;, &quot;B&quot;);\n\n    // 可以使用命名参数\n    println!(\n        &quot;{name} {age} {id}&quot;,\n        name=&quot;A&quot;,\n        age=12,\n        id=123\n    );\n\n    // 可以在 `:` 后面指定特殊的格式\n    println!(&quot;{} 的二进制是 {:b}&quot;, 10, 10);\n\n    // 你可以按指定宽度来右对齐文本\n    // 下面语句输出 &quot;     1&quot;, 5 个空格后面连着 1\n    println!(&quot;{number:&gt;width$}&quot;, number=1, width=6);\n\n    // 你可以在数字左边补 0. 下面语句输出 &quot;000001&quot;\n    println!(&quot;{number:&gt;0width$}&quot;, number=1, width=6);\n\n    // println! 会检查使用到的参数数量是否正确\n\n    #[allow(dead_code)]\n    struct Structure(i32);\n    // 像结构体这样的自定义类型需要更复杂的方式来处理\n    // 下面语句无法运行\n    // println!(&quot;{}&quot;, Structure(3));\n}接下来我们将学习如何打印像结构体那样的复杂数据类型\n所有的类型, 若想用 std::fmt 的格式化打印出来, 都要求实现它. 自动的实现只为一些类型提供, 比如 std 库中的类型. 所有其他类型 都 必须 手动实现\nfmt::Debug 派生宏使这项工作变得相当简单, 所有类型都能推导 fmt::Debug 的实现. 但是 fmt::Display 需要手动实现\nDebug trait所有 Std 类型都天生可以使用 {:?} 来打印\nrust// 推导 `Structure` 的 `fmt::Debug` 实现\n#[derive(Debug)]\nstruct Structure(i32);\n\n// 将 `Structure` 放到结构体 `Deep` 中. 然后使 `Deep` 也能够打印\n#[derive(Debug)]\nstruct Deep(Structure);\n\nfn main() {\n    // 使用 `{:?}` 打印和使用 `{}` 类似\n    println!(&quot;一年有{:?}个月&quot;, 12);\n    println!(&quot;{0:?}是这个演员的名字&quot;, &quot;Slater&quot;);\n\n    // `Structure` 也可以打印！\n    println!(&quot;打印结构体{:?}&quot;, Structure(3));\n\n    // 使用 `derive` 的一个问题是不能控制输出的形式\n    // 假如我只想展示一个 `7` 怎么办？\n    println!(&quot;打印结构体{:?}&quot;, Deep(Structure(7)));\n}\nfmt::Debug 使这些内容可以打印, 但是牺牲了一些美感. Rust 通过 {:#?} 提供了 “美化打印” 的功能\nrust#[derive(Debug)]\nstruct Person&lt;&#39;a&gt; {\n    name: &amp;&#39;a str,\n    age: u8\n}\n\nfn main() {\n    let name = &quot;Peter&quot;;\n    let age = 27;\n    let peter = Person { name, age };\n\n    // 美化打印\n    println!(&quot;{:#?}&quot;, peter);\n}Display traitfmt::Debug 通常看起来不太简洁, 因此自定义输出的外观经常是更可取的. 这需要通过手动实现 fmt::Display 来做到. fmt::Display 采用 {} 标记\nrust#![allow(unused_variables)]\nfn main() {\n    // fmt::Display 需要手动导入\n    use std::fmt;\n\n    struct Structure(i32);\n\n    impl fmt::Display for Structure {\n        fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n            // 仅将 self 的第一个元素写入到给定的输出流 `f`. 返回 `fmt:Result`\n            // 结果表明操作成功或失败. `write!`的用法和 `println!` 很相似\n            write!(f, &quot;{}&quot;, self.0)\n        }\n    }\n}fmt::Display 的效果可能比 fmt::Debug 简洁, 但对于 std 库来说, 模棱两可的类型该如何显示呢? 这并不是一个问题, 因为对于任何 非 泛型的 容器 类型, fmt::Display 都能够实现。\nrustuse std::fmt;\n\n// 带有两个数字的结构体. 推导出 `Debug`, 以便与 `Display` 的输出进行比较\n#[derive(Debug)]\nstruct MinMax(i64, i64);\n\n// 实现 `MinMax` 的 `Display`\nimpl fmt::Display for MinMax {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        // 使用 `self.number` 来表示各个数据\n        write!(f, &quot;({}, {})&quot;, self.0, self.1)\n    }\n}\n\n// 为了比较, 定义一个含有具名字段的结构体\n#[derive(Debug)]\nstruct Point2D {\n    x: f64,\n    y: f64,\n}\n\n// 类似地对 `Point2D` 实现 `Display`\nimpl fmt::Display for Point2D {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        // 自定义格式, 使得仅显示 `x` 和 `y` 的值\n        write!(f, &quot;x: {}, y: {}&quot;, self.x, self.y)\n    }\n}\n\nfn main() {\n    let minmax = MinMax(0, 14);\n\n    println!(&quot;Compare structures:&quot;);\n    println!(&quot;Display: {}&quot;, minmax);\n    println!(&quot;Debug: {:?}&quot;, minmax);\n\n    let big_range =   MinMax(-300, 300);\n    let small_range = MinMax(-3, 3);\n\n    println!(&quot;The bigger range is {big} ,the smaller range is {small}&quot;,\n        small = small_range,\n        big = big_range\n    );\n\n    let point = Point2D { x: 3.3, y: 7.2 };\n\n    println!(&quot;Compare points:&quot;);\n    println!(&quot;Display: {}&quot;, point);\n    println!(&quot;Debug: {:?}&quot;, point);\n}\n输入输出流控制台输入rustuse std::io; // 手动导入 `io`\n\nfn read_input() -&gt; io::Result&lt;()&gt; {\n    //创建空字符串\n    let mut input = String::new();\n    io::stdin().read_line(&amp;mut input)?;\n    println!(&quot;Your input: {}&quot;, input.trim());\n    Ok(())\n}\nfn main() {\n    read_input();\n}控制台输出对我们来说这些已经太熟悉了, 这里只再提一些细节. 标准化的输出是 行缓冲 的, 这就导致标准化的输出在遇到一个新行之前并不会被隐式刷新. 换句话说 print! 和 println! 二者的效果并不总是相同的. 比如:\nrustuse std::io;\nfn main() {\n    print!(&quot;Waitting: &quot;);\n    let mut input = String::new();\n    io::stdin()\n        .read_line(&amp;mut input)\n        .expect(&quot;Read failed&quot;);\n    print!(&quot;Your input: {}\\n&quot;, input);\n}在这段代码运行时则不会先出现预期的提示字符串, 因为行没有被刷新. 如果想要达到预期的效果就要显示的刷新, 即在提示字符串下加一行 io::stdout().flush().unwrap();\n文件输入文件输入流指向了文件而不是控制台, 一般通过 match 处理潜在错误\nrustuse std::error::Error;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::path::Path;\n\nfn main() {\n    // 创建一个文件路径\n    let path = Path::new(&quot;test.txt&quot;);\n    let display = path.display();\n\n    // 打开文件只读模式, 返回一个 `io::Result&lt;File&gt;` 类型\n    let mut file = match File::open(&amp;path) {\n        // 处理打开文件可能潜在的错误\n        Err(err) =&gt; panic!(&quot;无法打开 {}, 错误: {}&quot;, display,Error::description(&amp;err)),\n        Ok(file) =&gt; file,\n    };\n\n    // 文件输入数据到字符串, 并返回 `io::Result&lt;usize&gt;` 类型\n    let mut s = String::new();\n    match file.read_to_string(&amp;mut s) {\n        Err(err) =&gt; panic!(&quot;无法读取 {}, 错误: {}&quot;, display,Error::description(&amp;err)),\n        Ok(_) =&gt; print!(&quot;{} 的内容为:\\n{}&quot;, display, s),\n    }\n}文件输出文件输出流重定向到文件中\nrustuse std::error::Error;\nuse std::io::prelude::*;\nuse std::fs::File;\nuse std::path::Path;\n\nfn main() {\n    let path = Path::new(&quot;out/test.txt&quot;);\n    let display = path.display();\n\n    // 用只写模式创建并打开一个文件, 并返回 `io::Result&lt;File&gt;` 类型\n    let mut file = match File::create(&amp;path) {\n        Ok(file) =&gt; file,\n        Err(err) =&gt; panic!(&quot;无法创建文件 {}, 错误: {}&quot;, display, Error::description(&amp;err)),\n    };\n\n    file.write(b&quot;写入文本&quot;).unwrap();\n}OpenOptionsRust 还为我们提供了一个方便的配置用于统一前面两个操作, 下面看一些例子\nrustuse std::fs::OpenOptions;\n\n// 打开一个文件\nlet file = OpenOptions::new() // 创建一组可供配置的空白新选项, 每个选项的默认值都是 false\n    .read(true) // 启用 读 模式\n    .write(true) // 启用 写 模式\n    .create(true) // 如果不存在则创建文件, 存在就返回文件\n    .open(&quot;test.txt&quot;); // 文件路径如果该文件已经存在, 则对该文件的任何写调用都将覆盖其内容, 而不会将其截断\n下面还有一些常用选项\n\nappend: 追加模式, 写入将追加到文件中, 而不是覆盖. 请注意, 设置 .write(true).append(true) 与仅设置 .append(true) 具有相同的效果. 下面是一些注意事项\n对于大多数文件系统, 操作系统保证所有写操作都是 Atom (原子) 的: 不会浪费任何写操作, 因为另一个进程会同时进行写操作\n使用追加模式时, 确保一次完成将所有在一起的数据写入文件\n如果同时使用读取和追加的访问权限打开文件, 请注意: 在打开之后以及每次写入之后, 读取位置可能设置在文件末尾. 所以在写入之前, 保存当前位置, 可以使用 seek(SeekFrom::Current(0)), 并在下次读取之前恢复它\n\n\ntruncate: 截断模式, 如果成功打开文件, 则会将文件长度截断为 0. 注意, 必须同时开启 write 才能使用此操作\ncreate_new: 创建新文件模式. 与 create 不同的是, 如果文件已存在, 即使是符号链接, 它也不会返回, 而是直接报错, 只有文件不存在才会创建并返回. 通过这样的方式确保打开的一定是新文件\n这个选项是有实际用处的, 因为它是原子的. 否则, 在检查文件是否存在与创建新文件之间, 文件可能是由另一个进程创建的\n注意: 如果开启了此选项, 则 create 和 truncate 将被忽略\n\n\n\n","slug":"RustCourse-07","date":"2021-06-08T14:14:48.000Z","categories_index":"Course","tags_index":"Rust","author_index":"芳塔洛斯"},{"id":"91ba0ade330f247ed224e1b5c95f6039","title":"初识 Rust(6) | 方法, 泛型, Trait, 生命周期, 集合类型","content":"方法Rust 通过 impl 关键字在 struct , enum 或者 trait 对象的上下文实现方法调用语法, 一个对象可以有多个 impl 块. 关联函数的第一个参数通常为 self 参数, 一个指代方法或 Trait 类型的别名, 有 3 种变体:\n\nself, 允许实现者移动和修改对象, 对应的闭包特性为 FnOnce\n&amp;self, 既不允许实现者移动对象也不允许修改, 对应的闭包特性为 Fn\n&amp;mut self, 允许实现者修改对象但不允许移动, 对应的闭包特性为 FnMut\n\n还有一个 Self 是用于主带当前的实例对象\nrust/// 矩形结构体\nstruct Rectangular {\n    width: u32,\n    height: u32,\n}\n// 为该结构体创建方法\nimpl Rectangular {\n    /// 创建矩形\n    // 不含 self 参数的方法也称为静态方法\n    fn new(width: u32, height: u32) -&gt; Rectangular {\n        Rectangular {\n            width,\n            height\n        }\n    }\n    /// 快速创建正方形\n    fn square(size: u32) -&gt; Self {\n        Rectangular {\n            width: size,\n            height: size\n        }\n    }\n    /// 获得矩形宽\n    fn get_width(&amp;self) -&gt; u32 {\n        self.width\n    }\n    /// 获得矩形长\n    fn get_height(&amp;self) -&gt; u32 {\n        self.height\n    }\n    /// 求矩形面积\n    fn area(&amp;self) -&gt; u32 {\n        self.width * self.height\n    }\n    /// 求矩形对角线\n    fn diagonal(&amp;self) -&gt; f64 {\n        let x = self.width as f64;\n        let y = self.height as f64;\n        let z = x * x + y * y;\n        z.sqrt()\n    }\n}\nfn main() {\n    let a = Rectangular::new(10, 20);\n    let b = a.area();\n    println!(&quot;这个矩形的面积是: {}&quot;,b);\n\n    let c= Rectangular::square(20);\n    let d = c.area();\n    println!(&quot;这个正方形的面积是: {}&quot;,d);\n\n    let e = Rectangular::new(3, 4);\n    let f = e.diagonal();\n    println!(&quot;这个矩形的对角线是:{}&quot;,f);\n\n    let g = Rectangular::new(10,40);\n    println!(&quot;这个矩形的长是: {}, 宽是: {}&quot;,g.get_width(),g.get_height());\n}泛型Rust 作为一门强类型语言, 如果一个函数的参数类型定义为 i32, 那它就无法接受 i16 的参数. 但在编程中, 经常需要用一个函数处理不同类型的数据, 例如两个数的加法, 无论是整数还是浮点数, 甚至是自定义类型, 都能进行支持. 这时, 就需要用到 泛型 (Generics). 熟悉 面向对象 的人可能了解 多态, 实际上泛型就是多态的一种, 在类型理论中称作 参数多态, 即对于给定参数可以有多种形式的函数或类型. 泛型用于表示任意类型, 但通常我们会对其加以约束\n我们提到的任意类型加法, 可以参考下面的 “例子”, 它还不能够编译, 原因就是缺少约束, 因为在实际中, 也不是任意两个事物就可以相加的\nrustfn add&lt;T&gt;(a:T, b:T) -&gt; T {\n    a + b\n}\n\nprintln!(&quot;add i8: {}&quot;, add(2i8, 3i8));\nprintln!(&quot;add i32: {}&quot;, add(20, 30));\nprintln!(&quot;add f64: {}&quot;, add(1.23, 1.23));泛型声明还记得 Option 枚举的定义吗, 其中的 T 就是一个泛型, 使得这个枚举可以承载任何值. 在 Rust 中我们习惯使用 T 作为泛型\nrustenum Option&lt;T&gt; {\n    Some(T),\n    None,\n}相信你已经注意到了, 泛型同样需要先声明再使用, 声明的语法就是 &lt;T&gt;, 泛型参数可以不止一个, 也可以作用于结构体和方法\nrustfn point&lt;T, U&gt;(a: T, b: U) -&gt; (T, U) {\n    (a, b)\n}\nlet couple = point(1, 2.0);\n\nstruct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\n// 要注意先在 impl 声明泛型, 再在 Point 使用泛型\nimpl&lt;T&gt; Point&lt;T&gt; {\n    // Some function\n}\n\n// 不仅可以定义泛型, 也能为特定的类型实现特定的方法\nimpl Point&lt;i32&gt; {\n    // Some function\n}\n\nlet int_origin = Point { x: 0, y: 0 };\nlet float_origin = Point { x: 0.0, y: 0.0 };Const 泛型上面所提到的泛型都是针对 类型 的, 那么有没有针对 值 的泛型呢? 可能有人对这个问题本身都无法理解, 值要怎么用泛型? 我们先从数组讲起\n我们知道 [i32; 1] 和 [i32; 2] 是两个不同的数组类型, 无法被同一个固定类型的函数所接受, 但我们可以通过引用, 用 &amp;[i32] 这个类型让固定类型的函数可以接受所有的 i32 元素数组. 随后, 我们又可以用 &amp;[T] 这个类型, 让函数接受所有 (被同一系列 Trait 所约束) 的数组\n比如为了打印数组, 我们最终可以实现:\nrustfn display_array&lt;T: std::fmt::Debug&gt;(arr: &amp;[T]) {\n    println!(&quot;{:?}&quot;, arr);\n}但如果在某种情况下, 不适合或者干脆不能用引用的数组呢? 其实很早之前, 部分第三方库的参数不允许数组超过 32 个元素, 因为迫于着某种原因, 他们需要为每种长度的数组都单数实现一个函数 … 可以说是非常痛苦了, 不过好在, 这种情况已经称为过去式了, 我们拥有了 Const 泛型这种针对于值得泛型, 正好可以很好的处理数组长度的问题\n让我们不通过引用重新实现上面的函数\nrustfn display_array&lt;T: std::fmt::Debug, const N: usize&gt;(arr: [T; N]) {\n    println!(&quot;{:?}&quot;, arr);\n}我们定义了一个类型为 [T; N] 的数组, 其中 T 是一个基于类型的泛型参数, 重点是 N 这个泛型, 它就是我们所说的那个基于值的泛型参数! 因为它用来替代的是数组的长度. 声明语法如上所示, 它基于的值类型是 usize\n在 Const 泛型参数之前, Rust 完全不适合复杂矩阵的运算, 自从有了 Const 泛型, 一切都将改变\n泛型的性能对于多态函数，有两种 派分 机制: 静态派分 和 动态派分. 前者类似于 C++ 的模板, Rust 会生成适用于指定类型的特殊函数, 然后在被调用的位置进行替换, 好处是允许函数被内联调用, 性能没有损耗, 毕竟这就像是我们为每个类型都手动实现了对应的函数, 但是这会导致代码膨胀, 使最终得二进制文件变大. 后者类似于 Go 的 interface, Rust 通过引入 Trait Object (特征对象) 来实现, 在运行期查找 虚表 来选择执行的方法. Trait Object 具有和 Trait相同的名称, 通过 转换 或者强制 多态化 一个指向具体类型的指针来创建, 会带来一定的性能损耗\nTrait为了描述类型可以实现的抽象接口, Rust 通过 Trait (特征) 来定义 函数类型签名, 特性就相当于其他语言中的接口\nrust// 通过 trait 关键字定义特性\ntrait HasArea {\n    // 这个特性使 area 函数必须接受一个 &amp;eslf 类型, 返回一个 f64 类型\n    fn area(&amp;self) -&gt; f64;\n}\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl HasArea for Circle {//将特性应用于该结构体\n    fn area(&amp;self) -&gt; f64 {//实现特性\n        std::f64::consts::PI * (self.radius * self.radius)\n    }\n}\n\nstruct Square {\n    x: f64,\n    y: f64,\n    side: f64,\n}\n\nimpl HasArea for Square {\n    fn area(&amp;self) -&gt; f64 {\n        self.side * self.side\n    }\n}\n总而言之, Trait 定义了一组可以被共享的行为, 只要实现了Trait, 就能使用这组行为\n特征约束其实在上面的示例中已经有所体现. 这里让我们再举一个例子:\nrustfn print_area&lt;T: HasArea&gt;(shape: T) {\n    println!(&quot;This shape has an area of {}&quot;, shape.area());\n}可以看到函数 print_area() 中的泛型参数 T 被添加了一个名为 HasArea 的 Trait Bound (特征约束), 用以确保任何实现了HasArea 的类型将拥有一个 area 方法. Trait Bound, 可以使用 + 运算符\nrustuse std::fmt::Debug;\n\nfn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {\n    x.clone();\n    y.clone();\n    println!(&quot;{:?}&quot;, y);\n}也可以有条件的实现 Trait, 例如, 标准库为任何实现了 Display trait 的类型实现了 ToString trait\nrustimpl&lt;T: Display&gt; ToString for T {\n    // --snip--\n}现在我们可以修改之前的例子了\nrustfn add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) -&gt; T {\n    a + b\n}\n\nprintln!(&quot;add i8: {}&quot;, add(2i8, 3i8));\nprintln!(&quot;add i32: {}&quot;, add(20, 30));\nprintln!(&quot;add f64: {}&quot;, add(1.23, 1.23));只有能够加和的类型才能调用这个函数\n有的时候类型约束可能会非常长, 将会是我们的函数签名也变得非常长, 这种时候就可以通过使用 where 关键字\nrustfn bar&lt;T, K&gt;(x: T, y: K)\n    where T: Clone,\n          K: Clone + Debug\n{\n    x.clone();\n    y.clone();\n    println!(&quot;{:?}&quot;, y);\n}where 从句还允许限定的左侧可以是任意类型, 而不仅仅是类型参数\n定义在 Trait 中的完整方法称为 默认方法, 可以被该 Trait 的实现 重载. 此外, Trait之间也可以存在 继承\nrusttrait People {\n    fn eat(&amp;self);\n\n    // 默认方法\n    fn greet(&amp;self) {\n        println!(&quot;Hello!&quot;);\n        }\n}\n\n// 继承\ntrait Student : People {\n    fn study(&amp;self);\n}\n\nstruct Citizen;\n\nimpl People for Citizen {\n    fn eat(&amp;self) {\n        println!(&quot;Delicious!&quot;);\n    }\n}\n\nimpl Student for Citizen {\n    fn study(&amp;self) {\n        println!(&quot;Study!&quot;);\n    }\n}如果同一个类型实现了两个不同 Trait , 但这两个 Trait 却拥有名称相同的方法, 可以使用 显式调用 来避免混淆\nrust// 短形式\nTraitName::method_name(valuable);\n\n// 展开形式\n&lt;TypeName as TraitName&gt;::method_name(valuable);直接用 Trait 作为参数和返回值首先是作为参数\nrustfn display(item: &amp;impl ToString) {\n    println!(&quot;Display: {}&quot;, item.to_string());\n}这看上去非常易懂: item 是任何实现了 ToString trait 的类型\n同样, 我们也可以返回一个实现了某个 Trait 的任意类型\nrustfn people() -&gt; impl People{\n    Citizen\n}但是有一点要注意, 函数的所有分支返回的类型必须是相同的, 这是因为 Rust 要求类型的大小必须在编译期已知, 而返回两种不同的实现了同一 Trait 的类型就会导致无法确定返回值的具体大小, 比如下面的代码无法编译\nrustfn people(is_man: bool) -&gt; impl People{\n    if is_man{\n        Man\n    } else {\n        Woman\n    }\n}自动派生我们的文章中已经出现过 #[derive(Debug)], 它将通过一个 过程宏 为一个类型自动实现 Debug trait\n调用某些方法需要引入对应的 Trait如果你要使用一个特征的方法, 那么你需要将该特征引入当前的作用域中, 比如下面:\nrustuse std::convert::TryInto;\n\nfn main() {\n    let a: i32 = 10;\n    let b: u16 = 100;\n    let b_ = b.try_into().unwrap();\n    if a &lt; b_ {\n        println!(&quot;Ten is less than one hundred.&quot;);\n    }\n}虽然没有使用 TryInto trait, 但是调用了其下的 try_into() 方法. 但不用担心, 事实上 Rust 已经通过 prelude 引入了 TryInto trait 了, 所以不用担心这些额外的代码, 可以尝试删掉最上面的一行\nTrait 的泛型与关联类型Trait 也可以接受泛型参数。但更好的处理方式往往是使用 关联类型\nrust// 泛型参数\ntrait Graph&lt;N, E&gt; {\n    fn has_edge(&amp;self, &amp;N, &amp;N) -&gt; bool;\n    fn edges(&amp;self, &amp;N) -&gt; Vec&lt;E&gt;;\n}\n\nfn distance&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; u32 {}\n\n// 关联类型\ntrait Graph {\n    type N;\n    type E;\n\n    fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;\n    fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;\n}\n\nfn distance&lt;G: Graph&gt;(graph: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; uint {}\n\nstruct Node;\n\nstruct Edge;\n\nstruct SimpleGraph;\n\nimpl Graph for SimpleGraph {\n    type N = Node;\n    type E = Edge;\n\n    fn has_edge(&amp;self, n1: &amp;Node, n2: &amp;Node) -&gt; bool {}\n\n    fn edges(&amp;self, n: &amp;Node) -&gt; Vec&lt;Edge&gt; {}\n}\n\nlet graph = SimpleGraph;\nlet object = Box::new(graph) as Box&lt;Graph&lt;N=Node, E=Edge&gt;&gt;;关联类型是在 Trait 定义的语句块中, 申明一个自定义类型, 这样就可以在特征的方法签名中使用该类型, 通常当类型很复杂时, 关联类型能大大提高代码可读性.\n或者在使用泛型时, 导致函数头部也必须增加泛型的声明, 而使用关联类型会好很多, 对比一下下面的代码\nrusttrait Container&lt;A,B&gt; {\n    fn contains(&amp;self,a: A,b: B) -&gt; bool;\n}\nfn difference&lt;A,B,C&gt;(container: &amp;C) -&gt; i32\n  where\n    C : Container&lt;A,B&gt; {...}\n\ntrait Container{\n    type A;\n    type B;\n    fn contains(&amp;self, a: &amp;Self::A, b: &amp;Self::B) -&gt; bool;\n}\nfn difference&lt;C: Container&gt;(container: &amp;C) {}还有一点是我们之前提过 Self 用来指代当前调用者的具体类型, 那么如果我们定义了 type Item, 就可以使用 Self::Item 来指代该类型实现中定义的 Item 类型\n关于实现 Trait 的几条限制:\n如果一个 Trait 不在当前作用域内, 它就不能被实现。\n不管是 Trait 还是 impl, 默认都只能在当前的 Crate 内起作用\n带有 Trait Bound 的泛型函数使用 单态化实现, 所以它是 静态派分 的\n最重要的一点, 不能为一个从外部引入的类型实现一个从外部引入的 Trait, 这两个至少要有一个是在当前作用域定义的, 这时为了防止你破环第三方库的代码或者第三方库破环你的代码, 比如你不能为 String 类型实现 Display trait. 这被称为 孤儿原则\n\n绕过孤儿原则可以通过 New Type 模式, 在本地定义一个元组结构体包裹外部类型, 然后为这个元组结构体实现外部 Trait\n容器类型动态数组之前我们提到, Rust 的数组是不可变的, 而可变的动态数组, 我们称之为 Vec (向量). 动态数组是一种基于堆内存申请的连续动态数据类型，拥有 O(1) 时间复杂度的索引, 压入 (push), 弹出 (pop)\n动态数组在连续的内存空间储存多个值, 因此访问其中某个元素的成本非常低, 但同样只能存储相同类型的元素, 如果需要存储不同类型的元素, 可以使用 重装枚举类型 或者接下来会提到的 Trait Object (特征对象)\n通过前面几篇文章的铺垫, Vec 的学习就变得相当简单了, 这里直接通过一系列例子进行展示\nrust// 创建空 Vec\n// 如果仅仅是创建空 Vec ,需要手动注明类型, 但如果随后便添加了一个元素, 那么编译器就可以自动推导出类型\nlet v: Vec&lt;i32&gt; = Vec::new();\n// 使用宏创建空 Vec\nlet v: Vec&lt;i32&gt; = vec![];\n// 创建包含 5 个元素的 Vec\nlet v = vec![1, 2, 3, 4, 5];\n// 创建 10 个 0 的 Vec\nlet v = vec![0; 10];\n// 创建可变的Vec, 并 push 元素 3\nlet mut v = vec![1, 2];\nv.push(3);\n// 创建拥有两个元素的 Vec, 并 pop 一个元素\nlet mut v = vec![1, 2];\nlet two = v.pop();\n// 创建包含 3 个元素的可变 Vec，并索引一个值和修改一个值\nlet mut v = vec![1, 2, 3];\nlet three = v[2];\nv[1] = v[1] + 5;\n\n// 通过 get 方法安全的索引元素, 返回 Option&lt;T&gt; 枚举, 这里直接用 unwrap 方法进行解包, 但更好的做法是通过 match 进行解构\nlet one = v.get(0).unwrap();\n\n// 通过迭代器遍历 Vec\nlet mut v = vec![1, 2, 3];\nfor i in &amp;v {\n    println!(&quot;{i}&quot;);\n}\n\n// 迭代的同时修改 Vec\nlet mut v = vec![1, 2, 3];\nfor i in &amp;mut v {\n    *i += 10\n}\n\n// 通过重装枚举装入不同类型的值\nenum Num {\n    Int(i32),\n    Float(f64)\n}\n\nlet v = vec![Num::Int(0), Num::Float(3.14)]\n\n// 通过特征对象装入不同的值\ntrait Print {\n    fn display(&amp;self);\n}\n\nstruct Text(String);\nimpl Print for Text {\n    fn display(&amp;self) {\n        println!(&quot;The text is: {}&quot;,self.0)\n    }\n}\nstruct Int(i32);\nimpl Print for Int {\n    fn display(&amp;self) {\n        println!(&quot;The num is {}&quot;,self.0)\n    }\n}\n\nlet v: Vec&lt;Box&lt;dyn IpAddr&gt;&gt; = vec![\n    Box::new(Text(&quot;Hello, world!&quot;.to_string())),\n    Box::new(Int(1)),\n];\n\nfor ip in v {\n    ip.display();\n}注意, Vec 与其内部元素是共存亡的, 一旦 Vec 离开作用域, 其自身和内部元素都将被 Drop\n索引与 get 方法的区别为什么要存在两种获取元素的方式呢? 其实这是为了解决数组越界导致的空指针问题\nrustlet v = vec![1, 2, 3, 4, 5];\n\nlet does_not_exist = &amp;v[100];\nlet does_not_exist = v.get(100);上面这两种方法, 使用索引会因为找不到元素直接 panic. 而使用 get 方法后, 最终通过解包会得到 Option::None\n但总之, Rust 给了我们选择, get 方法既冗长不美观, 又会带来轻微的性能损失, 如果可以保证数组不越界, 那还是用索引更加方便\nVec 常用方法初始化 vec 的更多方式:\nrustlet v = vec![0; 3];   // 默认值为 0，初始长度为 3\nlet v = Vec::from([0, 0, 0]); // 从普通数组生成\nlet mut v = [0, 1, 2].to_vec();\nv.is_empty() //判断是否为空\nv.insert(3, 3); // 在指定索引插入元素, 注意索引不能超过 Vec 的长度\nv.remove(3) // 移除指定索引的元素并返回, 比如这里会返回 3\n\nlet mut v1 = [3, 4, 5].to_vec(); // append 会清空 v1, 需要增加可变声明\nv.append(&amp;mut v1); // 将 v1 的元素添加到 v\nv.truncate(5); // 截断到指定长度，多余的元素被删除, v: [0, 1, 2, 3, 4]\nv.retain(|x| *x &gt; 0); // 仅保留满足条件的元素 v: [1, 2, 3, 4]\n// 删除指定范围的元素，同时获取被删除元素的迭代器, v: [1, 2], m: [3, 4]\nlet mut m: Vec&lt;_&gt; = v.drain(2..=4).collect();\nlet v2 = v.split_off(1); // 指定索引处切分成两个 vec, v: [1], v2: [2]\nlet slice = &amp;m[0..=1]; // 获取切片\nv.clear() // 清空数组动态数组在增加元素时如果容量不足就会导致 Vec 扩容 (目前的策略是重新申请一块 2 倍大小的内存, 再将所有元素拷贝到新的内存位置，同时更新指针数据), 频繁扩容或者当元素数量较多且需要扩容时, 大量的内存拷贝显然会降低程序的性能\n可以考虑在初始化时就指定一个实际的预估容量, 尽量减少可能的内存拷贝\nrustlet mut v = Vec::with_capacity(10);\nv.reserve(100); // 调整 v 的容量到至少 100\nv.shrink_to_fit(); // 释放剩余的容量, 一般不会主动执行Vec 的排序Rust 实现了两种排序算法, 稳定排序 sort 和 sort_by, 不稳定排序 sort_unstable 和 sort_unstable_by\n稳定 指对相等的元素, 不会对其进行重新排序, 而不稳定算法不保证这点, 但速度更快, 内存占用更低\nrust// 排列整数\nlet mut vec = vec![1, 3, 2, 5, 4];\nvec.sort_unstable();\n// 排列浮点数\nlet mut vec = vec![1.0, 0.9, 1.1, 2.8, 4f32];\nvec.sort_unstable();运行后发现后者直接报错了, 这是因为在浮点数当中存在一个 NAN (Not A Number) 的值无法与其他的浮点数比较\n所以浮点数并没有实现全数值可比较的 Ord trait, 而是实现了部分可比较的 PartialOrd trait\n所以如果确定数组不包含 NAN, 可以用 partial_cmp 来作为大小判断的依据\nrustlet mut vec = vec![1.0, 0.9, 1.1, 2.8, 4f32];\nvec.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());如法炮制, 来对结构体数组进行排序\nruststruct Num(u32)\n\nlet mut num = vec![Num(2), Num(1), Num(3)];\nnum.sort_unstable_by(|a, b| b.0.cmp(&amp;a.0));当然, 我们也可以手动实现 Ord trait 来作为排序依据, 但这还不够, 因为实现这个 Trait 还需要实现 Eq, PartialEq, PartialOrd trait 好消息是我们可以 derive 这些属性\nrust#[derive(Ord, Eq, PartialEq, PartialOrd)]\nstruct Num(u32)\n\nlet mut num = vec![Num(2), Num(1), Num(3)];\nnum.sort_unstable()可变长度字符串String 是一个带有的 vec:Vec&lt;u8&gt; 成员的结构体, 可以理解为 str 类型的动态形式. 它们的关系相当于 [T] 和 Vec&lt;T&gt; 的关系, 所以 String 类型也有类似 push 和 pop 的方法\nrust// 创建一个空的字符串\nlet mut s = String::new();\n// 从 `&amp;str` 类型转化成 `String` 类型\nlet mut hello = String::from(&quot;Hello, &quot;);\n// 压入字符和压入字符串切片\nhello.push(&#39;w&#39;);\nhello.push_str(&quot;orld!&quot;);\n\n// 弹出字符。\nlet mut s = String::from(&quot;foo&quot;);\nassert_eq!(s.pop(), Some(&#39;o&#39;));\nassert_eq!(s.pop(), Some(&#39;o&#39;));\nassert_eq!(s.pop(), Some(&#39;f&#39;));\nassert_eq!(s.pop(), None);KV 存储KV 键值对 数据结构并提供了平均复杂度为 O(1) 的查询方法, 当我们希望通过一个 Key 去查询值时, 该类型非常有用, 下面我们介绍其中一种比较常用的, HashMap (哈希表)\nHashMap 并不在 prelude 中, 需要我们手动引入, 类似 Vec, 可以使用 new 方法来, 然后通过 insert 方法插入键值对\nrustuse std::collections::HashMap;\n\nlet mut map = HashMap::new();\n\n// 自动类型推断, 很明显是 HashMap&lt;&amp;str,i32&gt;\nmap.insert(&quot;one&quot;, 1);\nmap.insert(&quot;two&quot;, 2);可以通过迭代器将其他类型高效的转化成 HashMap\nrustuse std::collections::HashMap;\n\nlet price_list = vec![\n    (&quot;苹果&quot;.to_string(), 4),\n    (&quot;橘子&quot;.to_string(), 3),\n    (&quot;香蕉&quot;.to_string(), 5),\n];\n\nlet price_map: HashMap&lt;_,_&gt; = price_list.into_iter().collect();创建 HashMap 有三点需要注意:\n\n若类型实现 Copy trait, 会被复制进 HashMap\n若没实现 Copy trait, 所有权将被转移给 HashMap\n如果将引用放入 HashMap, 请确保该引用的 生命周期 至少跟 HashMap 一样长\n\n一些常用操作rust// 通过 Key 获取 Value\n// get 方法会返回一个 Option 类型, 如果未查询到会返回 None\n// 查询到会返回一个引用类型, 比如这里是 Option&lt;i32&gt;\nprice_map.get(&quot;苹果&quot;);\n\n// 如果想直接获得 i32 类型可以用以下的方法\n// 因为 i32 是 Copy 的, 通过 copied 方法可以返回 Option&lt;i32&gt;\n// 随后通过 unwrap_or 方法解包, 如果是 Some 则返回, 如果是 None, 则返回 0\nprice_map.get(&quot;橘子&quot;).copied().unwrap_or(0);\n\n// 迭代循环 HashMap\nfor (key, value) in &amp;scores {\n    println!(&quot;{} 的价格是 {}&quot;, key, value);\n}\n\n// 通过相同的 Key 可以更新对应的 Value\nprice_map.insert(&quot;香蕉&quot;.to_string(), 5);\n\n// 查询一个 Key, 如果不存在就插入, 如果存在则无事发生\nprice_map.entry(&quot;葡萄&quot;.to_string()).or_insert(7);特征对象上面我们提到函数可以以 Trait 为返回值, 但有一个限制就是函数的所有分支返回的类型必须是相同的, 而这种限制就会让这种方法变得非常鸡肋. 有什么解决办法吗?\n一种方法是可以采用 Rust 独有的重装枚举. Hmm, 这确实能解决眼下的问题, 但如果你无法提前知道返回的 Trait 的所有情况呢?\n其实在上一篇文章中答案就已经显露了, 为了在 main 函数中使用 ? 运算符, 我们通过 Box&lt;dyn Error&gt; 让 main 函数可以返回任何实现了 Error 的错误类型, 其中的 dyn Trait 就是我们接下来要讲的 Trait Object (特征对象), 我们在前文 泛型的性能 就提到过, Trait Object 的类型是在运行时确定的, 因此会带来一定的性能损耗\n这种类型在 UI 库中比较常见, 因为在 UI 中, 我们需要绘制组件, 我们不可能为每个组件都实现一个绘制函数, 而且有的库也允许用户封装自己的组件, 这就更无法预知其类型了, 这时就要用到 Trait Object\n下面我们举一段例子\nrustpub trait Draw {\n    fn draw(&amp;self);\n}任何实现了 Draw trait 的类型都是可以并且需要被绘制的\nruststruct Text {}\nimpl Draw for Text {\n    fn draw(&amp;self) {\n        // Drawing\n    }\n}\nstruct Image {}\nimpl Draw for Image {\n    fn draw(&amp;self) {\n        // Drawing\n    }\n}随后, 我们需要一个 View Tree, 这里我们用 Vec 来代替, 储存这些可以被绘制的对象. 但这个 Vec 应该是什么类型呢? 我们既需要绘制 Text, 也需要绘制 Imagin, 可我们不能填入两个类型. 但因为它们都实现了 Draw trait, 那可不可以把拥有 Draw 特征的对象填入呢? 答案当然是肯定的, 这就是 Trait Object\n再提一次, Trait Object 指向实现了 Draw trait 的类型的实例, 也就是指向了 Text 或者 Imagin 的实例, 这种映射关系是存储在一张表中, 可以在运行时通过特征对象找到具体调用的类型方法\n可以通过 &amp; 引用或者 Box&lt;T&gt; 智能指针 的方式来创建特征对象\n\n\n\n\n\n\n\n\n\n关于智能指针会在以后的进阶教程中提到. 这里简单概括一下, Box&lt;T&gt; 能把任意类型分配到堆上并返回一个指针\n关于创建的具体过程让我们先举一个小例子\nrusttrait Draw {\n    fn draw(&amp;self) -&gt; String;\n}\n\nimpl Draw for u8 {\n    fn draw(&amp;self) -&gt; String {\n        format!(&quot;u8: {}&quot;, *self)\n    }\n}\n\n// 若 T 实现了 Draw trait, 则调用该函数时传入的 Box&lt;T&gt; 可以被隐式转换成函数参数签名中的 Box&lt;dyn Draw&gt;\nfn draw1(x: Box&lt;dyn Draw&gt;) {\n    // 由于实现了 Deref trait, Box&lt;T&gt; 会自动解引用为 T, 然后调用该值对应的类型上定义的 `draw` 方法\n    x.draw();\n}\n\nfn draw2(x: &amp;dyn Draw) {\n    x.draw();\n}\n\nfn main() {\n    let num = 8u8;\n    draw1(Box::new(num));\n    draw2(&amp;num);\n}下面我们可以完善这段代码了\nrustpub struct Screen {\n    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,\n}\n\n// 实现一个 run 方法启动渲染\nimpl Screen {\n    pub fn run(&amp;self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}有两点需要注意\n\n可以发现 dyn 关键字只用在 Trait Object 的类型声明上, 在创建时无需使用\n之所以能够将 Trait Object 作为参数, 是因为 &amp;dyn 或者 Box&lt;dyn&gt; 都是一种指针, 可以在编译器确定指针的大小, 而如果直接使用 dyn Draw, Draw 类型的大小还是无法在编译器确定, 进而无法编译\n\n那么使用 Trait Object 的好处是, 即使用户自己创建了一个组件, 只要它实现了 Draw trait, 就可以被加入到我们的 Screen components 中. 而如果使用泛型, 那么我们的 UI 就只能接受 Text 或者 Imagin 两种组件了\n在动态类型语言和 Go 的 interface 中, 有一个重要概念: Duck Typing (鸭子类型), 就是只关心值有什么特征, 而不关心它实际是什么. 原例子是, 当一个东西走起来像鸭子, 叫起来像鸭子, 那么它就是一只鸭子, 即使它真的不是鸭子, 我们也当它是鸭子\n特征对象的限制不是所有 Trait 都能拥有 Trait Object, 只有对象安全的 Trait 才行\n如果一个对象时安全的, 它的 Trait 下的所有方法需要有以下特征:\n\n方法的返回类型不能是 Self\n方法没有任何泛型参数\n\n对象安全对于 Trait Object 是必须的, 因为就像鸭子类型所讲的, 一旦有了特征对象, 我们就不再关心其具体类型了, 但如果 Trait 方法返回了 Self 类型, 但是特征对象忘记了其真正的类型, 那这个 Self 的处境就非常尴尬, 连它自己都不知道自己是什么了. 对于泛型参数也是同理\n","slug":"RustCourse-06","date":"2021-06-08T12:32:17.000Z","categories_index":"Course","tags_index":"Rust","author_index":"芳塔洛斯"},{"id":"fa6879e34f616dae4cddea50d2178b96","title":"初识 Rust(5) | 流程控制, 模式匹配, 错误处理","content":"流程控制有了流程控制, 我们才能把代码的结构组织起来. Rust 中的流程控制都是表达式, 可以被赋值给变量\nif-else 条件分支if 是分支的一种, 可以与 else 和 else if 连用. 条件不需要小括号, 但条件后面必须跟一个代码块.\nrustlet x = 5;\nlet y = if x == 5 { true } else { false }for 迭代器循环与 C 语言的三目运算符不同, for 的抽象结构如下\nrustfor item in collection {\n    // Do something with item\n}collection 拥有三种不同形式, 可以是任何实现了 Iterator trait 的集合类型, 因此也可以通过 Iterator (迭代器) 的形式来使用:\n\ncollection 等价于 IntoIterator::into_iter(collection), 转移所有权到 for 代码块的作用域\n&amp;collection 等价于 collection.iter()\t不可变借用\n&amp;mut collection 等价于 collection.iter_mut()\t可变借用\n\n再简单提一下迭代器, 其还可以是以下两种形式\n\n1..10, 表示 1 到 9 的整数\n1..=10, 表示 1 到 10 的整数\n\nrustfor i in 1..=10 {\n    println!(&quot;{i}&quot;);\n}如果想在循环中 获取元素的索引 可以使用 enumerate 方法\nrustlet a = [4, 3, 2, 1];\n// 注意索引从 0 开始\nfor (i, v) in a.iter().enumerate() {\n    println!(&quot;第 {} 个元素是 {}&quot;, i + 1, v);\n}如果仅仅希望将一个过程重复几次, 不需要额外声明变量, 可以用 _ 来接收\nrustfor _ in 1..=10 {\n    println!(&quot;Print ten times&quot;);\n}迭代器有哪些优势先让我们看看这两种循环方式\nrust// 第一种, 通过索引访问元素\nlet collection = [1, 2, 3, 4, 5];\nfor i in 0..collection.len() {\n    let item = collection[i];\n    // Do something with item\n}\n\n// 第二种, 通过迭代器直接访问元素\nfor item in collection {\n    // Do something with item\n}首先是性能差距:\n\n第一种做法为了避免悬垂引用, 对 collection[index] 的索引访问会进行 边界检查(Bounds Checking), 确认该 index 确实在 collection 内, 导致运行时的性能损耗\n而第二种迭代器的方式, 由编译器确保每个元素绝对有效, 就不会触发这种检查\n\n安全性:\n\n第一种方式对 collection 的索引访问是 非连续的, 有可能在两次访问之间 collection 发生了变化, 导致脏数据产生\n而第二种迭代器的方式是连续访问, 通过所有权限制保证在访问过程中数据并不会发生变化\n\nRust 的 for 循环比 C 中的更加优秀强大, 无需任何条件限制, 也不需要通过索引来访问, 再加上 Rust 的 零成本抽象, 是  Rust 中最安全且高效的循环, 因此也是最常用的循环\nWhile 条件循环while 抽象结构如下\nrustwhile bool {\n    code\n}之前我们说 for 是最安全的循环, 下面我们通过用 while 来模仿 for 的功能来说明为什么\nrustlet a = [1, 2, 3, 4, 5];\nlet mut index = 0;\n\nwhile index &lt; 5 {\n    println!(&quot;the value is: {}&quot;, a[index]);\n    index = index + 1;\n}我们通过维护一个索引, 如期打印出了 5 条语句. 但这这很容易出错, 一旦我们错误判断了索引的范围, 就会引发 Panic\n而且在循环过程中, 也会不停的进行边界检查, 拖慢性能\n对比一下上面的, 很容易看出, for 更加安全, 高效, 简洁\n但是也不是说我们只需要 for 循环, 不然 Rust 为什么要设计 while 循环, 根据不同的场景, 选择更合适的方式\nLoop 无限循环C 或者Rust 都可以通过 while true 来实现一个无限循环, 但 Rust 又单独专门设计了一个无限循环 — loop\nrust/// 注: loop 同样返回一个 `!` 类型\nloop {\n    code\n}就 循环 这一概念而言, loop 毫无疑问是最纯粹的, 它仅仅是循环, 再无其他, 因此也是适用面最广的循环, 当然特定的场景下 for 或 while 才是更优解\n使用 loop 一定要打起精神来, 不然一个无限消耗资源的循环可能会让设备内存溢出\n对于 loop, 第一个问题就是, 如何结束循环? 接下来我们就会介绍两种控制循环的方式, 当然, 这对其他两种循环同样适用\nBreak, Continue 与 Lable对于循环, 可以使用 break 关键字强制退出循环, 也可以使用 continue 关键字结束本次循环并进入下一次循环, 这两个关键字后面也可以跟一个返回值\n也可以使用标签退出指定循环\nrust&#39;outer: loop {\n    &#39;inner: loop {\n        println!(&quot;退出外部循环&quot;)；\n        break &#39;outer\n    }\n}模式匹配match基本操作match 是一个强大的匹配模式, 接下来先看几个例子\nrustlet day = 5;\n\nmatch day {\n    0 | 6 =&gt; println!(&quot;休息日&quot;)，\n    1 ... 5 =&gt; println!(&quot;工作日&quot;)，\n    _ =&gt; println!(&quot;none&quot;),\n}| 用于匹配多个值, ... 或 ..= 用于匹配一个范围, 包括开头结尾, 因为 match 进行的是穷举性匹配, 所以需要一个 _ 匹配剩下的所有值\n可以使用 @ 来绑定一个变量\nrustlet a = 1;\nmatch a {\n    b @ 1...3 =&gt; println!(&quot;a = {}&quot;, b),\n    // 也可以给绑定的变量起一个新的名字\n    c: num @ 4...6 =&gt; println!(&quot;a = {}&quot;, num),\n    // 绑定也可以匹配多个值, 但要记得加括号\n    d @ (7 | 8) =&gt; println!(&quot;a = {}&quot;, d),\n    _ =&gt; println!(&quot;Match failed&quot;),\n}获得一个引用之前的文章我们提到可以使用 ref 获得一个引用, 这里我们再次强调, 在模式匹配中只能通过 ref 获得一个引用, 而函数声明只能用 &amp; 来获得一个引用\nrust#![feature(core_intrinsics)]\nenum Num&lt;&#39;a&gt; {\n    Nor(i32),\n    NorRef(i32),\n    Ref(&amp;&#39;a i32),\n    RefRef(&amp;&#39;a i32),\n}\n\nfn print_data(data: &amp;u32) {\n    println!(&quot;log data: {}&quot;, data);\n}\n\n// fn print_data(data: ref u32){  // expected type, found keyword `ref`\n//     println!(&quot;log data: {}&quot;, data);\n// }\n\nfn print_type&lt;T&gt;(_: T) {\n    println!(&quot;log type name: {}&quot;, unsafe { std::intrinsics::type_name::&lt;T&gt;() })\n}\n\nfn log(num: Num) {\n    match num {\n        Favour::Nor(data) =&gt; {\n            config(&amp;data);\n            print_type_name_of(data);\n        },\n        Favour::NorRef(ref data) =&gt; {\n            config(data);\n            print_type_name_of(data);\n        },\n        Favour::Ref(data) =&gt; {\n            config(data);\n            print_type_name_of(data);\n        },\n        Favour::RefRef(ref data) =&gt; {\n            config(data);\n            print_type_name_of(data);\n        }\n    }\n}\n\nfn main() {\n    log(Favour::Nor(1));\n    log(Favour::Ref(&amp;2));\n    log(Favour::NorRef(3));\n    log(Favour::RefRef(&amp;4));\n}输出结果如下:\ntxtlog data: 1\nlog type name: u32\nlog data: 2\nlog type name: &amp;u32\nlog data: 3\nlog type name: &amp;u32\nlog data: 4\nlog type name: &amp;&amp;u32通过 ref mut 在模式匹配中可以获得可变引用\nrustlet mut a = 1;\nmatch a {\n    ref mut x =&gt; println!(x),\n}解构复合类型match 可用于解构复合类型, 如定长数组, 元组, 结构体或枚举 (实际上在上面的例子中已经体现)\nrustlet point = (0, 2);\nmatch point {\n    (0, y) =&gt; println!(&quot;这个点在y轴上, 纵坐标为 {}&quot;, y),\n    (x, 0) =&gt; println!(&quot;这个点在x轴上, 横坐标为 {}&quot;, x),\n    (0, 0) =&gt; println!(&quot;这个点是原点&quot;),\n    _ =&gt; println!(&quot;这个点不在坐标轴上&quot;),\n}忽略变量可以使用 .. 来忽略变量\nruststruct Point {\n    x:i32,\n    y:i32,\n}\n\nlet point = Point {\n    x:10,\n    y:10\n}\n\nmatch point {\n    Point {x,..} =&gt;println!(&quot;x is {}&quot;,x),\n}\n\nenum Int{\n    Value(i32),\n    N\n}\n\nlet value = Int::Value(10);\n\nmatch value{\n    Int::Value(i) if i&gt;5=&gt;println!(&quot;这个数字大于5&quot;),\n    Int::Value(..)=&gt;println!(&quot;是一个数字&quot;),\n    Int::N=&gt;println!(&quot;不是数字&quot;),\n}但要注意 .. 必须是无歧义的, 比如下面的代码无法运行\nrustlet numbers = (2, 4, 8, 16, 32);\n\nmatch numbers {\n    // error: `..` can only be used once per tuple pattern\n    (.., second, ..) =&gt; {\n        println!(&quot;Some numbers: {}&quot;, second)\n    },\n}变量遮蔽无论是 match 还是接下来会提到的 if let, 它们都将开辟一个新的代码块, 这将会绑定新变量, 同名外部变量会被暂时遮蔽:\nrustlet age = Some(0); // 此时 age 是 Some(T) 类型\nmatch age { // match 作用域开始\n    // 下一行 age 是 i32 类型, 但或许我们本想使用 Some(T) 类型\n    Some(age) =&gt;  println!(&quot;匹配出来的age是{}&quot;,age),\n    _ =&gt; ()\n}// match 作用域结束\n// 此时 age 是 Some(T) 类型匹配守卫Match Guard 可以让我们在一个 match 分支模式之后额外添加一个 if 条件, 进行进一步更加精准的匹配, 这个条件也可以使用在匹配模式中创建的变量. 记住, 模式的优先级大于匹配守卫, 只有先满足模式, 才会考虑是否满足匹配守卫\nrustlet num = Some(4);\n\nmatch num {\n    Some(x) if x &gt; 0 =&gt; println!(&quot;A positive num: {}&quot;, x), // 只有这一行会打印输出\n    Some(x) =&gt; println!(&quot;A negative num: {}&quot;, x),\n    None =&gt; println!(&quot;No num&quot;),\n}当匹配模式无法提供类如 if x &gt; 0 的表达能力时可以考虑这种方式\n匹配守卫还能解决上面变量遮蔽导致无法使用外部变量的问题\nrustlet x = Some(5);\nlet y = 10;\n\nmatch x {\n    Some(50) =&gt; println!(&quot;50&quot;),\n    Some(n) if n == y =&gt; println!(&quot;Matched, n = {}&quot;, n),\n    _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),\n}上面的代码只有第三个匹配分支会打印输出. 因为第二个匹配分支中的模式不会像 Some(y) 那样引入一个覆盖外部 y 的新变量. 这意味着可以在匹配守卫中使用外部的 y. 而匹配守卫 if n == y 并不是一个模式所以没有引入新变量, 这个 y 正是 外部的 y 而不是新的覆盖变量 y\n也可以在匹配守卫中使用 | 运算符来指定多个模式, 匹配守卫的条件会作用于所有的模式\nrustlet x = 4;\nlet y = false;\n\nmatch x {\n    // 匹配守卫并非只作用于 6\n    4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),\n    _ =&gt; println!(&quot;no&quot;),\n}拓展: match! 宏这里含有许多未提到的知识, 可以先看以后的文章再回过头来看\n考虑以下这种情况\n有一个动态数组，里面存有以下枚举：\nrustenum Bin {\n    Zero,\n    One\n}\n\nfn main() {\n    let bin = vec![Bin::One, Bin::One, Bin::Zero];\n}如果想对 bin 进行过滤，只保留类型是 Bin::One 的元素, 这种做法是不行的\nrustbin.iter().filter(|b| b == Bin::One);因为无法将 x 直接跟一个枚举成员进行比较. 虽然也可以用 match 来解决, 但在迭代器链式调用中略显啰嗦, 好在 Rust 标准库提供了一个非常实用的宏: matches!, 可以将一个 表达式 跟 模式 进行匹配, 并根据是否匹配成功返回 true 或 false. 因此上面的代码可以改成这样\nrustbin.iter().filter(|b| matches!(b, Bin::One));还有许多更强大的功能\nrustlet f = &#39;f&#39;;\n// assert! 宏用于判断一个表达式是否为 true\n// 同样可以指定多个模式\nassert!(matches!(foo, &#39;A&#39;..=&#39;Z&#39; | &#39;a&#39;..=&#39;z&#39;));\n\nlet four = Some(4);\n// 同样可以使用匹配守卫\nassert!(matches!(four, Some(x) if x &gt; 2));if let 与 while letif let (单次) 与 while let (循环) 相当于精简版的 match, 用于解决一些匹配项很少或者只关心其中几个值时的匹配\nrustenum Int{\n    Value(i32),\n    N\n}\n\nlet a = Int::Value(10);\n\nif let Int::Value(v) = a {\n    println!(&quot;The value is {}&quot;, v);\n}\n\nlet mut b = Int::Value(1);\n\nwhile let Int::Value(v) = b {\n    if v&gt;3 {\n        println!(&quot;b is over 3&quot;);\n        b = N\n    } else {\n        println!(&quot;b is {:?}, add one&quot;,i);\n        b = Int::Value(i+1);\n    }\n}实际上类似 match, if let 也支持变量绑定, 而且还有一种称为 绑定时解构 的操作\n还记得我们之前也通过 let 解构过复合类型吗, 我们说过 let 也是一种匹配模式, 因此也拥有一些强大的功能, 比如, 绑定时解构\nrust#[derive(Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\n// 绑定新变量 `p`，同时对 `Point` 进行解构\nlet point = Point {x: 10, y: 5};\nif let p @ Point {x: 10, y} = point {\n    println!(&quot;x is 10 and y is {} in {:?}&quot;, y, p);\n} else {\n    println!(&quot;x was not 10 :(&quot;);\n}\n\n// 对了, 还记得我们之前也通过 `let` 解构过复合类型吗\n// 我们还说过 `let` 也是一种匹配模式, 所以 ...\nlet p @ Point {x: px, y: py } = Point {x: 10, y: 23};\nprintln!(&quot;x: {}, y: {}&quot;, px, py);\nprintln!(&quot;{:?}&quot;, p);可能存在的值Null (空值) 是一个让人又爱又恨的东西, 很多时候它都太重要了, 但是又由于空值过于灵活, 带来了无穷无尽的内存安全问题\n作为一门现代语言, 没有空值不行, 但作为一门注重安全的语言, 有空值又不好, 于是 Rust 通过枚举巧妙地解决了这个问题, 构造了一个 Option (可能存在的值)\nOption 在结构上非常类似我们上面所举的最后一个例子\nrustenum Option&lt;T&gt; {\n    Some(T),\n    None,\n}其中 T 是一个 泛型类型, 表示 任意符合限制的类型, 我们将在后面的文章提到. 总之, 一个 Option, 要么存在 Some(T) 要么是 None\n\n\n\n\n\n\n\n\n\n注: Option 的变体成员 Some 和 None 都通过 prelude 导入默认作用域了, 可以直接使用, 但不要忘记它们是来自 Option 的哦\n上面提到的 匹配模式 就是用于解构 Option 的绝佳方式\nrustlet v = Some(1);\nmatch v {\n    Some(1) =&gt; println!(&quot;One!&quot;),\n    _ =&gt; (),\n}\n\n// 当然在我们仅仅关心一个值时不要忘了这个更加简洁的写法\nif let Some(1) = v{\n    println!(&quot;One!&quot;);\n}错误处理不可恢复的错误与 panic! 宏的简单介绍面对复杂的生产环境, 我们的程序几乎不可能是毫无错误的, 比如程序自身逻辑出现严重问题. 即使程序本身正常, 谁知道用户会做出什么奇怪的操作呢, 比如一个手滑删掉了程序所依赖的动态库, 这种时候就不是很适合让我们的程序靠自身来解决这个问题, 被称为 Panic (不可恢复的错误)\n造成 Panic 有两种方式\n被动触发rustfn main() {\n    let array = [1, 2, 3];\n    println!(&quot;{}&quot;, v[10]);\n}一个经典的数组越界错误, 这时我们的程序就会被动的触发 Panic. 这在编程语言中无一例外, 都会报出严重的异常, 部分语言包括 Rust 甚至导致程序直接崩溃关闭。\n报错信息如下\ntxt$ cargo run\n   Compiling ...\n    Finished ...\n     Running ...\nthread &#39;main&#39; panicked at &#39;index out of bounds: the len is 3 but the index is 10&#39;, src/main.rs:3:20\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace报错信息很详细, 这多亏于 Rust 强大到一骑绝尘的编译器, 编译器手把手叫你写代码可不是乱吹的, 告诉我们崩溃线程, 崩溃原因, 对应的源码位置, 以及如何查看更详细报错信息的命令\n被动触发是最常见的 Panic 方式. 主动报错总是好的, 总不会有人希望代码里藏着一个随时可能会爆的雷吧\n主动调用有时候处于一些特殊原因, 比如程序依赖的重要文件丢失了, 但既靠程序自己来还原可能会带来功能膨胀, 这时我们就可以手动调用 panic! 宏, 调用后程序会打印出一个错误信息,随后开始进行栈展开, 最后清理并退出程序.\n\n\n\n\n\n\n\n\n\n切记, 一定是不可恢复的错误才能调用 panic!, 就像酒吧总不能因为客人点份炒饭就爆炸吧\nBacktrace 栈展开实际开发中, 因为函数的层层调用, 错误往往涉及到很长的调用链甚至会深入第三方库, 如果没有栈展开技术, 错误将难以追踪溯源. 还是来看这个简单的错误\nrustfn main() {\n    let v = vec![1, 2, 3];\n    v[10];\n}txtthread &#39;main&#39; panicked at &#39;index out of bounds: the len is 3 but the index is 10&#39;, src/main.rs:3:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace有人可能不以为然, 但实际上数组越界是一个非常严重的问题, 比如 C 语言中, 数组越界一样可以访问对应地址的内存, 但结果可就不是一个数组的元素了, 这种情况被称为缓冲区溢出, 并可能会导致安全漏洞.\n还是那句话, 主动报错总是好的, 比如这种情况, 如果真的访问到了一个未知的值, 这在很多时候会导致程序上的逻辑 Bug, 而众所周知, 逻辑 Bug 是最难被发现和修复的, 因此程序直接崩溃, 告诉我们问题所在, 然后我们进行修复, 这才是最合理的开发流程, 而不是把选择掩耳盗铃\n现在, 我们已经知道错误发生的位置了, 为了获取更详细的信息, 让我们按照提示使用添加一个临时环境变量, 再次运行程序:  RUST_BACKTRACE=1 cargo run (Linux&#x2F;Mac shell) 或 $env:RUST_BACKTRACE=1 ; cargo run (Windows PowerShell)\ntxtthread &#39;main&#39; panicked at &#39;index out of bounds: the len is 3 but the index is 10&#39;, src/main.rs:4:5\nstack backtrace:\n   0: rust_begin_unwind\n             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/std/src/panicking.rs:517:5\n   1: core::panicking::panic_fmt\n             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:101:14\n   2: core::panicking::panic_bounds_check\n             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:77:5\n   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index\n             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:184:10\n   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index\n             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:15:9\n   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index\n             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/alloc/src/vec/mod.rs:2465:9\n   6: world_hello::main\n             at ./src/main.rs:4:5\n   7: core::ops::function::FnOnce::call_once\n             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/ops/function.rs:227:5\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.上面打印的内容就是一次 栈展开 (栈回溯), 包含了函数调用的顺序 (逆序), 排在最顶部最后一个调用的函数是 rust_begin_unwind，该函数的目的就是进行栈展开, 并呈现这些信息给我们\n\n\n\n\n\n\n\n\n\n注: 获取到栈回溯信息需要开启 debug 标志, 只要在使用 cargo run 或 cargo build 不加 --release Flag 即可, 这两个操作默认是 Debug 运行方式. 而且栈展开信息在不同操作系统或者 Rust 版本上也有所不同\nPanic 终止方式当出现 panic! 时, 程序提供了两种方式来处理终止流程: 栈展开和直接终止。\n\n栈展开 是默认的方式, 这意味着 Rust 会回溯栈上数据和函数调用, 做更多的善后工作. 好处是可以给出充分的报错信息和栈调用信息, 便于事后的问题复盘\n直接终止 顾名思义就是不清理数据直接退出程序, 善后工作交与操作系统来负责\n\n大多数情况使用默认选择就好, 但当你关心最终编译出的二进制可执行文件大小或者进行嵌入式开发时, 那么可以尝试去使用直接终止的方式, 例如下面的配置修改 Cargo.toml 文件, 实现在 Release 模式下遇到 Panic 直接终止\ntoml[profile.release]\npanic = &#39;abort&#39;Panic 后会怎么样如果是 Main 线程 Panic, 则程序会终止, 如果是其它子线程, 则该线程终止, 不会影响 Main 线程. 因此, 尽量不要在 Main 线程中做太多任务, 可以将这些任务交由子线程去做, 防止整个程序崩溃\n可恢复的错误与 Result 枚举就像上面提到的, 遇到一些简单的错误时, 我们应该尝试着用一种更温和的方式捕获并解决这个问题, 而不是让我们的程序直接崩溃, 比如 Result 枚举, 其定义如下\nrustenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}类似于 Option, Ok 变体代表成功执行, T 泛型代表执行成功后返回的内容, Err 变体代表执行失败, E 泛型存放着错误信息. 而这两个变体也通过 prelude 导入了默认作用域, 可以直接使用\nResult 与 match 等匹配模式结合起来, 就构成了 Rust 中优雅强大健壮的错误处理系统\n举一个尝试打开文件的例子\nrustuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let f = File::open(&quot;hello.txt&quot;);\n\n    let f = match f {\n        Ok(file) =&gt; file,\n        Err(error) =&gt; match error.kind() {\n            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {\n                Ok(fc) =&gt; fc,\n                Err(e) =&gt; panic!(&quot;Problem creating the file: {:?}&quot;, e),\n            },\n            other_error =&gt; panic!(&quot;Problem opening the file: {:?}&quot;, other_error),\n        },\n    };\n}简单明了, 上面代码在匹配出 Error 并没有直接选择 Panic, 而是对 Error 进行了进一步匹配解析\n\n如果文件存在且成功打开就返回文件句柄\n如果是文件不存在错误 ErrorKind::NotFound 就创建文件, 这里创建文件. File::create 也是返回 Result, 因此继续用 match 进行匹配\n创建成功, 将新的文件句柄赋值给 f\n如果失败, 则 Panic\n\n\n剩下的错误，一律 Panic\n\n事实上这样写也有一点啰嗦. 在初识 Rust 后的一些进阶学习中, 我们会讲到 组合器 这个强大的工具\n有时, 在代码原型设计阶段我们不想处理错误, 或者我们不需要处理这个错误, 或者我们能保证这个操作不会触发错误, 那么我们就可以通过以下两个方法简化错误处理\nrustuse std::fs::File;\n\nlet f = File::open(&quot;hello.txt&quot;).unwrap();\nlet f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);其中 unwrap 方法代表直接解构 Result, 成功就返回, 不成功就 Panic. expect 方法与之类似, 只不过可以附带一段额外的错误信息\n错误传播有时我们可能不需要在某个函数内部就地解决问题, 需要把错误层层向上传递, 让上层决策者决定如何处理问题, 这个时候我们可以考虑将错误信息封装进 Result 作为函数返回值移交给上层调用者\n比如我们想要将文件的内容读取到字符串中\nrustuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_file() -&gt; Result&lt;String, io::Error&gt; {\n    let f = File::open(&quot;hello.txt&quot;);\n    let mut f = match f {\n        // 打开文件成功, 将 file 句柄绑定给 f\n        Ok(file) =&gt; file,\n        // 打开文件失败, 将错误返回(向上传播)\n        Err(e) =&gt; return Err(e),\n    };\n    // 创建动态字符串\n    let mut s = String::new();\n    // 从 f 文件句柄读取数据并写入动态字符串\n    match f.read_to_string(&amp;mut s) {\n        // 读取成功, 返回 Ok 封装的字符串\n        Ok(_) =&gt; Ok(s),\n        // 读取失败, 将错误向上传播\n        Err(e) =&gt; Err(e),\n    }\n}上面的代码很好的实现了我们的需求, 但还有一个问题 ,有些过于冗长. 幸运的是, Rust为我们提供了一个很甜的 语法糖 — ? 运算符\n下面让我们来看看这颗语法糖到底有多甜, 同样的功能用 ? 重新实现:\nrustuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    let mut f = File::open(&quot;hello.txt&quot;)?;\n    let mut s = String::new();\n    f.read_to_string(&amp;mut s)?;\n    Ok(s)\n}简洁而高效, 实际上 ? 的本质是一个宏, 实现了与 match 类似的功能, 但在某些方面更加强大\n比如 ? 是可以链式调用的, 上面的代码可以进一步缩短:\nrustuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    let mut s = String::new();\n    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;\n    // 事实上 Rust 标准库提供了 `fs::read_to_string()` 函数提供了以上一条龙服务\n    Ok(s)\n}关于 ? 的拓展比如一个设计良好的系统中, 肯定有自定义的错误特征, 错误之间存在着上下级关系, 例如标准库中的 std::io::Error 和 std::error::Error, 前者是 IO 相关的错误结构体, 而后者是一个最最通用的 标准错误特征, 同时前者实现了后者, 因此 std::io::Error 可以转换为 std:error::Error\n明白了以上的错误转换就能更好地理解 ? 的强大了, 首先它可以自动进行类型提升\nrustfn open_file() -&gt; Result&lt;File, Box&lt;dyn std::error::Error&gt;&gt; {\n    let mut f = File::open(&quot;hello.txt&quot;)?;\n    Ok(f)\n}上面代码中 File::open 报错时返回的错误是 std::io::Error 类型, 但是 open_file 函数最终返回了一个实现了 std::error::Error 的 Trait Object. 一个错误类型通过 ? 返回成了另一个错误类型. 这是因为标准库中有一个 From trait, 该 Trait 有一个 from 方法用于把一个类型转成另外一个类型, 而 ? 可以自动调用该方法, 然后进行隐式类型转换. 因此只要函数返回的错误 ReturnError 实现了 From&lt;OtherError&gt; trait, 那么 ? 就会自动把 OtherError 转换为 ReturnError\n这种转换非常好用, 意味着你可以构建一个大而全的 ReturnError 来覆盖所有错误类型, 只需为各种子错误类型实现这种转换即可\n实际上 ? 不仅仅可以用于 Result 的传播, 还能用于 Option 的传播. 成功返回 Some(T), 失败返回 None\n最后有两点需要注意:\n\n? 需要一个变量来承载正确的值, 只有发生了错误才能直接返回, 因此类似 func()? 的表达式作为最终的返回值是不可以的\n? 只能在以 Result 为返回值的函数中使用. 那是不是代表着 main 函数与 ? 无缘了呢? 不会的, 事实上 Rust 也支持返回 Result 的 main 函数:\n\nrustuse std::error::Error;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    Ok(())\n}这样就能使用 ? 了. 可以看到返回的错误是 Box&lt;dyn Error&gt; , 因为 std::error:Error 是 Rust 中抽象层次最高的错误, 所以就算 main 函数中调用任何标准库函数发生错误, 都可以进行返回。\n至于 main 函数可以有多种返回值, 那是因为实现了 std::process::Termination trait , 只是目前为止该特征尚未稳定\n最后提一下, 事实上在 ? 之前, Rust 有一个 try! 宏用于捕获错误, 只是如今这个宏在所有方面都不如 ?, 因此还是不要使用的好\n","slug":"RustCourse-05","date":"2021-06-08T08:27:33.000Z","categories_index":"Course","tags_index":"Rust","author_index":"芳塔洛斯"},{"id":"4982b3ac55a9e6b7056efc0b28169dff","title":"初识 Rust(3) | 变量, 常量, 语句和表达式, 原生类型","content":"变量变量绑定在多数语言中, 我们可能会用类似 var a = 1 的语句将Value 赋值 (assignment) 给 Variable\n而在 Rust 中我们使用 let 关键字将 Value 绑定 (Bind) 到 Variable\n为什么要引入一个新的名字呢? 这里就涉及 Rust 为了实现内存安全首创的最核心的语言机制 — 所有权\n简单来讲, 任何 Memory Object (内存对象) 都有一个 Owner (主人), 而且一般情况下一个内存对象有且完全属于一个主人, 绑定这个过程就是把这个内存对象绑定给一个变量\n既然是绑定, 那么就可以很容易的想到, 内存对象是可以被迫离开原来的主人被绑定到一个新的变量的, 而且根据字面意思, 该内存对象之前的主人就会丧失对其的所有权, 比起赋值, 用绑定来描述这个过程更加形象, 不是吗?\n至于所有权这个概念, 让我们在以后的部分加以解释, 现在让我们先来看几个例子:\nrustfn main() {\n    let a = 5; // 类型推断\n    let b: i32 = 10; // 显式声明\n    let c = 10i32; // 另一种显式声明, num + type\n    let d = c; // 整数类型默认实现了 Copy trait, 所以下面变量 c 仍可使用\n\n    //a = 10;   //报错, 变量默认不可更改\n\n    // 编译器会对未使用的变量绑定产生警告；可以给变量名加上下划线前缀来消除警告。\n    let _unused = 3u32;\n}Rust 通过静态类型确保类型安全. 变量绑定可以在声明时注明类型, 不过在多数情况下, 编译器能够从上下文推导出变量的类型, 从而大大减少了类型注释的工作\n变量解构let 不只是用于声明变量, 绑定变量. 实际上 let 是一种 匹配模式 (Match Pattern), 拥有十分强大的功能\nrustfn main() {\n    let (a, mut b): (bool, bool) = (true, false);\n    println!(&quot;a = {}, b = {}&quot;, a, b);\n\n    // 解构赋值机制\n    let (a, b);\n    // _ 代表匹配一个值, 但是我们不关心且不需要这个值, 因此没有使用一个变量名而是使用了 _ 表示丢弃\n    (a, b, _) = (1, 2, 3);\n    println!(&quot;a = {}, b = {}&quot;, a, b);\n}变量遮蔽 (shadowing)其实在上面的例子我们就能看到, 连续声明了两次同名的变量. 很明显, Rust 允许声明同名变量, 这一过程称为 遮蔽 (shadowing), 在后面声明的变量会遮蔽掉前面声明的\nrustfn main() {\n    let a = 1;\n    // 在main函数的作用域内对之前的变量进行遮蔽\n    let a = a + 1;\n\n    {\n        // 在当前的花括号作用域内, 对之前的变量进行遮蔽, 不影响外部作用域\n        let a = a * 2;\n        println!(&quot;The value of a in the inner scope is: {}&quot;, a);\n    }\n\n    println!(&quot;The value of a is: {}&quot;, a);\n}这将会输出\ntxtThe value of a in the inner scope is: 4\nThe value of x is: 2但这并不代表我们改变了变量, 而是产生并绑定了一个新的变量, 涉及新的内存分配\n变量遮蔽往往能节省变量名的使用, 让语义更加清晰\n比如当我们接收了一段空格但只关心空格的数量\nrust// 字符串类型\nlet spaces = &quot;   &quot;;\n// usize数值类型\n// 这样可以节省一个类似于 spaces_len 的变量名\nlet spaces = spaces.len();默认不可变与可变变量从上面的例子中可以看到 Rust 中的变量默认居然是不可变的, 这似乎有违常识和字面意思\n但其实, 默认不可变的变量能带来很多好处, 首先方便了编译器的类型推断, 然后让逻辑更加清晰, 能一眼看出哪些变量会在接下来发生变化\n对于某些情景, 可以避免一些 Bug, 比如一个被多次使用的变量, 我们本希望它不改变, 但却不小心在某一处代码改变了它\n实际上我们日常的代码中, 真正发生了改变的变量并不是特别多, 很多时候我们真的也需要一个 “不可变的变量”, 默认不可变就更加方便编译器进行检查, 既提高了效率, 也提高了内存安全性\n在变量名前加上 mut 关键字, 即可让变量变为可变变量, 简单且灵活\n通过显示声明可变变量, 能够强制让我们在写代码时思考这个变量是否真的需要可变\nrustfn main() {\n    let mut a :f64 = 2.0;\n    pritnln!(&quot;{}&quot;,a);\n    // 改变 a 绑定的值\n    // 直接修改对应地址的内存, 因此比遮蔽效率更高\n    a = a + 1.0;\n    println!(&quot;{}&quot;,a);\n    // 通过变量遮蔽重新将a绑定为不可变\n    let a = a;\n\n    // // 之前的例子\n    // // 这是不可以的, 无法将一个 usize 类型绑定给 &amp;str\n    // let mut spaces = &quot;   &quot;;\n    // spaces = spaces.len();\n}虽然变量默认不可变, 但不可以把不可变变量理解为常量. 变量是可能不会发生改变的量, 而常量是永远不会改变的量, 在 Rust 中也有专门的声明方式\n常量Rust 有两种常量, 可以在任意作用域声明, 包括全局作用域. 它们都需要显式的类型声明:\n\nconst: 不可改变的值, 通常情况下我们使用这种常量\nstatic: 通常称为静态变量, 具有 &#39;static 生命周期, 从程序启动到程序结束，即在整个程序运行期间都存在, 静态变量是全局的，可以在整个程序的任何地方访问\n有个特例是字符串字面量 &amp;str. 它可以不经改动就被赋给一个 static 变量, 因为它的类型标记 &amp;&#39;static str 就包含了所要求的生命周期 &#39;static. 其他的引用类型都必须特地声明, 使之拥有 &#39;static 生命周期\nstatic mut: 可变静态变量, 一种特殊的静态变量, 可以在运行时修改其值, 但这不等同于变量, 只能在 unsafe 块中操作\n可变静态变量通常用于在整个程序的执行过程中共享和修改全局状态. 一般情况下, 使用可变静态变量要慎重, 因为全局状态的可变性可能导致并发和竞争条件的问题. 然而有些场景下确实需要在全局范围内维护一些状态, 比如一个全局计数器, 这时可变静态变量是一种合理的选择\n\n\n\n在实际开发中, 最好将硬编码的值保存为常量, 这样即使后期需要修改, 也只需要修改一次\nrust// 全局变量是在在所有其他作用域之外声明的。\nstatic LANGUAGE: &amp;&#39;static str = &quot;Rust&quot;;\nconst  THRESHOLD: i32 = 10;\nthreshold\nfn is_big(n: i32) -&gt; bool {\n    // 在一般函数中访问常量\n    n &gt; THRESHOLD\n}\n\nfn main() {\n    let n = 16;\n\n    // 在 main 函数中访问常量\n    println!(&quot;This is {}&quot;, LANGUAGE);\n    println!(&quot;The threshold is {}&quot;, THRESHOLD);\n    println!(&quot;{} is {}&quot;, n, if is_big(n) { &quot;big&quot; } else { &quot;small&quot; });\n\n    // 报错！不能修改一个 `const` 常量\n    THRESHOLD = 5;\n    // ^ 注释掉此行\n}语句与表达式语句会执行一些操作但是不会返回一个值, 而表达式会在求值后返回一个值\n对 Rust 而言这种基于语句 (statement) 和表达式(expression) 的方式是非常重要的, 很多其它语言而言往往不区分这两个概念. 基于表达式是函数式语言的重要特征, 表达式总要返回值\n语句rustlet a = 0;\nlet b = (1,2);形如这种, 它们完成了一个具体的操作, 但是并没有返回值，因此是语句\n由于 let 是语句, 因此不能将 let 语句赋值给其它值, 如下形式是错误的\nrustlet b = (let a = 0);但是, let 作为表达式已经是试验功能了, 也许不久的将来, 上面的代码可以被真正编译通过\n表达式表达式会进行求值, 然后返回一个值\n表达式可以成为语句的一部分, 例如 let a = 0; 中 0 就是一个表达式, 它所求的值就是 0 (有些反直觉, 但是确实是表达式)\n调用函数, 宏都是表达式, 用花括号包裹最终返回一个值的语句块也是表达式. 总之, 有返回值就是表达式:\nrustlet y = {\n    let x = 3;\n    x + 1\n};\n\nprintln!(&quot;The value of y is: {}&quot;, y);如果在上面的 x+1 后面加上一个 ; 就表示丢弃返回值, 将会返回元类型 ()\n原生类型在上面的例子中, 我们见到了 i32 f64 bool等数据类型, 它们是 Rust 的原生类型, Rust 的原生类型有以下几类:\n\n布尔类型: 只有两个值, true 和 false\n字符类型: 表示单个 Unicode 字符, 储存为 u8\n数值类型: 有符号整型 (i8 i16 i32 i64 i128 isize), 无符号整型 (u8 u16 u32 u64 u128 usize) 和浮点型 (f32 f64)\n字符串类型: 其底层为不定长类型 str, 更常用的是字符串切片 &amp;str 和堆分配字符串 String, 其中 String 并不是原生类型, 字符串切片是静态的, 有固定大小且不可改变, 堆分配字符串是可变的\n数组: 有固定大小, 且元素为同一类型, 可表示为 [T; N]\n切片: 引用数组的一部分数据且无需复制, 可表示为 &amp;[T]\n元组: 有固定大小, 元素类型可不同的有序列表\n指针: 最底层是裸指针 *const T 和 *mut T, 解引用它们是不安全的, 需要放到 unsafe 块里\n函数: 本质是一个函数指针\n元类型: 其唯一的值是 ()\n\nrust// 如果没有必要，以后的示例将不会有 fn main() {} 等\n// 下面按顺序展示一下这些类型\nlet t = true;\nlet f: bool = false;\n\nlet c = &#39;c&#39;;\n\nlet x = 100;\nlet y: u32 = 123_456;\nlet z: f64 = 1.2e+3; // 浮点数可用科学计数法\nlet zero = z.abs_sub(123.4);\nlet bin = 0b111_000;\nlet oct = 0o1234_5670;\nlet hex = 0xf23a9;\n\nlet strs = &quot;Hello world&quot;;\nlet strs: &amp;&#39;static str = &quot;Hello, world!&quot;;\n// 这不是原生类型哦\nlet mut string = strs.to_string();\n\nlet a = [0, 1, 2, 3];\nlet b = &amp;a[1..3];\nlet mut ten_zeros: [i64;10] = [0; 10];\n\nlet tuple: (i32,&amp;str) = (50, &quot;hello&quot;);\nlet (fifty, _) = tuple;\nlet hello = tuple.1;\n\nlet x = 5;\nlet p = &amp;x as *const i32;\nlet point_at = unsafe{*p};\n\nfn func(x:i32) -&gt; i32 {\n    x\n}\nlet function: fn(i32) -&gt; i32 = func;有几点是需要特别注意的:\n\n数值类型可以使用 _ 来增加可读性。\nRust 支持单字节字符 b&#39;H&#39; 和单字节字符串 b&quot;Hello&quot;, 仅限于 ASCII 字符. 使用 r#&quot;...&quot;# 标记来表示原始字符串, 不需要对特殊字符进行转义\nstr 类型很少使用, &amp;str 类型使用的较多, 本质是 [u8] 类型的切片 &amp;[u8], 是一种大小固定的类型, 之前提到过常见的字符串字面值就是带有 &#39;static 生命周期的 &amp;str 类型\n使用 &amp; 符号将 String 类型转换成 &amp;str 类型很容易, 但由于 String 不是原生类型, 使用 to_string() 方法将 &amp;str 转换到 String 类型 涉及到高昂的分配内存, 除非很有必要否则不要这么做\n数组的长度是 不可变的, 动态的数组 (Vec) 将会在之后提到, 可以通过 vec![] 宏或者 Vec::new() 声明\n元组可以使用 == 和 != 运算符来判断是否相同\n不多于 32 个元素的数组和不多于 12 个元素的元组在值传递时是自动复制的\nRust 不提供原生类型之间的隐式转换, 只能使用 as 关键字显式转换。\n可以使用 type 关键字定义某个类型的别名, 并且应该采用驼峰命名法, 这在解决非常长的变量名时非常有用, 最常见的时 impl 块中的 Self 别名\n\nrustlet decimal = 65.4321_f32;\nlet integer = decimal as u8;\nlet character = integer as char;\n\ntype Color = (u8, u8, u8);\nlet black: Color = (0, 0, 0);数组与切片这两个在原生类型中稍复杂一点, 下面让我们具体的学习一下这些类型\n数组用于储存相同类型的数据集, [T; N] 表示一个 T 类型, N 个元素的数组, 数组的大小必须固定, 需要在编译的时候确定下来\nrustlet mut array :[i32; 3]= [0; 3];\narray[1] = 1;\narray[2] = 2;\nprintln!(&quot;{}&quot;, array[2]);array[1] = 2 的意思是将索引为 1 的元素的值改为 2, 需要注意的是 Rust 就像大多数语言那样, 数组第一个元素的索引为 0\n切片 (slice) 类型和数组类似, 但其大小在编译时是不确定的. 切片是一个 双字对象, 第一个字是一个指向数据的指针, 第二个字是切片的 长度. 这个 “字” 的宽度和 usize 相同, slice 可以用来借用数组的一部分, 类型标记为 &amp;[T]\nrustuse std::mem;\n\n// 此函数借用一个 slice\nfn analyze_slice(slice: &amp;[i32]) {\n    println!(&quot;The first element of this slice is {}&quot;, slice[0]);\n    println!(&quot;The slice has {} element&quot;, slice.len());\n}\n\nfn main() {\n    let xs: [i32; 5] = [1, 2, 3, 4, 5];\n    let ys: [i32; 500] = [0; 500];\n\n    println!(&quot;The first element of this array is {}&quot;, xs[0]);\n    println!(&quot;The second element of this array is  {}&quot;, xs[1]);\n\n    println!(&quot;The length of this array is {}&quot;, xs.len());\n\n    // 数组是在栈中分配的\n    println!(&quot;The array occupied {} bytes&quot;, mem::size_of_val(&amp;xs));\n\n    println!(&quot;borrow the whole array as a slice&quot;);\n    // 直接借用整个数组\n    analyze_slice(&amp;xs);\n\n    // 也可以指向数组的一部分\n    println!(&quot;borrow a section of the array as a slice&quot;);\n    analyze_slice(&amp;ys[1 .. 4]);\n\n    // 越界的下标会引发致命错误 (panic)\n    println!(&quot;{}&quot;, xs[5]);\n}","slug":"RustCourse-03","date":"2021-06-08T04:10:27.000Z","categories_index":"Course","tags_index":"Rust","author_index":"芳塔洛斯"},{"id":"692ddd8a7f3465e5861ddef99bf86d5f","title":"初识 Rust(4) | 作用域, 所有权机制, 函数与返回值, 复合类型, Module 与可见性","content":"变量作用域这是一个简单的概念, 在绝大多数编程语言中都有作用域, 且几乎相同, 让我们通过一个小例子来理解\nrust{ // a 在这里尚未声明\n    let a = 0; // a 的作用域从这里开始\n    { // b 在这里尚未声明, a 在这里仍然有效\n        let b = 0; // b 的作用域从这里开始\n        // 使用 b\n    } // b 的作用域到此结束, 不再有效\n    // 使用 a\n} // a 的作用域到此结束, 不再有效\n所有权机制程序的本质就是计算机按照一定的规则来操作内存, 如何申请新的内存, 释放不必要的内存, 保证需要的内存时刻可用, 成为了所有编程语言的重中之重\n如何管理内存, 在编程语言的发展中摸索出了两条主流做法:\n\n手动管理内存, 如 C&#x2F;C++, 需要通过函数调用来申请和释放内存, 心智负担最大, 但性能最高, 新生的 Zig 语言更是一个典型, 甚至没有隐式的内存分配\nGC (垃圾回收机制),如 Java, 新生的 Go, 通过在程序运行期间不断寻找不再需要的内存并释放, 心智负担最小, 但性能一般较低\n\n而 Rust 语言探索出了第三条方法, 就是我们要介绍的 所有权机制: 通过指定一系列规则, 让编译器在编辑期就做好绝大多数内存安全检查, 对于初学者心智负担较大, 但这种检查只发生在编译期, 因此对于程序运行时没有任何性能损失\n由于这是一个新的概念, 无论有无编程基础都需要一段时间来习惯, 而一旦掌握这些规则, 写起来会越发顺手, 海阔天空\n一段内存不安全的 C 代码cint* return_one() {\n    int one = 1; // one 作用域的开始\n    char *hello = &quot;hello&quot;; // hello 作用域的开始\n    return &amp;one; // 尝试返回一个在函数内部创建的值得引用\n} // one 和 hello 的作用域结束, 内存被回收销毁虽然这段代码可以被编译, 但事实上充满了内存安全问题\n函数内部创建 one 这个变量并存储在 栈 上, 但栈上的内存在离开作用域后会被系统回收, 而最后函数返回 one 的地址, 这段地址将会指向一片未知的空间, 这就是 Dangling Pointer (悬垂引用), 最后获得的 one 究竟是什么是无法预知的\n随后, 变量 hello, 这这常量字符串将会被编码到常量区, 但这个字符串并没有任何作用, 可位于常量区的内存将会在整个程序结束后才被回收\n根据微软公开的报告, 近 70% 的 Bug 都是 内存安全问题, 可见这个问题影响之深远.\n但随着 Rust 的出现, 这类问题几乎可以被杜绝, 这到底是如何做到的呢\n预备知识: Stack and Heap (堆栈)堆栈是内存的两种不同形式, 在大多数现代语言中无需了解, 但 Rust 作为一门偏底层的系统级语言, 以及为了更好的了解所有权机制, 了解堆栈, 知道内存分配在何处是十分重要的, 这将直接影响程序的性能\n栈存储在栈中的内存 先进后出 就像在一根螺丝上拧上一个个螺母, 不可能在最后拧上的螺母被取下之前去除螺丝上的第一个螺母\n向栈中存入数据称为 进栈或压栈 (Push), 取出数据称为 出栈 (Pop)\n栈要求每一个数据的大小都是已知且固定的, 以方便顺序压入和取出\n堆堆主要用于弥补栈的不足, 用于存储大小未知, 或者可能发生改变的数据\n存入数据时, 堆会寻找一块足够大的空间, 将其标记为已使用, 并返回一个指向这里的 内存地址 (也称指针 Pointer), 这个过程称为 分配 (Allocating), 随后将返回的内存地址压入栈中, 后续通过访问栈中的指针来访问实际内存\n性能对比很容易发现, 栈是一种更高效的内存分配方式:\n\n写入数据: 因为每次压入新的数据无需分配新的空间, 只需要在栈顶进行操作即可, 而堆分配需要寻找空间, 标记空间, 为下一次分配作准备等等\n读取数据: 得益于 CPU 高速 Cache, 栈上的内存多数时候可以直接存放到 Catch, 减少 CPU 对内存的直接访问, 有时可以带来数十倍的性能差距. 而堆内存只能存储在内存中, 而且需要先访问栈获得指针才能使用\n\n总结在栈中分配的内存, 在函数调用时顺序压入, 在函数调用结束时逆序弹出, 内存失效, 此时再进行引用操作就会产生悬垂引用\n而堆上的内存缺乏组织, 因此对堆内存的追踪管理时十分重要的, 否则将会产生 内存泄漏, 导致一部分内存永远无法通过程序自身进行回收\n而 Rust 的所有权机制就为解决以上这些问题提供了强大的保障\n最后, 再大多数语言, 以及 Rust 开发中, 都不是必须理解堆栈的原理\n但理解这些, 对我们 剖析所有权 的工作原理有很大的帮助\n所有权原则Rust 为了实现所有权内存管理, 在编译器层面制定了三条规则:\n\n\n\n\n\n\n\n\n\n\n每个值都被一个变量所拥有, 称为 Owner\n每个值在同一时间仅能被一个 Owner 所拥有\n当Owner 离开作用域时, 这个值将被 Drop (丢弃)\n\n这里我们先用 String 类型进行举例, 详细内容将会在后面的文章介绍\nRust 中最常用的字符串之一 &amp;str 我们已经见过了, 它将被硬编码到程序里. 字符串字面量很好用, 但也有一些缺陷, 比如, 它无法被改变\n这种时候就需要可变长度字符串 String 类型了\n可以通过标准库中的函数来创建它\nrustlet hello = String::from(&quot;Hello&quot;);下面让我们以 String 为基础了解一下变量绑定背后的事\n转移所有权先来看看原生类型\nrustlet a = 1;\nlet b = a;很简单, 首先将值 1 绑定给 a, 接下来 Copy (拷贝) a 的值并绑定给 b, 这样 a 和 b 的值均为 1\n因为原生类型都是大小固定的简单值, 在后面的文章我们会了解到他们都实现了 Copy trait, 因此这两个变量是通过自动拷贝进行变量绑定的, 整个过程完全在栈上完成. 对这种简单值得拷贝并不会带来性能影响而且速度非常快, 比如示例中得 i32 类型, 只需要复制 4 个字节得内存即可\n接下来看看 String 类型\nrustlet a = String::from(&quot;Hello&quot;);\nlet b = a;看起来似乎和上面完全一样, 但实际上背后的工作流程完全不同\nString 是一个复杂类型, 为了实现可变, 必须被分配到堆上, 因此这个类型由 指向堆内存得指针, 字符串长度, 字符串容量 组成\n显而易见, 如果要完全拷贝 String 与 ,实际储存在堆上的字节数组, 涉及到内存分配, 对性能会带来很大的影响\n但如果只拷贝 String 类型本身, 那么就只需要拷贝以上三个内存大小固定且已知得量即可, 方便快捷, 所以 Rust 毫无疑问的选择了这一种做法\n但这带来一个新的问题, 想想所有权原则的第二条, 那么此时, 将会有两个指针指向同一片堆内存, 即一个值有了两个 Owner. 但是这又如何呢\n想象一下, 如果这件事发生了, 当 a 离开作用域时, 对应的内存被 Drop, 而当 b 离开作用域时, 程序会尝试在已被 Drop 的内存上再次进行 Drop, 这被称为 Double Free (二次释放) 错误, 同样可能导致内存安全问题\n因此, Rust 的解决方式是, 将 a 赋值给 b 的同时, 将 a 手中的 所有权转交给 了 b, 此时 a 不再有效, 原来的值只有 b 一个 Owner, 所以以下的代码无法运行\nrustlet a = String::from(&quot;Hello&quot;);\nlet b = a;\nprintln!(&quot;{}, world!&quot;, a);如果你有一些编程基础, 可能听过类似 Shallow Copy (浅拷贝) 和 Deep Copy (深拷贝), 那么 String 类型的这种转移所有权的机制看起来有点像浅拷贝, 但是别忘了在 a 赋值给 b 后 a 的值就失效了, 因此这里我们用一个更形象的说法, 将这个操作称之为 Move (移动)\n了解了这些, 就应该能更清楚的明白为什么 Rust 称呼 let valuable = value 为 绑定 而非 赋值 了吧\n而事实上, Rust 中也有与深拷贝和浅拷贝对应的概念\n克隆Clone 对应着一般意义上的深拷贝, Rust 永远不会自动执行这一过程, 深拷贝必须是显示的, 比如 String 类型如果真的有必要进行深度复制, 可以使用 clone 方法, 当然, 这涉及到高昂的内存分配, 请谨慎使用\nrustlet a = String::from(&quot;Hello&quot;);\nlet b = a.clone();\nprintln!(&quot;a = {}, b = {}&quot;, a, b);对于其他类型的深拷贝, 可能需要实现 Clone trait\n拷贝Copy 对应着一般意义上的浅拷贝, 这只发生在栈上, 因此性能很高\n让我们再看一遍字符串字面量\nrustlet a = &quot;Hello&quot;;\nlet b = a;\nprintln!(&quot;{}, world!&quot;, a);如果参考之前的 String 的例子, 没有调用 clone 方法那这段代码也应该报错才是\n但这和之前的例子有一个本质上的区别: 在 String 的例子中 a 是持有所有权的, 而这个例子中 a 只是引用了硬编码在二进制中的字符串 &quot;Hello&quot;, 并没有持有所有权\n因此 let b = a 中, 仅仅是对该引用进行了拷贝, 此时 a 和 b 都引用了同一个字符串\n能进行拷贝的值都需要实现 Copy trait, 实现了这个 Trait 的类型主要有以下这些: 任何基本类型的组合, 不需要分配内存或某种形式资源的类型\n具体如下:\n\n所有整数类型, 如 i32\n布尔类型 bool\n所有浮点数类型, 如 f64\n字符类型 char\n元组, 当且仅当其包含所有元素的类型也都是 Copy 的时候\n不可变引用 &amp;T ,例如上面的最后一个例子, 但是注意, 可变引用 &amp;mut T 是不可以 Copy 的\n\n引用与借用在上面的例子中, 我们提到了一个概念 — 引用\n事实上, 如果仅仅支持通过移动所有权来获得一个值, 程序将变得更加复杂, 所幸, Rust 也像大多数语言那样, 提供了对某个变量的引用. 只不过, 在 Rust 中, 我们更习惯将它称为 Borrowing (借用), 就像字面意思, 有借有还, 而且 借 能发生的前提是这个量是有主人的\n通过 &amp; 运算符可以获得一个借用, 或者说常规意义上的 引用, 这是一个指针类型, 指向了对象存储的内存地址, 引用仅仅允许使用该值, 而没有所有权\n引用默认是不可变的, 离开作用域不会导致值的 Drop\nrustlet x = 0;\n{\n    let y = &amp;x;\n    // Do something with y\n} // y 离开作用域但无事发生\n// x 仍然可用\n// assert_eq 宏用于判断两个变量是否完全相同\nassert_eq!(0, x);Rust 中还提供了一个专门的 Reference (引用) 关键字 ref, 这与 &amp; 有什么区别呢? 举一个例子, 就像我们写作文引用名人名言那样, 有的时候实在想不出来了, 那就引用一个不存在的名人吧 (你说对吧, 沃斯机所得先生). ref 就允许在对象被声明之前先获得一个引用\nrust// 下面就展示了两者的区别\nlet ref a: i32;\na = &amp;3;\nlet b = &amp;2;但是需要注意一点, ref 只能用于变量声明, 不能用来声明类型, 比如 &amp;i32 是一个合法的引用类型, 但 ref i32 不是\n事实上, 和 ref 与接下来要提到的 * 一样, &amp; 同样可以用于变量声明, 比如:\nrust// &amp;a 这个整体是一个 &amp;i32 类型\nlet &amp;a = 0;关于 ref 与 &amp; 的细节问题可以看下面这个例子\nrust// 注意, 目前这段代码只能在 Nightly 版本运行\n#![feature(core_intrinsics)]\n\nfn main() {\n    let x = &amp;false;\n    print_type_name_of(x);\n\n    let &amp;y = &amp;false;\n    print_type_name_of(y);\n\n    let ref z = &amp;false;\n    print_type_name_of(z);\n}\n\nfn print_type_name_of&lt;T&gt;(_: T) {\n    println!(&quot;The type of the value is {}&quot;, unsafe { std::intrinsics::type_name::&lt;T&gt;() })\n}运行结果如下:\ntxtThe type of the value is &amp;bool\nThe type of the value is bool\nThe type of the value is &amp;&amp;bool其中第二条是最有趣的, 可以理解为 y 的引用是一个 Bool 类型的引用, 所以 y 是 Bool 类型, 似乎也有一点解引用的味道\n小小的总结一下:\n\n\n\n\n\n\n\n\n\n作用于表达式, &amp; 表示借用, ref 无效作用于变量绑定, &amp; 类似于下面会提到的 *, ref 表示引用类型作用于类型声明, &amp; 表示引用类型, ref 无效作用于模式匹配, &amp; 无效, ref 表示引用类型 (这将会在后面的文章提到)\n解引用可以通过 * 运算符进行解引用, 来访问原始对象\nrustlet x = 0;\nlet y = &amp;x;\nassert_eq!(0, *y);可变引用通过 &amp;mut (或者 ref mut) 来获得一个可变引用, 当然, 被引用的值也应该是可变的\nrustlet mut a = 1;\nlet b = &amp;mut a;\n*b = 2\nprintln!(&quot;{}&quot;, b);但要注意一点, 在 不存在可变引用 的情况下不可变引用可以存在 任意多个\n而一旦存在可变引用, 就 不能存在 不可变引用, 且 同一个作用域 只能有一个可变引用\n前一个很好理解, 毕竟我们也不希望一个不可变的引用在某处突然莫名其妙的被修改了\n后一个对新手来说也是一个重难点, 被称为 Borrow Checker (编译器借用检查机制)\n这种限制的好处就是使 Rust 在编译期就避免数据竞争, 数据竞争可由以下行为造成:\n\n两个或更多的指针同时访问同一数据\n至少有一个指针被用来写入数据\n没有同步数据访问的机制\n\n数据竞争会导致 UB(未定义行为), 这种行为很可能超出我们的预期, 难以在运行时追踪, 并且难以诊断和修复, 所有 Rust 为了避免了这种情况直接拒绝编译存在数据竞争的代码\n但有的时候, 出于一些需要, 可能需要存在对变量的可变引用和不可变引用, 只要这两个不是同时发生就好\n\n\n\n\n\n\n\n\n\n在 Rust 1.31 以后, 变量的作用域持续于整个 {}, 而引用不同, 在最后一次被使用后即离开作用域\nrustlet mut s = String::from(&quot;hello&quot;);\n\nlet ref1 = &amp;s;\nprintln!(&quot;{}, world!&quot;, r1);\n// 在 Rust 1.31 以后, r1 作用域在这里结束, 所以下面我们可以创建一个可变引用\n\nlet r2 = &amp;mut s;\nprintln!(&quot;{}, world!&quot;, r2);这种编译器优化行为被称为 Non-Lexical Lifetimes (NLL), 专门用于找到某个引用在作用域结束前就不再被使用的代码位置\n或者需要多个可变引用, 就像上面提到的 “同一作用域”, 我们可以通过 {} 开辟新的作用域来实现这个需求\nrustlet mut hello = String::from(&quot;hello&quot;);\n\n{\n    let ref1 = &amp;mut s;\n\n} // r1 在这里被 Drop, 所以我们可以创建一个新的可变引用\n\nlet ref2 = &amp;mut s;悬垂引用在本文的开头就提到了这个概念. Rust 编译器的 借用检查 可以确保引用永远也不会变成悬垂状态: 当你获取数据的引用后, 编译器会检查以确保数据不会在引用结束前被释放. 要想释放数据, 必须先停止其引用的使用\nrustlet reference_to_nothing = {\n    let strs = String::from(&quot;hello&quot;);\n    // 下面这一行无法运行!\n    &amp;strs;\n    // 改成这样移动所有权才可以\n    // strs\n}总结\n\n\n\n\n\n\n\n\n\n每个值都被一个变量所拥有, 称为 Owner\n每个值在同一时间仅能被一个 Owner 所拥有\n当Owner 离开作用域时, 这个值将被 Drop (丢弃)\n同一时刻, 对一个值要么拥有一个可变引用, 要么拥有任意个不可变引用\n\n介绍完所有权, 就方便我们介绍函数与一些复杂的类型了\n函数函数签名与声明rustfn function_name(arg: arg_type, ...) -&gt; return_type{\n    body\n}函数通过 fn 关键字声明, 后跟一个函数名称, 采用蛇形命名法, 小括号是 必须 的, 内部的参数是可选的, 参数需要有参数名称和参数类型, 多个参数通过 , 隔开. -&gt; return_type 表示返回一个值, 同样是可选的, 不需要名称, 只需要注明类型, 但注意, 一次 最多只能返回一个值, 多个返回值可以通过 返回元组 来实现, 最后必须跟上一个 {} 函数体\n函数声明的位置随意, 全局甚至在另一个函数内部, 即使在调用函数后才声明也无所谓, 只要有定义即可, Rust 不关心我们把函数放在哪\n函数默认会将最后一条表达式返回, 如果有需要也可以通过 return 关键字在任意位置提前返回\nrustfn return_one() -&gt; i32 {\n    let one = 1;\n    one\n}\n\nfn return_two() -&gt; i32 {\n    return 2;\n    println!(&quot;This will print nothing&quot;);\n}函数调用函数调用很简单, 只需要函数名后跟小括号, 内部按顺序传入参数即可\nrustfn add(num1: i32, num2: i32) -&gt; i32 {\n    num1 + num2\n}\n\nlet two = return_one(1, 1);特殊的返回类型无返回值实际上对于每一个无返回值的函数, 都隐式的返回了一个 单元类型(), 本质是一个零长度的元组, 没有任何作用, 仅仅表示一个函数没有返回值\n实际上以分号 ; 结尾的表达式同样隐式的返回了这个类型\nrustfn return_nothing(){\n    println!(&quot;Return nothing&quot;);\n}\n// 显式指定, 但谁会闲得无聊这样做呢\nfn return_nothing() -&gt; () {\n    println!(&quot;Return nothing&quot;);\n}永不返回的发散函数当用 ! 作函数返回类型的时候, 表示该函数永不返回 (diverge function), 这种语法往往用做会导致程序崩溃的函数\nrustfn dead_end() -&gt; ! {\n    panic!(&quot;Never return&quot;);\n}函数传值与所有权将值传入函数传出一样会发生 移动 或 复制\nrustfn main() {\n    let strs = String::from(&quot;hello&quot;); // strs 进入作用域\n    takes_ownership(strs); // strs 的所有权移动到函数里\n    // strs 不再有效\n    let num = 0; // num 进入作用域\n    copy(num); // num 应该移动函数里, 但 i32 实现了 Copy 所以在后面可继续使用 num\n\n} // 这里 num 先被 Drop, 然后是 strs, 但 strs 的所有权已被移走\n\nfn takes_ownership(strs: String) { // strs 进入作用域\n    println!(&quot;{}&quot;, strs);\n} // strs 被 Drop\n\nfn copy(num: i32) { // num 进入作用域\n    println!(&quot;{}&quot;, some_integer);\n} // num 被 Drop返回值也同理\nrustfn main() {\n    let str1 = gives_ownership(); // gives_ownership 将返回值所有权移给 str1, str1进入作用域\n    // str1 的所有权被移动到 takes_and_gives_back 中, 且也将返回值移给 str2\n    let str2 = takes_and_gives_back(str1);\n} // str1 已被移出, str2 被Drop\n\nfn gives_ownership() -&gt; String {\n    let strs = String::from(&quot;hello&quot;); // strs 进入作用域.\n    strs // 返回 strs 并移出所有权给函数调用者\n}\n\nfn takes_and_gives_back(strs: String) -&gt; String { // strs 进入作用域\n\n    strs  // 返回 strs 并移出所有权给函数调用者\n}但这样总是把值传来传去会让语法变得啰嗦, 很不优雅, 这时我们可以传递引用\nrustfn main() {\n    let mut strs = String::from(&quot;hello&quot;);\n\n    let len = calculate_length(&amp;strs); // &amp;strs 作用域结束\n\n    println!(&quot;The length of &#39;{}&#39; is {}.&quot;, strs, len);\n\n    change(&amp;mut strs);\n\n    println!(&quot;{}&quot;, strs);\n}\n\nfn calculate_length(s: &amp;String) -&gt; usize {\n    s.len()\n}\n\nfn change(some_string: &amp;mut String) {\n    some_string.push_str(&quot;, world&quot;);\n}匿名函数Rust 使用 Closure (闭包) 创建匿名函数\nrustlet out = 12; // 闭包可使用外部变量\nlet num1 = |i,j|i+j+out; // 闭包可根据上下文自动推导类型\nlet num2 = |i:i32,j:i32|i*j+out; // 也可以指定类型\nlet a = 1;\nlet b = 2;\nlet c = num1(a,b);\nlet d = num2(a,b);\nprintln!(&quot;{},{}&quot;,c,d);其中 || 之间是闭包的参数, 其后是函数的主体, 闭包 num1 借用了它作用域中的 let 绑定 out. 如果要让闭包获得所有权, 可以使用 move 关键字\nrustlet mut num = 5;\n\n{\n    let mut add = move |x: i32| num += x;   // 闭包通过 move 获取了 num 的所有权\n    add(5);\n}\n// 下面的 num 在被 move 之后还能继续使用是因为其实现了 Copy trait\nassert_eq!(5, num);高阶函数Rust 支持高阶函数, 允许闭包作为参数\nrustfn add_one(x: i32) -&gt; i32 { x + 1 }\n\nfn apply&lt;F&gt;(f: F, y: i32) -&gt; i32 // 接受一个类型F与i32, 返回i32\n    where F: Fn(i32) -&gt; i32// 对类型 F 的约束\n{\n    f(y) * y // 函数体\n}\n\nfn factory(x: i32) -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {\n    //返回一个函数\n    Box::new(move |y| x + y)\n}\n\nfn main() {\n    let transform: fn(i32) -&gt; i32 = add_one;//函数指针\n    let f0 = add_one(2i32) * 2;\n    let f1 = apply(add_one, 2);\n    let f2 = apply(transform, 2);\n    println!(&quot;{}, {}, {}&quot;, f0, f1, f2);//这三个是相等的\n\n    let closure = |x: i32| x + 1;\n    let c0 = closure(2i32) * 2;\n    let c1 = apply(closure, 2);\n    let c2 = apply(|x| x + 1, 2);\n    println!(&quot;{}, {}, {}&quot;, c0, c1, c2);\n\n    let box_fn = factory(1i32);\n    let b0 = box_fn(2i32) * 2;\n    let b1 = (*box_fn)(2i32) * 2;\n    let b2 = (&amp;box_fn)(2i32) * 2;\n    println!(&quot;{}, {}, {}&quot;, b0, b1, b2);\n\n    let add_num = &amp;(*box_fn);\n    let translate: &amp;Fn(i32) -&gt; i32 = add_num;\n    let z0 = add_num(2i32) * 2;\n    let z1 = apply(add_num, 2);\n    let z2 = apply(translate, 2);\n    println!(&quot;{}, {}, {}&quot;, z0, z1, z2);\n}复合类型结构体Struct 是一种记录类型, 所包含的每个 Field (域) 都有一个名称, 每个结构体也都有一个名称, 通常以 大写字母 开头, 使用 驼峰命名法. 元组结构体是由 元组 和 结构体 混合构成, 元组结构体有名称, 但是它的域没有. 当元组结构体只有一个域时, 称为New Type (新类型). 没有域的结构体, 称为类单元结构体. 结构体中的值默认是不可变的, 需要给结构体加上 mut 使其可变\nruststruct Student {\n    name: String,\n    grade: i8,\n    class: i8,\n    id: i8,\n}\nlet mut bob = Student {\n    name: String::from(&quot;Bob&quot;),\n    class: 1,\n    grade: 2,\n    id: 123,\n};\nbob.grade = 1;\n\nstruct Color(u8, u8, u8);\nlet android_green = Color(0xa4, 0xc6, 0x39);\n// 解构\nlet Color(red, green, blue) = android_green;\n\nstruct Inches(i32);\nlet length = Inches(10);\nlet Inches(integer_length) = length;\n\nstruct EmptyStruct;\nlet empty = EmptyStruct;枚举枚举 是一种代表一系列子数据类型的集合, 可用于分类, 但是相较于其他语言, 还可以携带数据类型, 可以被称为 重装枚举. 枚举可以通过 ::来获得每个元素的名称\nrustenum Book {\n    Pbook(u32),\n    Ebook { url: String },\n}\nlet book = Book::Pbook(1010);\nlet _ebook = Book::Ebook {\n    url: String::from(&quot;https://xx.xx&quot;),\n};与结构体一样, 枚举中的元素默认不能使用关系运算符进行比较 (如 ==, !=, &gt;=), 也不支持像 + 和 * 这样的双目运算符, 均需要自己实现, 或者使用 match 进行匹配。\nC 语言风格的枚举Rust 的枚举也可以像 C 语言那样\nrust// 拥有隐式辨别值 (implicit discriminator, 从 0 开始) 的 enum\nenum Number {\n    Zero,\n    One,\n    Two,\n}\n\n// 拥有显式辨别值 (explicit discriminator) 的 enum\nenum Color {\n    Red = 0xff0000,\n    Green = 0x00ff00,\n    Blue = 0x0000ff,\n}\n\nfn main() {\n    // `enum` 可以转成整型。\n    println!(&quot;zero 是 {}&quot;, Number::Zero as i32);//as 用来类型转换\n    println!(&quot;one 是 {}&quot;, Number::One as i32);\n\n    println!(&quot;玫瑰是 #{:06x} 色的&quot;, Color::Red as i32);\n    println!(&quot;天空是 #{:06x} 色的&quot;, Color::Blue as i32);\n}Module 与可见性当项目越来越大, 把所有代码都塞进 main.rs 或 lib.rs 几乎是不可能的, 或者有的时候我们需要人为控制代码的可见性, 这个时候我们就需要 Module (模块) 来管理我们的项目结构\n可以通过 mod 关键字 + mod_name 来开辟一个新的 Module, 默认情况下父 Module 或同级 Module 无法访问子 Module, 而子 Module 可以访问所有的父 Module\n如果是在单个文件中, mod_name 后面直接跟一个 {}, 并在内部放入其成员\nrustmod a_module {\n    // Some code\n}当然, Module 最重要的功能还是将代码分到不同的文件中, 这种情况下 mod_name 后面直接加 ; 即可, 我们在 main.rs 中声明三个 Module\nrustmod mod1;\nmod mod2;\nmod mod3;下面是一段文件树示例\ntxtsrc\n├─ main.rs\n├─ mod3.rs // 内容: mod file3;\n├─ mod3\n│  └─ file3.rs\n├─ mod2\n│  ├─ mod.rs // 内容: mod file2;\n│  └─ file2.rs\n└─ mod1.rs我们能发现有三种不同的方式用于将代码分入不同的文件:\n\n直接在 src 文件夹下新建与 Module 同名的文件\n在 src 文件夹下新建与 Module 同名的文件夹并在内部新建 mod.rs 文件, 同时这个文件夹内也可以新建其他 Module 并在 mod.rs 文件中声明\n同时在 src 文件夹中新建与 Module 同名的文件和文件夹, 而这个同名的文件可以起到上一条中 mod.rs 文件的作用\n\nCrate 本身就是其下所有模块的父模块, Module 层层嵌套就组成了模块树\n通过路径引用模块路径通过 :: 操作符进行分隔, 分为两种:\n\n相对路径:\n由当前模块的同级模块出发, 引用其内部成员. current_mod::inner_function()\n由父模块出发引用其他子模块内部成员, 需要 super 关键字. super::another_mod::inner_function()\n由当前模块出发, 引入自己的内部成员, 需要 self 关键字. self::my_function(). 比如在 Module 内部的一个函数需要引用这个 Module 的另一个函数时\n\n\n绝对路径: 就像之前说的, Crate 就是最高的父模块, 可以直接由 Crate 出发一步步走向内部成员, 需要 crate 关键字. crate::sub_mod::inner_function()\n\n代码可见性下面这段代码看似合理, 但实际上并不能运行, 就像我们之前说的, Module 默认是对父 Module 不可见的\nruststruct Int(i32)\n\nmod inner {\n    fn return_one() -&gt; Int {\n        Int(1)\n    }\n}\n\nlet one = inner::return_one();可以通过 pub 关键字使内部成员公开\nrustmod inner {\n    pub fn return_one() -&gt; Int {\n        Int(1)\n    }\n}注意, Struct 即使对外公开, 其内部 Field 仍然默认私有, 也需要 pub 关键字才能访问, 而 Enum 类型一旦公开, 其内部所有变体自动公开\nrustmod inner {\n    pub struct Point {\n        pub x: i32,\n        y: i32\n    }\n\n    pub enum Bool {\n        True,\n        False\n    }\n}\n\nlet p = inner::Point {\n    // x 是 pub 的, 可以访问\n    x: 0,\n    // y 是 private 的, 无法访问, 此行会报错, 应给给 Point 的 y 也加上 pub\n    y: 0\n};\n\nlet b = inner::Bool::True;pub 关键字还可以在后面加上一些限制\nrustpub(crate) // 只在当前 Crate 公开\npub(super) // 只在当前父 Module 公开\npub(self) // 只在当前 Module 公开\npub(in a::b) // 在指定模块公开如果是多重嵌套的 Module, 为了访问最里面的 Module, 同样需要在 mod 前加上 pub 关键字\nrustmod out_mod{\n    pub mod inner_mod{\n        pub fn func(){\n            // Do something\n        }\n    }\n}\n\nout_mod::inner_mod::func()引入作用域上面我们已经成功地将代码拆分到了不同的文件中. 但是有一个问题, 比如 out_mod::inner_mod::func(), 要是每次调用函数都要用上这一坨, 那任谁也受不了\n这种时候, 我们就可以通过 use 关键字将一个成员引入我们的作用域, 使其在当前 Module 以及所有子 Module 持续可用\n还是上面的例子\nrustmod out_mod{\n    pub mod inner_mod{\n        pub fn func(){\n            // Do something\n        }\n    }\n}\n\nuse out_mod::inner_mod::func;\n\nfn use1() {\n    func()\n}\n\nfn use2() {\n    func()\n}\n// ...我们知道 Crate 本身就是一个顶级 Module, 因此我们也可以使用 use 将第三方库中的代码引入我们的作用域\n可以通过 {} 一次引入多个成员, 用 , 隔开, 可以通过 * 引入一个模块下所有的公开成员. 同样可以通过 self 关键字引入 Module 自身\nrustuse crate1::mod1::{self, mod2::*, item};\n\nmod1::some_func();\nitem();重导出可以通过 pub 关键字将 use 引入的成员在当前 Module 再次公开, 以让 Module 可以通过这个 Module 来访问那些成员\nrustmod mod1 {\n    fn func() {\n        // Do something\n    }\n}\n\nmod mod2 {\n    pub use mod1::func;\n}\n\nmod2::func;这对于集中管理公开成员非常有帮助, 事实上, Rust 为每一个项目都隐式的添加了 use std::prelude::*, 它就通过重导出其他模块的常用成员, 可以非常方便快捷的引入这些常用的功能. 在编写 Lib Crate 时也可以创建一个 prelude Module 来集中管理常用成员\n","slug":"RustCourse-04","date":"2021-06-08T04:10:27.000Z","categories_index":"Course","tags_index":"Rust","author_index":"芳塔洛斯"},{"id":"4b0f692f776f3adc938ca1b3146c2dd5","title":"初识 Rust(2) | 你好, 世界!","content":"Hello RustHello World学习一门语言的传统都是打印 Hello World, 下面让我们用 Rust 的方式向世界问好\n创建一个 Rust 文件打开 VSCode, 新建一个文件夹用于存放我们的代码, 在里面新建一个 main.rs 文件 (Rust的习惯后缀名为 .rs 虽然在只用 Rustc 编译时别的后缀名也能通过)\n关于文件命名, Rust采用 蛇形命名法, 如果名字有多个单词, 无需 有大写字母, 而是采用 _ 来分隔每一个单词，如 hello_world.rs, 尽量避免使用 ASCII 字符以外的字符, 不要以数字开头\n编写并运行第一个Rust程序rust// main.rs\nfn main() {\n    println!(&quot;Hello World!&quot;);\n}在 main.rs 文件上单击右键，选择 在终端中打开, 然后执行以下命令\nshrustc main.rs &amp;&amp; main终端上会输出\ntxtHello World!分析这个程序好了, 我们已经创建了第一个 Rust 程序了, 但这段代码到底是什么意思呢? 现在让我们来分析一下:\n\nfn 表示定义一个 函数, main 是这个函数的名字, 花括号 {} 里的语句则是这个函数的内容, Rust 要求所有函数体都要用花括号包裹起来. 一般来说, 将左花括号与函数声明置于同一行并以空格分隔, 是良好的代码风格\n名字为 main 的函数在 Rust 里有特殊的作用, 即程序的入口, 程序就是从这里开始执行的\nprintln!()是一个宏, 它的功能是打印圆括号()中的内容并换行, ! 是宏的标志, 如果是调用函数，则没有 !\n在 Rust 中, 语句的末尾一般用分号 ; 作为结束标志\nRust 程序的编译与运行是彼此独立的, 在运行 Rust 程序之前, 必须先使用 Rust 编译器编译它, 即输入 rustc 命令并传入源文件名称\nRust 是一种 预编译静态类型 语言, 这意味着你可以编译程序, 并将可执行文件送给其他人, 他们甚至不需要安装 Rust 就可以运行. 这与解释性语言不同\n\nHello Cargo仅仅使用 Rustc 编译简单程序是没问题的, 不过随着项目的增长, Rustc 就会难以满足需要, 这种时候就需要包管理工具了\ncargo简介代码管理对于编程来说一直是一个重要的问题, 各种不同的语言也都会采用不同的代码管理器, Rust 作为一枚现代语言, 综合了现有语言管理工具的优点, 为我们提供了一个大杀器 — Cargo\n作为 Rust 的代码组织管理工具, cargo 提供了一系列的工具. 从项目的建立, 构建到测试, 运行直至部署, 为 Rust 项目的管理提供尽可能完整的手段. 同时与 Rust 语言及其编译器 Rustc 本身的各种特性紧密结合\ncargo入门在我们安装 Rust 的时候就已经安装好了 Cargo\n创建项目新建一个文件夹并在终端中打开, 输入以下命令\nshcargo new hello_cargo --bin--bin 是一个参数, 代表这是一个 Bin crate, 最终将会被编译为二进制可执行文件, Cargo 默认创建 Bin crate, 所以该参数可以不加\n查看目录结构hello_cargo 文件夹下有一个 src 和一个 Cargo.toml 文件, src 文件夹下有一个 main.rs 文件，它也在 hello_cargo 目录初始化了一个 .git 仓库, 以及一个 .gitignore 文件, 在 VSCode 中我们可以很轻易地使用 Git\ntxthello_cargo\n├── Cargo.toml\n└── src\n    └── main.rs编辑 main.rs 并运行Cargo 初始化的 main.rs 里会有一些默认内容, 我们把它改为\nrust// hello_cargo/src/main.rs\nfn main() {\n    println!(&quot;Hello, Cargo!&quot;);\n}随后在终端输入以下命令\nshcargo build # Debug 模式\ncargo build --release # Release 模式 --release 代表优化编译也可以直接使用 cargo run 命令编译并运行\n这两个命令分别会在以下文件夹下生成可执行文件\ntxt./target/debug/hello_cargo.exe\n./target/release/hello_cargo.exeCrate 与 Package我们说过 Cargo 是一个强大的包管理工具, 让我们先来介绍以下几个概念:\n\nCrate: 通常翻译为 包, 包括 Bin Crate (将被编译为可执行文件) 和 Lib Crate (将被编译为库文件)\nPackage: 包的名字已经被 Crate 占用, 这里可以被理解为 项目, 一个 Package 包括至多一个 Lib Crate 或任意数量得 Bin Crate 或者两者同时存在. 这一概念容易和 Crate 混淆, 一个方便理解得例子是对于 Bin Crate, 当我们初始化一个 Bin Crate 时看起来就像一个 Package, 这是因为这个 Crate 和 Package 的名字是一样的, 都是项目名. 但别忘了我们还可以在项目中创建其他的不同名字的将被编译为可执行文件的 .rs 文件\nWorkSpace: 工作空间, 用于在大型项目中组织多个 Package\n\n一个标准 Cargo Package 目录结构通常如下:\n\ncargo.toml 和 cargo.lock 文件位于项目根目录\n源代码位于 src\n默认的 Lib crate 入口文件是 src/lib.rs\n默认的 Bin crate入口文件是 src/main.rs\n其他可选的可执行文件位于 bin/*.rs (这里每一个rs文件均对应一个可执行文件)\n外部测试源代码文件位于 tests\n示例程序源代码文件位于 examples\n基准测试源代码文件位于 benches\n\nCargo.tomlCargo 的项目数据描述文件, 存储了项目的所有信息\ntoml[package]\nname = &quot;hello_cargo&quot;\ndescription = &quot;&quot;\nversion = &quot;0.1.0&quot;\nauthors = [&quot;YourName &lt;Your email&gt;&quot;]\nedition = &quot;2021&quot;\n\n[dependencies]\ncrate1 = &quot;0.3&quot;\ncrate2 = &quot;0.2*&quot;\ncrate3 = { version = &quot;0.5.0&quot;}\ncrate4 = { git = &quot;https://github.com/name/crate_name&quot; }\ncrate5 = { path = &quot;path/crate_name&quot; }TOML 是Rust的官方配置文件格式, 由像 [package] 或 [dependencies] 这样的段落组成, 每一个段落又由多个字段组成, 这些段落和字段就描述了项目组织的基本信息\n\npackage 段落\nname 字段表明项目的名称. 当发布 crate时, crates.io 将使用此字段标明的名称. 这也是编译时输出的二进制可执行文件的名称\nversion 字段是使用 语义版本控制 的 crate 版本号\ndescription 字段是对项目的描述\nauthors 字段表明发布 crate 时的作者列表\nedition 字段是对项目的 Edition (版次) 声明, 作为一门成熟的语言很重要的一点就是向后兼容. 但有的时候, 面对一些历史遗留问题, 做出一些不兼容的更改也是有需要的, Rust 通过不同的版次引入不兼容的新特性或者删除旧的特性\n\n\ndependencies 段落可以让你为项目添加依赖, 包括一下几种:\n基于 Rust 官方仓库, 通过版本说明来描述\n基于项目源代码的 Git 仓库地址, 通过 URL 来描述\n基于本地项目的绝对路径或者相对路径\n\n\n\n而对于 WorkSpace, Cargo.toml 的内容可能是这样的\ntoml[workspace]\nmembers = [\n    &quot;path/crate1&quot;,\n    &quot;path/crate2&quot;,\n    &quot;...&quot;\n]Cargo.lock该不需要直接修改, 是 Cargo 工具根据 Cargo.toml 生成的项目依赖详细清单文件\n定义集成测试用例Cargo 另一个重要的功能, 即将软件开发过程中必要且非常重要的测试环节进行集成, 并通过代码属性声明或者 Cargo.toml 文件描述来对测试进行管理\n单元测试主要通过在项目代码的测试代码部分前用 #[test] 属性来描述\n集成测试一般都会通过 Cargo.toml 文件中的 [[test]] 段落进行描述\n简单的示例:\ntoml[[test]]\nname = &quot;test1&quot;\npath = &quot;tests/test1.rs&quot;\n\n[[test]]\nname = &quot;test2&quot;\npath = &quot;tests/test2.rs&quot;上述例子中, name 字段定义了集成测试的名称, path 字段定义了集成测试文件相对于 Cargo.toml 的路径.\n看看，定义集成测试就是如此简单, 但需要注意的是:\n\n如果没有在 Cargo.toml 里定义集成测试的入口, 那么tests 目录(不包括子目录)下的每个 .rs 文件被当作集成测试入口\n如果在 Cargo.toml 里定义了集成测试入口, 那么定义的那些 .rs 文件就是入口, 不再默认指定任何集成测试入口.\n\n定义示例和可执行文件Example 用例的描述以及 Bin 用例的描述也是 Cargo 的常用功能\ntoml[[example]]\nname = &quot;examlpe1&quot;\npath = &quot;examples/examlpe1.rs&quot;\n\n[[bin]]\nname = &quot;bin1&quot;\npath = &quot;bin/bin1.rs&quot;对于 [[example]] 和 [[bin]] 段落中声明的Examples 和 Bins，需要通过 cargo run --example &lt;NAME&gt; 或者 cargo run --bin &lt;NAME&gt; 来运行\n其他Cargo命令\ncargo clean: 清理 target 文件夹中的所有内容\ncargo update: 根据 Cargo.toml 重新检索并更新各种依赖项的信息, 并写入 Cargo.lock\ncargo install: 安装 crates.io 可用于实际的生产的可执行文件\ncargo fmt: 代码格式化工具\n\n从这开始, 请把 Cargo 当作习惯, 对于简单项目, Cargo 并不比 Rustc 提供了更多的优势, 不过随着开发的深入, 终将证明其价值\n注释与文档最后, 让我们学习一下 Rust 的注释\nRust中有三种注释，前两种分别为:\n\n行注释 //...\nC 语言风格的块注释 /*...*/\n\nrust// 创建一个绑定\nlet x = 5;\nlet y = 6; // 创建另一个绑定\n\n/*这是一段块注释*/let a = 1;/*块注释不影响块以外的代码*/\n/*\n块注释可以有很多行\n*/Rust的第三种注释是 文档注释 ,文档注释又分为两小种, 支持 Markdown 语法:\n\n//! 模块注释, 用来描述包含它的项, 一般用在模块文件的头部\n/// 用来描述的它后面接着的项\n\nrust//! 这是一个模块\n/// Add One\n/// # Example\n/// ```rust\n/// let one = 1;\n///\n/// assert_eq!(2, add_one(one));\n/// fn add_one(x: i32) -&gt; i32 {\n///     x + 1\n/// }\n/// ```\nfn add_one(x: i32) -&gt; i32 {\n  x + 1\n}生成文档Rust 工具链可以很轻易地从文档注释中生成漂亮的 HTML 文档:\n\nrustdoc *.rs: 用于单个文件\ncargo doc: 用于整个项目\n\n","slug":"RustCourse-02","date":"2021-04-05T04:36:07.000Z","categories_index":"Course","tags_index":"Rust","author_index":"芳塔洛斯"},{"id":"56db3bc75e0f5c25df1df7381c2e80ef","title":"初识 Rust(1) | Rust 环境配置","content":"简介Rust, 连续七年成为全世界最受欢迎的语言, 一门系统级, 多范式,赋予每个人构建可靠且高效软件能力的语言, 如今被越来越多的大公司所接受, 并成功进入 Windows, Linux, Android 等主流操作系统的内核\n只要你喜欢编程, 无论是否用于参与工作, 相信学习这门语言都能让你受益匪浅\n这是一个非官方的 Rust 语言简易教程, 在实践中编写并加入了自己的理解和一些在其他教程中可能很少会被提到的琐碎之物\nRust环境配置安装C++build toolRust 依赖 C 的链接器等组件, 所以电脑上至少要存在一个 C&#x2F;C++ 编译环境\nWindows安装VisualStudio可以在 单个组件 选择只安装需要的组件, 关键词如下\n\nMSVC C&#x2F;C++ 生成工具\n适用于最新生成工具的 C++ ATL\nWindows SDK\n\n担心出问题或者觉得麻烦也可以直接在 工作负载 选择 使用 C++ 的桌面开发\n\n\n\n\n\n\n\n\n\n注: 可以选择 MinGW, 但是 Windows下还是更推荐 MSVC 环境\nMac &amp; Linux\nMac 需要安装 Xcode\n\nshxcode-select --install\n# 如果已安装则会显示已安装\nLinux 需要安装 GCC 或 Clang, 用系统对应的包管理器直接安装即可\n\n安装Rust配置镜像源因为Rust的服务器在国外, 安装速度较慢, 所以我们可以考虑使用镜像源\n这里使用 字节跳动 源\nsh# Windows 直接在系统变量下加入以下两条\n# 注意: 不是 Path 环境变量\nRUSTUP_UPDATE_ROOT\nhttps://rsproxy.cn/rustup\n\nRUSTUP_DIST_SERVER\nhttps://rsproxy.cn\n\n# Mac &amp; Linux 可以在终端执行以下两行命令\n# 或者将这两行粘贴到终端的配置文件中(如~/.bashrc)\nexport RUSTUP_UPDATE_ROOT=https://rsproxy.cn/rustup\nexport RUSTUP_DIST_SERVER=https://rsproxy.cnWindows如果不想安装在 C 盘的话需要提前配置两个系统变量\n再在系统变量中加入以下两条, 下面为示例\nshRUSTUP_HOME\nD:/Rust/rustup\n\nCARGO_HOME\nD:/Rust/cargo在官网 Rust-lang 下载 rustup-init.exe并运行\nMac &amp; Linux直接在终端执行\nshcurl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh环境配置安装选项运行安装程序后, 终端会输出 Current installtion options\n\n输入 1 执行安装\n输入 2 进行自定义选项\n其中最主要的配置就是 Rust 的版本, 包括:\nStable: 稳定版的 Rust, API 与语言特性不会更改, 保持向后兼容\nBeta: 测试版的 Rust, 测试一些即将加入 Stable 的新功能\nNightly: 每日更新版的 Rust, 有最前沿的功能和不稳定特性\n\n\n\n\n输入 3 取消安装\n\n随后将 CARGO_HOME/bin 加入环境变量(如 Windows 的 Path)\n最后, 可以在 CARGO_HOME 文件夹下新建 config.toml 添加一些全局配置\ntoml# 定义一些命令别名\n[alias]\n# cargo b\nb = &quot;build&quot;\nc = &quot;check&quot;\nt = &quot;test&quot;\nr = &quot;run&quot;\n\n[build]\n# 利用编译缓存加快编译\n# 需要安装 sscache 并配置 SCCACHE_DIR\nrustc-wrapper = &quot;sccache&quot;\n\n[target.x86_64-pc-windows-msvc]\n# Windows 上比 link 更快的链接器\nlinker = &#39;rust-lld.exe&#39;\n\n# 替换默认 crate 源\n[source.crates-io]\nreplace-with = &#39;rsproxy-sparse&#39;\n\n# 字节跳动的 crate 源\n[source.rsproxy]\nregistry = &quot;https://rsproxy.cn/crates.io-index&quot;\n\n# 通过 sparse 算法加速检索\n[source.rsproxy-sparse]\nregistry = &quot;sparse+https://rsproxy.cn/index/&quot;\n\n[registries.rsproxy]\nindex = &quot;https://rsproxy.cn/crates.io-index&quot;\n\n# 使用系统自带的 git-cli 加速检索\n[net]\ngit-fetch-with-cli = true\n\n[http]\ncheck-revoke = false验证安装终端输入\nshrustc -V\ncargo -V安装编辑器截止到目前, JetBrain 推出了 Rust 的专用 IDE RustRover, 但还不是很完善\n这里推荐VSCode + RA\n\n\n\n\n\n\n\n\n\nRust-Analyer(简称RA)是由Rust社区维护的RLS 2.0, RLS有的它更好, RLS没有的它还有, 原来的官方插件已废弃, 现在 RA 正式进入 Rust 官方 Repository, 所以更推荐安装这一个. 更多内容可以浏览它官网的用户手册\n下面是其他的可能需要的插件\n\nChinese (Simplified) 简体中文插件\nCrates Rust Crate 版本检查插件\nEven Better Toml 更好的 Toml 语言插件\nCodeium 一个类似 Copilot 的 AI 代码提示插件\nCodeLLDB 可以用于调试 Rust 代码, 但功能有限, 需要安装对应的组件 rustup component add llvm-tools\n\n至此, Rust 语言环境配置完毕\nFerris既然是初识, 那让我们也来先了解一些 Rust 语言的故事, 比如, 先从封面那只可爱的小螃蟹说起\n这只小螃蟹叫 Ferris, 是 Rust 社区为 Rust 语言制作的吉祥物\n红色的外表难免让人产生一些疑问: 它为什么是个熟螃蟹呢?\n对不起, 这不是熟的, 还请给 Ferris 道个歉!\n除了大家所熟知的 Rust 游戏和我们今天介绍的 Rust 语言, 别忘了 Rust 最初的含义 — 锈, 而锈中的代表物, 铁锈, Fe₂O₃ 就是类似这种红色\n社区中常常打着 REIR (Rewrite Everything In Rust) 的旗号, 而用 Rust 重写某个组件的过程常常被称为 「氧化」 . 比如有一个为Python编写Rust扩展的库, 就叫PyO3, 也有许多库从诞生时名字就以 Dio (二氧化物) 开头.\n至于为什么选个螃蟹当吉祥物, 或许这是因为 Rust 开发者们的一个自称 — Rustacean, 因为这个词是 「甲壳纲动物」 这个单词 Crustacean (krʌ’steʃən) 去掉了首字母 C 演变而来的, 去掉了C 就露出了 Rust 这四个字母, 或许还含有着去掉 C 用 Rust 重写之意. 而在甲壳纲动物里对大家而言螃蟹应该是最熟悉的了吧。\n","slug":"RustCourse-01","date":"2021-04-05T01:54:09.000Z","categories_index":"Course","tags_index":"Rust","author_index":"芳塔洛斯"},{"id":"8173c9ee4324b3b3ef1ff94914260b8e","title":"如何给文章分类","content":"对于博客写作, 无论是为了方便自己回顾还是方便别人查阅, 分类都是很重要的问题\n一个主流的方法是 Category (类别) 与 Tag (标签) 相结合的体系\nCategory 与 Tag 的区别\nCategory 说明文章是什么, 是大方向, 是文章的本质, 与文章是一对一的关系, 文章属于 Category, 比较僵硬\nTag 说明文章有什么, 是细节补充, 是文章的性质, 一篇文章可以有多个 Tag, Tag 属于文章, 比较灵活\n\n如何设计 Category 与 Tag你可能在很多地方看到过一些分类设计, 比如图书馆对书的分类法, 哲学, 人文 ,自然科学 …\n但我们不需要那样全面, 因为我们不会有那么广的写作方向, 只要根据自己擅长且经常写作的的内容来来规划就可以\n如果不明白大方向, 那可以考虑先写上那么十几篇, 然后回过头来看, 分大类并抽象其共同特征\n不重不漏设计分类的第一个原则, 这一点不言而喻. 有的时候, 我们可以添加一个用于兜底的 Category 存放一时半会无法准确分类的文章\n如无必要, 勿增实体设计分类的第二大原则, 要用尽量少的分类标准囊括最大的范围无论是 Category 还是 Tag, 如果极端到仅仅会有一篇文章用上了, 那就证明这个类别是有问题的, 需要进一步抽象, 合并. 比如在写读书心得的时候, 有的时候可能书比较精简, 用一篇文章就完成了写作 ,那么就没必要把这本书的题目作为一个 Tag, 可以用更宽泛的 读书笔记 一类的 Tag加以概括, 具体类别通过将书名加入到文章标题里进行体现\n同样的, 一些比较冷门的内容都可以这样做. 对于 Tag, 我们可以先做一个高度抽象抽象的大类, 对于频繁出现的, 加入更详细的 Tag进行补充\n比如, 经常写一些关于 Vue 前端框架的文章, 就可以打上 JS Vue 的 Tag, 而偶尔可能会会提一嘴新生的暂时比较冷门的框架, 就可以仅仅打上一个 JS 的 Tag\n简洁明了设计分类的第三大原则, 不要让别人, 或者过了很久之后自己看到都会感到费解, 比如 Methodology (方法论), 这可能适合这篇文章, 但这个词很长且不是每个人都认识, 因此可以用 Tip 等大多数人都能理解的 Tag 代替或者补充\n如何设计 Category 与 Tag树状判断对于分类, 我们可以建立一个树状的判断图\n比如我目前的 Category\n\n是否属于系列文章\n是\n对自己的一些项目追踪记录: Trace\n建站过程\n软件开发过程\n读一本书的心得体会\n\n\n对同一事物的系列教程: Course\n对一门编程语言的教程\n\n\n\n\n否\n是否有明确的推荐分享性质\n是: Share\n对一些小工具的介绍\n对一些库的介绍\n\n\n否\n日常随记: Note\n对一些知识点的备忘\n对一些经验的记录\n对一些问题的解决方法的记录\n\n\n一些杂谈: Other\n\n\n\n\n\n\n\n\n\n定期整理最后, 无论多么精心设计一套分类体系, 都不可能尽善尽美, 定期的整理才能让文章体系保持清晰\n","slug":"2021-02-21","date":"2021-02-21T01:54:09.000Z","categories_index":"Other","tags_index":"Methodology,Tip","author_index":"芳塔洛斯"}]